diff -Naur itcl/tcl_hdrs/tclIntDecls.h ITCL_BLD/tcl_hdrs/tclIntDecls.h
--- itcl/tcl_hdrs/tclIntDecls.h	1969-12-31 19:00:00.000000000 -0500
+++ ITCL_BLD/tcl_hdrs/tclIntDecls.h	2024-08-06 13:05:23.857800591 -0400
@@ -0,0 +1,1434 @@
+/*
+ * tclIntDecls.h --
+ *
+ *	This file contains the declarations for all unsupported
+ *	functions that are exported by the Tcl library.  These
+ *	interfaces are not guaranteed to remain the same between
+ *	versions.  Use at your own risk.
+ *
+ * Copyright (c) 1998-1999 by Scriptics Corporation.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TCLINTDECLS
+#define _TCLINTDECLS
+
+
+#undef TCL_STORAGE_CLASS
+#ifdef BUILD_tcl
+#   define TCL_STORAGE_CLASS DLLEXPORT
+#else
+#   ifdef USE_TCL_STUBS
+#      define TCL_STORAGE_CLASS
+#   else
+#      define TCL_STORAGE_CLASS DLLIMPORT
+#   endif
+#endif
+
+/* [Bug #803489] Tcl_FindNamespace problem in the Stubs table */
+#undef Tcl_CreateNamespace
+#undef Tcl_DeleteNamespace
+#undef Tcl_AppendExportList
+#undef Tcl_Export
+#undef Tcl_Import
+#undef Tcl_ForgetImport
+#undef Tcl_GetCurrentNamespace
+#undef Tcl_GetGlobalNamespace
+#undef Tcl_FindNamespace
+#undef Tcl_FindCommand
+#undef Tcl_GetCommandFromObj
+#undef Tcl_GetCommandFullName
+#undef Tcl_SetStartupScript
+#undef Tcl_GetStartupScript
+
+/*
+ * WARNING: This file is automatically generated by the tools/genStubs.tcl
+ * script.  Any modifications to the function declarations below should be made
+ * in the generic/tclInt.decls script.
+ */
+
+/* !BEGIN!: Do not edit below this line. */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Exported function declarations:
+ */
+
+/* Slot 0 is reserved */
+/* Slot 1 is reserved */
+/* Slot 2 is reserved */
+/* 3 */
+EXTERN void		TclAllocateFreeObjects(void);
+/* Slot 4 is reserved */
+/* 5 */
+EXTERN int		TclCleanupChildren(Tcl_Interp *interp, int numPids,
+				Tcl_Pid *pidPtr, Tcl_Channel errorChan);
+/* 6 */
+EXTERN void		TclCleanupCommand(Command *cmdPtr);
+/* 7 */
+EXTERN int		TclCopyAndCollapse(int count, const char *src,
+				char *dst);
+/* 8 */
+EXTERN int		TclCopyChannelOld(Tcl_Interp *interp,
+				Tcl_Channel inChan, Tcl_Channel outChan,
+				int toRead, Tcl_Obj *cmdPtr);
+/* 9 */
+EXTERN int		TclCreatePipeline(Tcl_Interp *interp, int argc,
+				const char **argv, Tcl_Pid **pidArrayPtr,
+				TclFile *inPipePtr, TclFile *outPipePtr,
+				TclFile *errFilePtr);
+/* 10 */
+EXTERN int		TclCreateProc(Tcl_Interp *interp, Namespace *nsPtr,
+				const char *procName, Tcl_Obj *argsPtr,
+				Tcl_Obj *bodyPtr, Proc **procPtrPtr);
+/* 11 */
+EXTERN void		TclDeleteCompiledLocalVars(Interp *iPtr,
+				CallFrame *framePtr);
+/* 12 */
+EXTERN void		TclDeleteVars(Interp *iPtr,
+				TclVarHashTable *tablePtr);
+/* Slot 13 is reserved */
+/* 14 */
+EXTERN int		TclDumpMemoryInfo(ClientData clientData, int flags);
+/* Slot 15 is reserved */
+/* 16 */
+EXTERN void		TclExprFloatError(Tcl_Interp *interp, double value);
+/* Slot 17 is reserved */
+/* Slot 18 is reserved */
+/* Slot 19 is reserved */
+/* Slot 20 is reserved */
+/* Slot 21 is reserved */
+/* 22 */
+EXTERN int		TclFindElement(Tcl_Interp *interp,
+				const char *listStr, int listLength,
+				const char **elementPtr,
+				const char **nextPtr, int *sizePtr,
+				int *bracePtr);
+/* 23 */
+EXTERN Proc *		TclFindProc(Interp *iPtr, const char *procName);
+/* 24 */
+EXTERN int		TclFormatInt(char *buffer, long n);
+/* 25 */
+EXTERN void		TclFreePackageInfo(Interp *iPtr);
+/* Slot 26 is reserved */
+/* Slot 27 is reserved */
+/* 28 */
+EXTERN Tcl_Channel	TclpGetDefaultStdChannel(int type);
+/* Slot 29 is reserved */
+/* Slot 30 is reserved */
+/* 31 */
+EXTERN const char *	TclGetExtension(const char *name);
+/* 32 */
+EXTERN int		TclGetFrame(Tcl_Interp *interp, const char *str,
+				CallFrame **framePtrPtr);
+/* Slot 33 is reserved */
+/* 34 */
+EXTERN int		TclGetIntForIndex(Tcl_Interp *interp,
+				Tcl_Obj *objPtr, int endValue, int *indexPtr);
+/* Slot 35 is reserved */
+/* Slot 36 is reserved */
+/* 37 */
+EXTERN int		TclGetLoadedPackages(Tcl_Interp *interp,
+				const char *targetName);
+/* 38 */
+EXTERN int		TclGetNamespaceForQualName(Tcl_Interp *interp,
+				const char *qualName, Namespace *cxtNsPtr,
+				int flags, Namespace **nsPtrPtr,
+				Namespace **altNsPtrPtr,
+				Namespace **actualCxtPtrPtr,
+				const char **simpleNamePtr);
+/* 39 */
+EXTERN Tcl_ObjCmdProc *	 TclGetObjInterpProc(void);
+/* 40 */
+EXTERN int		TclGetOpenMode(Tcl_Interp *interp, const char *str,
+				int *seekFlagPtr);
+/* 41 */
+EXTERN Tcl_Command	TclGetOriginalCommand(Tcl_Command command);
+/* 42 */
+EXTERN CONST86 char *	TclpGetUserHome(const char *name,
+				Tcl_DString *bufferPtr);
+/* Slot 43 is reserved */
+/* 44 */
+EXTERN int		TclGuessPackageName(const char *fileName,
+				Tcl_DString *bufPtr);
+/* 45 */
+EXTERN int		TclHideUnsafeCommands(Tcl_Interp *interp);
+/* 46 */
+EXTERN int		TclInExit(void);
+/* Slot 47 is reserved */
+/* Slot 48 is reserved */
+/* Slot 49 is reserved */
+/* 50 */
+EXTERN void		TclInitCompiledLocals(Tcl_Interp *interp,
+				CallFrame *framePtr, Namespace *nsPtr);
+/* 51 */
+EXTERN int		TclInterpInit(Tcl_Interp *interp);
+/* Slot 52 is reserved */
+/* 53 */
+EXTERN int		TclInvokeObjectCommand(ClientData clientData,
+				Tcl_Interp *interp, int argc,
+				CONST84 char **argv);
+/* 54 */
+EXTERN int		TclInvokeStringCommand(ClientData clientData,
+				Tcl_Interp *interp, int objc,
+				Tcl_Obj *const objv[]);
+/* 55 */
+EXTERN Proc *		TclIsProc(Command *cmdPtr);
+/* Slot 56 is reserved */
+/* Slot 57 is reserved */
+/* 58 */
+EXTERN Var *		TclLookupVar(Tcl_Interp *interp, const char *part1,
+				const char *part2, int flags,
+				const char *msg, int createPart1,
+				int createPart2, Var **arrayPtrPtr);
+/* Slot 59 is reserved */
+/* 60 */
+EXTERN int		TclNeedSpace(const char *start, const char *end);
+/* 61 */
+EXTERN Tcl_Obj *	TclNewProcBodyObj(Proc *procPtr);
+/* 62 */
+EXTERN int		TclObjCommandComplete(Tcl_Obj *cmdPtr);
+/* 63 */
+EXTERN int		TclObjInterpProc(ClientData clientData,
+				Tcl_Interp *interp, int objc,
+				Tcl_Obj *const objv[]);
+/* 64 */
+EXTERN int		TclObjInvoke(Tcl_Interp *interp, int objc,
+				Tcl_Obj *const objv[], int flags);
+/* Slot 65 is reserved */
+/* Slot 66 is reserved */
+/* Slot 67 is reserved */
+/* Slot 68 is reserved */
+/* 69 */
+EXTERN char *		TclpAlloc(unsigned int size);
+/* Slot 70 is reserved */
+/* Slot 71 is reserved */
+/* Slot 72 is reserved */
+/* Slot 73 is reserved */
+/* 74 */
+EXTERN void		TclpFree(char *ptr);
+/* 75 */
+EXTERN unsigned long	TclpGetClicks(void);
+/* 76 */
+EXTERN unsigned long	TclpGetSeconds(void);
+/* 77 */
+EXTERN void		TclpGetTime(Tcl_Time *time);
+/* Slot 78 is reserved */
+/* Slot 79 is reserved */
+/* Slot 80 is reserved */
+/* 81 */
+EXTERN char *		TclpRealloc(char *ptr, unsigned int size);
+/* Slot 82 is reserved */
+/* Slot 83 is reserved */
+/* Slot 84 is reserved */
+/* Slot 85 is reserved */
+/* Slot 86 is reserved */
+/* Slot 87 is reserved */
+/* 88 */
+EXTERN char *		TclPrecTraceProc(ClientData clientData,
+				Tcl_Interp *interp, const char *name1,
+				const char *name2, int flags);
+/* 89 */
+EXTERN int		TclPreventAliasLoop(Tcl_Interp *interp,
+				Tcl_Interp *cmdInterp, Tcl_Command cmd);
+/* Slot 90 is reserved */
+/* 91 */
+EXTERN void		TclProcCleanupProc(Proc *procPtr);
+/* 92 */
+EXTERN int		TclProcCompileProc(Tcl_Interp *interp, Proc *procPtr,
+				Tcl_Obj *bodyPtr, Namespace *nsPtr,
+				const char *description,
+				const char *procName);
+/* 93 */
+EXTERN void		TclProcDeleteProc(ClientData clientData);
+/* Slot 94 is reserved */
+/* Slot 95 is reserved */
+/* 96 */
+EXTERN int		TclRenameCommand(Tcl_Interp *interp,
+				const char *oldName, const char *newName);
+/* 97 */
+EXTERN void		TclResetShadowedCmdRefs(Tcl_Interp *interp,
+				Command *newCmdPtr);
+/* 98 */
+EXTERN int		TclServiceIdle(void);
+/* Slot 99 is reserved */
+/* Slot 100 is reserved */
+/* 101 */
+EXTERN CONST86 char *	TclSetPreInitScript(const char *string);
+/* 102 */
+EXTERN void		TclSetupEnv(Tcl_Interp *interp);
+/* 103 */
+EXTERN int		TclSockGetPort(Tcl_Interp *interp, const char *str,
+				const char *proto, int *portPtr);
+/* 104 */
+EXTERN int		TclSockMinimumBuffersOld(int sock, int size);
+/* Slot 105 is reserved */
+/* Slot 106 is reserved */
+/* Slot 107 is reserved */
+/* 108 */
+EXTERN void		TclTeardownNamespace(Namespace *nsPtr);
+/* 109 */
+EXTERN int		TclUpdateReturnInfo(Interp *iPtr);
+/* 110 */
+EXTERN int		TclSockMinimumBuffers(void *sock, int size);
+/* 111 */
+EXTERN void		Tcl_AddInterpResolvers(Tcl_Interp *interp,
+				const char *name,
+				Tcl_ResolveCmdProc *cmdProc,
+				Tcl_ResolveVarProc *varProc,
+				Tcl_ResolveCompiledVarProc *compiledVarProc);
+/* 112 */
+EXTERN int		Tcl_AppendExportList(Tcl_Interp *interp,
+				Tcl_Namespace *nsPtr, Tcl_Obj *objPtr);
+/* 113 */
+EXTERN Tcl_Namespace *	Tcl_CreateNamespace(Tcl_Interp *interp,
+				const char *name, ClientData clientData,
+				Tcl_NamespaceDeleteProc *deleteProc);
+/* 114 */
+EXTERN void		Tcl_DeleteNamespace(Tcl_Namespace *nsPtr);
+/* 115 */
+EXTERN int		Tcl_Export(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
+				const char *pattern, int resetListFirst);
+/* 116 */
+EXTERN Tcl_Command	Tcl_FindCommand(Tcl_Interp *interp, const char *name,
+				Tcl_Namespace *contextNsPtr, int flags);
+/* 117 */
+EXTERN Tcl_Namespace *	Tcl_FindNamespace(Tcl_Interp *interp,
+				const char *name,
+				Tcl_Namespace *contextNsPtr, int flags);
+/* 118 */
+EXTERN int		Tcl_GetInterpResolvers(Tcl_Interp *interp,
+				const char *name, Tcl_ResolverInfo *resInfo);
+/* 119 */
+EXTERN int		Tcl_GetNamespaceResolvers(
+				Tcl_Namespace *namespacePtr,
+				Tcl_ResolverInfo *resInfo);
+/* 120 */
+EXTERN Tcl_Var		Tcl_FindNamespaceVar(Tcl_Interp *interp,
+				const char *name,
+				Tcl_Namespace *contextNsPtr, int flags);
+/* 121 */
+EXTERN int		Tcl_ForgetImport(Tcl_Interp *interp,
+				Tcl_Namespace *nsPtr, const char *pattern);
+/* 122 */
+EXTERN Tcl_Command	Tcl_GetCommandFromObj(Tcl_Interp *interp,
+				Tcl_Obj *objPtr);
+/* 123 */
+EXTERN void		Tcl_GetCommandFullName(Tcl_Interp *interp,
+				Tcl_Command command, Tcl_Obj *objPtr);
+/* 124 */
+EXTERN Tcl_Namespace *	Tcl_GetCurrentNamespace(Tcl_Interp *interp);
+/* 125 */
+EXTERN Tcl_Namespace *	Tcl_GetGlobalNamespace(Tcl_Interp *interp);
+/* 126 */
+EXTERN void		Tcl_GetVariableFullName(Tcl_Interp *interp,
+				Tcl_Var variable, Tcl_Obj *objPtr);
+/* 127 */
+EXTERN int		Tcl_Import(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
+				const char *pattern, int allowOverwrite);
+/* 128 */
+EXTERN void		Tcl_PopCallFrame(Tcl_Interp *interp);
+/* 129 */
+EXTERN int		Tcl_PushCallFrame(Tcl_Interp *interp,
+				Tcl_CallFrame *framePtr,
+				Tcl_Namespace *nsPtr, int isProcCallFrame);
+/* 130 */
+EXTERN int		Tcl_RemoveInterpResolvers(Tcl_Interp *interp,
+				const char *name);
+/* 131 */
+EXTERN void		Tcl_SetNamespaceResolvers(
+				Tcl_Namespace *namespacePtr,
+				Tcl_ResolveCmdProc *cmdProc,
+				Tcl_ResolveVarProc *varProc,
+				Tcl_ResolveCompiledVarProc *compiledVarProc);
+/* 132 */
+EXTERN int		TclpHasSockets(Tcl_Interp *interp);
+/* 133 */
+EXTERN struct tm *	TclpGetDate(const time_t *time, int useGMT);
+/* Slot 134 is reserved */
+/* Slot 135 is reserved */
+/* Slot 136 is reserved */
+/* Slot 137 is reserved */
+/* 138 */
+EXTERN CONST84_RETURN char * TclGetEnv(const char *name,
+				Tcl_DString *valuePtr);
+/* Slot 139 is reserved */
+/* Slot 140 is reserved */
+/* 141 */
+EXTERN CONST84_RETURN char * TclpGetCwd(Tcl_Interp *interp,
+				Tcl_DString *cwdPtr);
+/* 142 */
+EXTERN int		TclSetByteCodeFromAny(Tcl_Interp *interp,
+				Tcl_Obj *objPtr, CompileHookProc *hookProc,
+				ClientData clientData);
+/* 143 */
+EXTERN int		TclAddLiteralObj(struct CompileEnv *envPtr,
+				Tcl_Obj *objPtr, LiteralEntry **litPtrPtr);
+/* 144 */
+EXTERN void		TclHideLiteral(Tcl_Interp *interp,
+				struct CompileEnv *envPtr, int index);
+/* 145 */
+EXTERN const struct AuxDataType * TclGetAuxDataType(const char *typeName);
+/* 146 */
+EXTERN TclHandle	TclHandleCreate(void *ptr);
+/* 147 */
+EXTERN void		TclHandleFree(TclHandle handle);
+/* 148 */
+EXTERN TclHandle	TclHandlePreserve(TclHandle handle);
+/* 149 */
+EXTERN void		TclHandleRelease(TclHandle handle);
+/* 150 */
+EXTERN int		TclRegAbout(Tcl_Interp *interp, Tcl_RegExp re);
+/* 151 */
+EXTERN void		TclRegExpRangeUniChar(Tcl_RegExp re, int index,
+				int *startPtr, int *endPtr);
+/* 152 */
+EXTERN void		TclSetLibraryPath(Tcl_Obj *pathPtr);
+/* 153 */
+EXTERN Tcl_Obj *	TclGetLibraryPath(void);
+/* Slot 154 is reserved */
+/* Slot 155 is reserved */
+/* 156 */
+EXTERN void		TclRegError(Tcl_Interp *interp, const char *msg,
+				int status);
+/* 157 */
+EXTERN Var *		TclVarTraceExists(Tcl_Interp *interp,
+				const char *varName);
+/* 158 */
+EXTERN void		TclSetStartupScriptFileName(const char *filename);
+/* 159 */
+EXTERN const char *	TclGetStartupScriptFileName(void);
+/* Slot 160 is reserved */
+/* 161 */
+EXTERN int		TclChannelTransform(Tcl_Interp *interp,
+				Tcl_Channel chan, Tcl_Obj *cmdObjPtr);
+/* 162 */
+EXTERN void		TclChannelEventScriptInvoker(ClientData clientData,
+				int flags);
+/* 163 */
+EXTERN const void *	TclGetInstructionTable(void);
+/* 164 */
+EXTERN void		TclExpandCodeArray(void *envPtr);
+/* 165 */
+EXTERN void		TclpSetInitialEncodings(void);
+/* 166 */
+EXTERN int		TclListObjSetElement(Tcl_Interp *interp,
+				Tcl_Obj *listPtr, int index,
+				Tcl_Obj *valuePtr);
+/* 167 */
+EXTERN void		TclSetStartupScriptPath(Tcl_Obj *pathPtr);
+/* 168 */
+EXTERN Tcl_Obj *	TclGetStartupScriptPath(void);
+/* 169 */
+EXTERN int		TclpUtfNcmp2(const char *s1, const char *s2,
+				unsigned long n);
+/* 170 */
+EXTERN int		TclCheckInterpTraces(Tcl_Interp *interp,
+				const char *command, int numChars,
+				Command *cmdPtr, int result, int traceFlags,
+				int objc, Tcl_Obj *const objv[]);
+/* 171 */
+EXTERN int		TclCheckExecutionTraces(Tcl_Interp *interp,
+				const char *command, int numChars,
+				Command *cmdPtr, int result, int traceFlags,
+				int objc, Tcl_Obj *const objv[]);
+/* 172 */
+EXTERN int		TclInThreadExit(void);
+/* 173 */
+EXTERN int		TclUniCharMatch(const Tcl_UniChar *string,
+				int strLen, const Tcl_UniChar *pattern,
+				int ptnLen, int flags);
+/* Slot 174 is reserved */
+/* 175 */
+EXTERN int		TclCallVarTraces(Interp *iPtr, Var *arrayPtr,
+				Var *varPtr, const char *part1,
+				const char *part2, int flags,
+				int leaveErrMsg);
+/* 176 */
+EXTERN void		TclCleanupVar(Var *varPtr, Var *arrayPtr);
+/* 177 */
+EXTERN void		TclVarErrMsg(Tcl_Interp *interp, const char *part1,
+				const char *part2, const char *operation,
+				const char *reason);
+/* 178 */
+EXTERN void		Tcl_SetStartupScript(Tcl_Obj *pathPtr,
+				const char *encodingName);
+/* 179 */
+EXTERN Tcl_Obj *	Tcl_GetStartupScript(const char **encodingNamePtr);
+/* Slot 180 is reserved */
+/* Slot 181 is reserved */
+/* 182 */
+EXTERN struct tm *	TclpLocaltime(const time_t *clock);
+/* 183 */
+EXTERN struct tm *	TclpGmtime(const time_t *clock);
+/* Slot 184 is reserved */
+/* Slot 185 is reserved */
+/* Slot 186 is reserved */
+/* Slot 187 is reserved */
+/* Slot 188 is reserved */
+/* Slot 189 is reserved */
+/* Slot 190 is reserved */
+/* Slot 191 is reserved */
+/* Slot 192 is reserved */
+/* Slot 193 is reserved */
+/* Slot 194 is reserved */
+/* Slot 195 is reserved */
+/* Slot 196 is reserved */
+/* Slot 197 is reserved */
+/* 198 */
+EXTERN int		TclObjGetFrame(Tcl_Interp *interp, Tcl_Obj *objPtr,
+				CallFrame **framePtrPtr);
+/* Slot 199 is reserved */
+/* 200 */
+EXTERN int		TclpObjRemoveDirectory(Tcl_Obj *pathPtr,
+				int recursive, Tcl_Obj **errorPtr);
+/* 201 */
+EXTERN int		TclpObjCopyDirectory(Tcl_Obj *srcPathPtr,
+				Tcl_Obj *destPathPtr, Tcl_Obj **errorPtr);
+/* 202 */
+EXTERN int		TclpObjCreateDirectory(Tcl_Obj *pathPtr);
+/* 203 */
+EXTERN int		TclpObjDeleteFile(Tcl_Obj *pathPtr);
+/* 204 */
+EXTERN int		TclpObjCopyFile(Tcl_Obj *srcPathPtr,
+				Tcl_Obj *destPathPtr);
+/* 205 */
+EXTERN int		TclpObjRenameFile(Tcl_Obj *srcPathPtr,
+				Tcl_Obj *destPathPtr);
+/* 206 */
+EXTERN int		TclpObjStat(Tcl_Obj *pathPtr, Tcl_StatBuf *buf);
+/* 207 */
+EXTERN int		TclpObjAccess(Tcl_Obj *pathPtr, int mode);
+/* 208 */
+EXTERN Tcl_Channel	TclpOpenFileChannel(Tcl_Interp *interp,
+				Tcl_Obj *pathPtr, int mode, int permissions);
+/* Slot 209 is reserved */
+/* Slot 210 is reserved */
+/* Slot 211 is reserved */
+/* 212 */
+EXTERN void		TclpFindExecutable(const char *argv0);
+/* 213 */
+EXTERN Tcl_Obj *	TclGetObjNameOfExecutable(void);
+/* 214 */
+EXTERN void		TclSetObjNameOfExecutable(Tcl_Obj *name,
+				Tcl_Encoding encoding);
+/* 215 */
+EXTERN void *		TclStackAlloc(Tcl_Interp *interp, int numBytes);
+/* 216 */
+EXTERN void		TclStackFree(Tcl_Interp *interp, void *freePtr);
+/* 217 */
+EXTERN int		TclPushStackFrame(Tcl_Interp *interp,
+				Tcl_CallFrame **framePtrPtr,
+				Tcl_Namespace *namespacePtr,
+				int isProcCallFrame);
+/* 218 */
+EXTERN void		TclPopStackFrame(Tcl_Interp *interp);
+/* Slot 219 is reserved */
+/* Slot 220 is reserved */
+/* Slot 221 is reserved */
+/* Slot 222 is reserved */
+/* 223 */
+EXTERN void *		TclGetCStackPtr(void);
+/* 224 */
+EXTERN TclPlatformType * TclGetPlatform(void);
+/* 225 */
+EXTERN Tcl_Obj *	TclTraceDictPath(Tcl_Interp *interp,
+				Tcl_Obj *rootPtr, int keyc,
+				Tcl_Obj *const keyv[], int flags);
+/* 226 */
+EXTERN int		TclObjBeingDeleted(Tcl_Obj *objPtr);
+/* 227 */
+EXTERN void		TclSetNsPath(Namespace *nsPtr, int pathLength,
+				Tcl_Namespace *pathAry[]);
+/* Slot 228 is reserved */
+/* 229 */
+EXTERN int		TclPtrMakeUpvar(Tcl_Interp *interp, Var *otherP1Ptr,
+				const char *myName, int myFlags, int index);
+/* 230 */
+EXTERN Var *		TclObjLookupVar(Tcl_Interp *interp,
+				Tcl_Obj *part1Ptr, const char *part2,
+				int flags, const char *msg, int createPart1,
+				int createPart2, Var **arrayPtrPtr);
+/* 231 */
+EXTERN int		TclGetNamespaceFromObj(Tcl_Interp *interp,
+				Tcl_Obj *objPtr, Tcl_Namespace **nsPtrPtr);
+/* 232 */
+EXTERN int		TclEvalObjEx(Tcl_Interp *interp, Tcl_Obj *objPtr,
+				int flags, const CmdFrame *invoker, int word);
+/* 233 */
+EXTERN void		TclGetSrcInfoForPc(CmdFrame *contextPtr);
+/* 234 */
+EXTERN Var *		TclVarHashCreateVar(TclVarHashTable *tablePtr,
+				const char *key, int *newPtr);
+/* 235 */
+EXTERN void		TclInitVarHashTable(TclVarHashTable *tablePtr,
+				Namespace *nsPtr);
+/* 236 */
+EXTERN void		TclBackgroundException(Tcl_Interp *interp, int code);
+/* 237 */
+EXTERN int		TclResetCancellation(Tcl_Interp *interp, int force);
+/* 238 */
+EXTERN int		TclNRInterpProc(ClientData clientData,
+				Tcl_Interp *interp, int objc,
+				Tcl_Obj *const objv[]);
+/* 239 */
+EXTERN int		TclNRInterpProcCore(Tcl_Interp *interp,
+				Tcl_Obj *procNameObj, int skip,
+				ProcErrorProc *errorProc);
+/* 240 */
+EXTERN int		TclNRRunCallbacks(Tcl_Interp *interp, int result,
+				struct NRE_callback *rootPtr);
+/* 241 */
+EXTERN int		TclNREvalObjEx(Tcl_Interp *interp, Tcl_Obj *objPtr,
+				int flags, const CmdFrame *invoker, int word);
+/* 242 */
+EXTERN int		TclNREvalObjv(Tcl_Interp *interp, int objc,
+				Tcl_Obj *const objv[], int flags,
+				Command *cmdPtr);
+/* 243 */
+EXTERN void		TclDbDumpActiveObjects(FILE *outFile);
+/* 244 */
+EXTERN Tcl_HashTable *	TclGetNamespaceChildTable(Tcl_Namespace *nsPtr);
+/* 245 */
+EXTERN Tcl_HashTable *	TclGetNamespaceCommandTable(Tcl_Namespace *nsPtr);
+/* 246 */
+EXTERN int		TclInitRewriteEnsemble(Tcl_Interp *interp,
+				int numRemoved, int numInserted,
+				Tcl_Obj *const *objv);
+/* 247 */
+EXTERN void		TclResetRewriteEnsemble(Tcl_Interp *interp,
+				int isRootEnsemble);
+/* 248 */
+EXTERN int		TclCopyChannel(Tcl_Interp *interp,
+				Tcl_Channel inChan, Tcl_Channel outChan,
+				Tcl_WideInt toRead, Tcl_Obj *cmdPtr);
+/* 249 */
+EXTERN char *		TclDoubleDigits(double dv, int ndigits, int flags,
+				int *decpt, int *signum, char **endPtr);
+/* 250 */
+EXTERN void		TclSetSlaveCancelFlags(Tcl_Interp *interp, int flags,
+				int force);
+/* 251 */
+EXTERN int		TclRegisterLiteral(void *envPtr, char *bytes,
+				int length, int flags);
+/* 252 */
+EXTERN Tcl_Obj *	TclPtrGetVar(Tcl_Interp *interp, Tcl_Var varPtr,
+				Tcl_Var arrayPtr, Tcl_Obj *part1Ptr,
+				Tcl_Obj *part2Ptr, int flags);
+/* 253 */
+EXTERN Tcl_Obj *	TclPtrSetVar(Tcl_Interp *interp, Tcl_Var varPtr,
+				Tcl_Var arrayPtr, Tcl_Obj *part1Ptr,
+				Tcl_Obj *part2Ptr, Tcl_Obj *newValuePtr,
+				int flags);
+/* 254 */
+EXTERN Tcl_Obj *	TclPtrIncrObjVar(Tcl_Interp *interp, Tcl_Var varPtr,
+				Tcl_Var arrayPtr, Tcl_Obj *part1Ptr,
+				Tcl_Obj *part2Ptr, Tcl_Obj *incrPtr,
+				int flags);
+/* 255 */
+EXTERN int		TclPtrObjMakeUpvar(Tcl_Interp *interp,
+				Tcl_Var otherPtr, Tcl_Obj *myNamePtr,
+				int myFlags);
+/* 256 */
+EXTERN int		TclPtrUnsetVar(Tcl_Interp *interp, Tcl_Var varPtr,
+				Tcl_Var arrayPtr, Tcl_Obj *part1Ptr,
+				Tcl_Obj *part2Ptr, int flags);
+/* 257 */
+EXTERN void		TclStaticPackage(Tcl_Interp *interp,
+				const char *prefix,
+				Tcl_PackageInitProc *initProc,
+				Tcl_PackageInitProc *safeInitProc);
+/* Slot 258 is reserved */
+/* Slot 259 is reserved */
+/* Slot 260 is reserved */
+/* 261 */
+EXTERN void		TclUnusedStubEntry(void);
+
+typedef struct TclIntStubs {
+    int magic;
+    void *hooks;
+
+    void (*reserved0)(void);
+    void (*reserved1)(void);
+    void (*reserved2)(void);
+    void (*tclAllocateFreeObjects) (void); /* 3 */
+    void (*reserved4)(void);
+    int (*tclCleanupChildren) (Tcl_Interp *interp, int numPids, Tcl_Pid *pidPtr, Tcl_Channel errorChan); /* 5 */
+    void (*tclCleanupCommand) (Command *cmdPtr); /* 6 */
+    int (*tclCopyAndCollapse) (int count, const char *src, char *dst); /* 7 */
+    int (*tclCopyChannelOld) (Tcl_Interp *interp, Tcl_Channel inChan, Tcl_Channel outChan, int toRead, Tcl_Obj *cmdPtr); /* 8 */
+    int (*tclCreatePipeline) (Tcl_Interp *interp, int argc, const char **argv, Tcl_Pid **pidArrayPtr, TclFile *inPipePtr, TclFile *outPipePtr, TclFile *errFilePtr); /* 9 */
+    int (*tclCreateProc) (Tcl_Interp *interp, Namespace *nsPtr, const char *procName, Tcl_Obj *argsPtr, Tcl_Obj *bodyPtr, Proc **procPtrPtr); /* 10 */
+    void (*tclDeleteCompiledLocalVars) (Interp *iPtr, CallFrame *framePtr); /* 11 */
+    void (*tclDeleteVars) (Interp *iPtr, TclVarHashTable *tablePtr); /* 12 */
+    void (*reserved13)(void);
+    int (*tclDumpMemoryInfo) (ClientData clientData, int flags); /* 14 */
+    void (*reserved15)(void);
+    void (*tclExprFloatError) (Tcl_Interp *interp, double value); /* 16 */
+    void (*reserved17)(void);
+    void (*reserved18)(void);
+    void (*reserved19)(void);
+    void (*reserved20)(void);
+    void (*reserved21)(void);
+    int (*tclFindElement) (Tcl_Interp *interp, const char *listStr, int listLength, const char **elementPtr, const char **nextPtr, int *sizePtr, int *bracePtr); /* 22 */
+    Proc * (*tclFindProc) (Interp *iPtr, const char *procName); /* 23 */
+    int (*tclFormatInt) (char *buffer, long n); /* 24 */
+    void (*tclFreePackageInfo) (Interp *iPtr); /* 25 */
+    void (*reserved26)(void);
+    void (*reserved27)(void);
+    Tcl_Channel (*tclpGetDefaultStdChannel) (int type); /* 28 */
+    void (*reserved29)(void);
+    void (*reserved30)(void);
+    const char * (*tclGetExtension) (const char *name); /* 31 */
+    int (*tclGetFrame) (Tcl_Interp *interp, const char *str, CallFrame **framePtrPtr); /* 32 */
+    void (*reserved33)(void);
+    int (*tclGetIntForIndex) (Tcl_Interp *interp, Tcl_Obj *objPtr, int endValue, int *indexPtr); /* 34 */
+    void (*reserved35)(void);
+    void (*reserved36)(void);
+    int (*tclGetLoadedPackages) (Tcl_Interp *interp, const char *targetName); /* 37 */
+    int (*tclGetNamespaceForQualName) (Tcl_Interp *interp, const char *qualName, Namespace *cxtNsPtr, int flags, Namespace **nsPtrPtr, Namespace **altNsPtrPtr, Namespace **actualCxtPtrPtr, const char **simpleNamePtr); /* 38 */
+    Tcl_ObjCmdProc * (*tclGetObjInterpProc) (void); /* 39 */
+    int (*tclGetOpenMode) (Tcl_Interp *interp, const char *str, int *seekFlagPtr); /* 40 */
+    Tcl_Command (*tclGetOriginalCommand) (Tcl_Command command); /* 41 */
+    CONST86 char * (*tclpGetUserHome) (const char *name, Tcl_DString *bufferPtr); /* 42 */
+    void (*reserved43)(void);
+    int (*tclGuessPackageName) (const char *fileName, Tcl_DString *bufPtr); /* 44 */
+    int (*tclHideUnsafeCommands) (Tcl_Interp *interp); /* 45 */
+    int (*tclInExit) (void); /* 46 */
+    void (*reserved47)(void);
+    void (*reserved48)(void);
+    void (*reserved49)(void);
+    void (*tclInitCompiledLocals) (Tcl_Interp *interp, CallFrame *framePtr, Namespace *nsPtr); /* 50 */
+    int (*tclInterpInit) (Tcl_Interp *interp); /* 51 */
+    void (*reserved52)(void);
+    int (*tclInvokeObjectCommand) (ClientData clientData, Tcl_Interp *interp, int argc, CONST84 char **argv); /* 53 */
+    int (*tclInvokeStringCommand) (ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]); /* 54 */
+    Proc * (*tclIsProc) (Command *cmdPtr); /* 55 */
+    void (*reserved56)(void);
+    void (*reserved57)(void);
+    Var * (*tclLookupVar) (Tcl_Interp *interp, const char *part1, const char *part2, int flags, const char *msg, int createPart1, int createPart2, Var **arrayPtrPtr); /* 58 */
+    void (*reserved59)(void);
+    int (*tclNeedSpace) (const char *start, const char *end); /* 60 */
+    Tcl_Obj * (*tclNewProcBodyObj) (Proc *procPtr); /* 61 */
+    int (*tclObjCommandComplete) (Tcl_Obj *cmdPtr); /* 62 */
+    int (*tclObjInterpProc) (ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]); /* 63 */
+    int (*tclObjInvoke) (Tcl_Interp *interp, int objc, Tcl_Obj *const objv[], int flags); /* 64 */
+    void (*reserved65)(void);
+    void (*reserved66)(void);
+    void (*reserved67)(void);
+    void (*reserved68)(void);
+    char * (*tclpAlloc) (unsigned int size); /* 69 */
+    void (*reserved70)(void);
+    void (*reserved71)(void);
+    void (*reserved72)(void);
+    void (*reserved73)(void);
+    void (*tclpFree) (char *ptr); /* 74 */
+    unsigned long (*tclpGetClicks) (void); /* 75 */
+    unsigned long (*tclpGetSeconds) (void); /* 76 */
+    void (*tclpGetTime) (Tcl_Time *time); /* 77 */
+    void (*reserved78)(void);
+    void (*reserved79)(void);
+    void (*reserved80)(void);
+    char * (*tclpRealloc) (char *ptr, unsigned int size); /* 81 */
+    void (*reserved82)(void);
+    void (*reserved83)(void);
+    void (*reserved84)(void);
+    void (*reserved85)(void);
+    void (*reserved86)(void);
+    void (*reserved87)(void);
+    char * (*tclPrecTraceProc) (ClientData clientData, Tcl_Interp *interp, const char *name1, const char *name2, int flags); /* 88 */
+    int (*tclPreventAliasLoop) (Tcl_Interp *interp, Tcl_Interp *cmdInterp, Tcl_Command cmd); /* 89 */
+    void (*reserved90)(void);
+    void (*tclProcCleanupProc) (Proc *procPtr); /* 91 */
+    int (*tclProcCompileProc) (Tcl_Interp *interp, Proc *procPtr, Tcl_Obj *bodyPtr, Namespace *nsPtr, const char *description, const char *procName); /* 92 */
+    void (*tclProcDeleteProc) (ClientData clientData); /* 93 */
+    void (*reserved94)(void);
+    void (*reserved95)(void);
+    int (*tclRenameCommand) (Tcl_Interp *interp, const char *oldName, const char *newName); /* 96 */
+    void (*tclResetShadowedCmdRefs) (Tcl_Interp *interp, Command *newCmdPtr); /* 97 */
+    int (*tclServiceIdle) (void); /* 98 */
+    void (*reserved99)(void);
+    void (*reserved100)(void);
+    CONST86 char * (*tclSetPreInitScript) (const char *string); /* 101 */
+    void (*tclSetupEnv) (Tcl_Interp *interp); /* 102 */
+    int (*tclSockGetPort) (Tcl_Interp *interp, const char *str, const char *proto, int *portPtr); /* 103 */
+    int (*tclSockMinimumBuffersOld) (int sock, int size); /* 104 */
+    void (*reserved105)(void);
+    void (*reserved106)(void);
+    void (*reserved107)(void);
+    void (*tclTeardownNamespace) (Namespace *nsPtr); /* 108 */
+    int (*tclUpdateReturnInfo) (Interp *iPtr); /* 109 */
+    int (*tclSockMinimumBuffers) (void *sock, int size); /* 110 */
+    void (*tcl_AddInterpResolvers) (Tcl_Interp *interp, const char *name, Tcl_ResolveCmdProc *cmdProc, Tcl_ResolveVarProc *varProc, Tcl_ResolveCompiledVarProc *compiledVarProc); /* 111 */
+    int (*tcl_AppendExportList) (Tcl_Interp *interp, Tcl_Namespace *nsPtr, Tcl_Obj *objPtr); /* 112 */
+    Tcl_Namespace * (*tcl_CreateNamespace) (Tcl_Interp *interp, const char *name, ClientData clientData, Tcl_NamespaceDeleteProc *deleteProc); /* 113 */
+    void (*tcl_DeleteNamespace) (Tcl_Namespace *nsPtr); /* 114 */
+    int (*tcl_Export) (Tcl_Interp *interp, Tcl_Namespace *nsPtr, const char *pattern, int resetListFirst); /* 115 */
+    Tcl_Command (*tcl_FindCommand) (Tcl_Interp *interp, const char *name, Tcl_Namespace *contextNsPtr, int flags); /* 116 */
+    Tcl_Namespace * (*tcl_FindNamespace) (Tcl_Interp *interp, const char *name, Tcl_Namespace *contextNsPtr, int flags); /* 117 */
+    int (*tcl_GetInterpResolvers) (Tcl_Interp *interp, const char *name, Tcl_ResolverInfo *resInfo); /* 118 */
+    int (*tcl_GetNamespaceResolvers) (Tcl_Namespace *namespacePtr, Tcl_ResolverInfo *resInfo); /* 119 */
+    Tcl_Var (*tcl_FindNamespaceVar) (Tcl_Interp *interp, const char *name, Tcl_Namespace *contextNsPtr, int flags); /* 120 */
+    int (*tcl_ForgetImport) (Tcl_Interp *interp, Tcl_Namespace *nsPtr, const char *pattern); /* 121 */
+    Tcl_Command (*tcl_GetCommandFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr); /* 122 */
+    void (*tcl_GetCommandFullName) (Tcl_Interp *interp, Tcl_Command command, Tcl_Obj *objPtr); /* 123 */
+    Tcl_Namespace * (*tcl_GetCurrentNamespace) (Tcl_Interp *interp); /* 124 */
+    Tcl_Namespace * (*tcl_GetGlobalNamespace) (Tcl_Interp *interp); /* 125 */
+    void (*tcl_GetVariableFullName) (Tcl_Interp *interp, Tcl_Var variable, Tcl_Obj *objPtr); /* 126 */
+    int (*tcl_Import) (Tcl_Interp *interp, Tcl_Namespace *nsPtr, const char *pattern, int allowOverwrite); /* 127 */
+    void (*tcl_PopCallFrame) (Tcl_Interp *interp); /* 128 */
+    int (*tcl_PushCallFrame) (Tcl_Interp *interp, Tcl_CallFrame *framePtr, Tcl_Namespace *nsPtr, int isProcCallFrame); /* 129 */
+    int (*tcl_RemoveInterpResolvers) (Tcl_Interp *interp, const char *name); /* 130 */
+    void (*tcl_SetNamespaceResolvers) (Tcl_Namespace *namespacePtr, Tcl_ResolveCmdProc *cmdProc, Tcl_ResolveVarProc *varProc, Tcl_ResolveCompiledVarProc *compiledVarProc); /* 131 */
+    int (*tclpHasSockets) (Tcl_Interp *interp); /* 132 */
+    struct tm * (*tclpGetDate) (const time_t *time, int useGMT); /* 133 */
+    void (*reserved134)(void);
+    void (*reserved135)(void);
+    void (*reserved136)(void);
+    void (*reserved137)(void);
+    CONST84_RETURN char * (*tclGetEnv) (const char *name, Tcl_DString *valuePtr); /* 138 */
+    void (*reserved139)(void);
+    void (*reserved140)(void);
+    CONST84_RETURN char * (*tclpGetCwd) (Tcl_Interp *interp, Tcl_DString *cwdPtr); /* 141 */
+    int (*tclSetByteCodeFromAny) (Tcl_Interp *interp, Tcl_Obj *objPtr, CompileHookProc *hookProc, ClientData clientData); /* 142 */
+    int (*tclAddLiteralObj) (struct CompileEnv *envPtr, Tcl_Obj *objPtr, LiteralEntry **litPtrPtr); /* 143 */
+    void (*tclHideLiteral) (Tcl_Interp *interp, struct CompileEnv *envPtr, int index); /* 144 */
+    const struct AuxDataType * (*tclGetAuxDataType) (const char *typeName); /* 145 */
+    TclHandle (*tclHandleCreate) (void *ptr); /* 146 */
+    void (*tclHandleFree) (TclHandle handle); /* 147 */
+    TclHandle (*tclHandlePreserve) (TclHandle handle); /* 148 */
+    void (*tclHandleRelease) (TclHandle handle); /* 149 */
+    int (*tclRegAbout) (Tcl_Interp *interp, Tcl_RegExp re); /* 150 */
+    void (*tclRegExpRangeUniChar) (Tcl_RegExp re, int index, int *startPtr, int *endPtr); /* 151 */
+    void (*tclSetLibraryPath) (Tcl_Obj *pathPtr); /* 152 */
+    Tcl_Obj * (*tclGetLibraryPath) (void); /* 153 */
+    void (*reserved154)(void);
+    void (*reserved155)(void);
+    void (*tclRegError) (Tcl_Interp *interp, const char *msg, int status); /* 156 */
+    Var * (*tclVarTraceExists) (Tcl_Interp *interp, const char *varName); /* 157 */
+    void (*tclSetStartupScriptFileName) (const char *filename); /* 158 */
+    const char * (*tclGetStartupScriptFileName) (void); /* 159 */
+    void (*reserved160)(void);
+    int (*tclChannelTransform) (Tcl_Interp *interp, Tcl_Channel chan, Tcl_Obj *cmdObjPtr); /* 161 */
+    void (*tclChannelEventScriptInvoker) (ClientData clientData, int flags); /* 162 */
+    const void * (*tclGetInstructionTable) (void); /* 163 */
+    void (*tclExpandCodeArray) (void *envPtr); /* 164 */
+    void (*tclpSetInitialEncodings) (void); /* 165 */
+    int (*tclListObjSetElement) (Tcl_Interp *interp, Tcl_Obj *listPtr, int index, Tcl_Obj *valuePtr); /* 166 */
+    void (*tclSetStartupScriptPath) (Tcl_Obj *pathPtr); /* 167 */
+    Tcl_Obj * (*tclGetStartupScriptPath) (void); /* 168 */
+    int (*tclpUtfNcmp2) (const char *s1, const char *s2, unsigned long n); /* 169 */
+    int (*tclCheckInterpTraces) (Tcl_Interp *interp, const char *command, int numChars, Command *cmdPtr, int result, int traceFlags, int objc, Tcl_Obj *const objv[]); /* 170 */
+    int (*tclCheckExecutionTraces) (Tcl_Interp *interp, const char *command, int numChars, Command *cmdPtr, int result, int traceFlags, int objc, Tcl_Obj *const objv[]); /* 171 */
+    int (*tclInThreadExit) (void); /* 172 */
+    int (*tclUniCharMatch) (const Tcl_UniChar *string, int strLen, const Tcl_UniChar *pattern, int ptnLen, int flags); /* 173 */
+    void (*reserved174)(void);
+    int (*tclCallVarTraces) (Interp *iPtr, Var *arrayPtr, Var *varPtr, const char *part1, const char *part2, int flags, int leaveErrMsg); /* 175 */
+    void (*tclCleanupVar) (Var *varPtr, Var *arrayPtr); /* 176 */
+    void (*tclVarErrMsg) (Tcl_Interp *interp, const char *part1, const char *part2, const char *operation, const char *reason); /* 177 */
+    void (*tcl_SetStartupScript) (Tcl_Obj *pathPtr, const char *encodingName); /* 178 */
+    Tcl_Obj * (*tcl_GetStartupScript) (const char **encodingNamePtr); /* 179 */
+    void (*reserved180)(void);
+    void (*reserved181)(void);
+    struct tm * (*tclpLocaltime) (const time_t *clock); /* 182 */
+    struct tm * (*tclpGmtime) (const time_t *clock); /* 183 */
+    void (*reserved184)(void);
+    void (*reserved185)(void);
+    void (*reserved186)(void);
+    void (*reserved187)(void);
+    void (*reserved188)(void);
+    void (*reserved189)(void);
+    void (*reserved190)(void);
+    void (*reserved191)(void);
+    void (*reserved192)(void);
+    void (*reserved193)(void);
+    void (*reserved194)(void);
+    void (*reserved195)(void);
+    void (*reserved196)(void);
+    void (*reserved197)(void);
+    int (*tclObjGetFrame) (Tcl_Interp *interp, Tcl_Obj *objPtr, CallFrame **framePtrPtr); /* 198 */
+    void (*reserved199)(void);
+    int (*tclpObjRemoveDirectory) (Tcl_Obj *pathPtr, int recursive, Tcl_Obj **errorPtr); /* 200 */
+    int (*tclpObjCopyDirectory) (Tcl_Obj *srcPathPtr, Tcl_Obj *destPathPtr, Tcl_Obj **errorPtr); /* 201 */
+    int (*tclpObjCreateDirectory) (Tcl_Obj *pathPtr); /* 202 */
+    int (*tclpObjDeleteFile) (Tcl_Obj *pathPtr); /* 203 */
+    int (*tclpObjCopyFile) (Tcl_Obj *srcPathPtr, Tcl_Obj *destPathPtr); /* 204 */
+    int (*tclpObjRenameFile) (Tcl_Obj *srcPathPtr, Tcl_Obj *destPathPtr); /* 205 */
+    int (*tclpObjStat) (Tcl_Obj *pathPtr, Tcl_StatBuf *buf); /* 206 */
+    int (*tclpObjAccess) (Tcl_Obj *pathPtr, int mode); /* 207 */
+    Tcl_Channel (*tclpOpenFileChannel) (Tcl_Interp *interp, Tcl_Obj *pathPtr, int mode, int permissions); /* 208 */
+    void (*reserved209)(void);
+    void (*reserved210)(void);
+    void (*reserved211)(void);
+    void (*tclpFindExecutable) (const char *argv0); /* 212 */
+    Tcl_Obj * (*tclGetObjNameOfExecutable) (void); /* 213 */
+    void (*tclSetObjNameOfExecutable) (Tcl_Obj *name, Tcl_Encoding encoding); /* 214 */
+    void * (*tclStackAlloc) (Tcl_Interp *interp, int numBytes); /* 215 */
+    void (*tclStackFree) (Tcl_Interp *interp, void *freePtr); /* 216 */
+    int (*tclPushStackFrame) (Tcl_Interp *interp, Tcl_CallFrame **framePtrPtr, Tcl_Namespace *namespacePtr, int isProcCallFrame); /* 217 */
+    void (*tclPopStackFrame) (Tcl_Interp *interp); /* 218 */
+    void (*reserved219)(void);
+    void (*reserved220)(void);
+    void (*reserved221)(void);
+    void (*reserved222)(void);
+    void * (*tclGetCStackPtr) (void); /* 223 */
+    TclPlatformType * (*tclGetPlatform) (void); /* 224 */
+    Tcl_Obj * (*tclTraceDictPath) (Tcl_Interp *interp, Tcl_Obj *rootPtr, int keyc, Tcl_Obj *const keyv[], int flags); /* 225 */
+    int (*tclObjBeingDeleted) (Tcl_Obj *objPtr); /* 226 */
+    void (*tclSetNsPath) (Namespace *nsPtr, int pathLength, Tcl_Namespace *pathAry[]); /* 227 */
+    void (*reserved228)(void);
+    int (*tclPtrMakeUpvar) (Tcl_Interp *interp, Var *otherP1Ptr, const char *myName, int myFlags, int index); /* 229 */
+    Var * (*tclObjLookupVar) (Tcl_Interp *interp, Tcl_Obj *part1Ptr, const char *part2, int flags, const char *msg, int createPart1, int createPart2, Var **arrayPtrPtr); /* 230 */
+    int (*tclGetNamespaceFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, Tcl_Namespace **nsPtrPtr); /* 231 */
+    int (*tclEvalObjEx) (Tcl_Interp *interp, Tcl_Obj *objPtr, int flags, const CmdFrame *invoker, int word); /* 232 */
+    void (*tclGetSrcInfoForPc) (CmdFrame *contextPtr); /* 233 */
+    Var * (*tclVarHashCreateVar) (TclVarHashTable *tablePtr, const char *key, int *newPtr); /* 234 */
+    void (*tclInitVarHashTable) (TclVarHashTable *tablePtr, Namespace *nsPtr); /* 235 */
+    void (*tclBackgroundException) (Tcl_Interp *interp, int code); /* 236 */
+    int (*tclResetCancellation) (Tcl_Interp *interp, int force); /* 237 */
+    int (*tclNRInterpProc) (ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]); /* 238 */
+    int (*tclNRInterpProcCore) (Tcl_Interp *interp, Tcl_Obj *procNameObj, int skip, ProcErrorProc *errorProc); /* 239 */
+    int (*tclNRRunCallbacks) (Tcl_Interp *interp, int result, struct NRE_callback *rootPtr); /* 240 */
+    int (*tclNREvalObjEx) (Tcl_Interp *interp, Tcl_Obj *objPtr, int flags, const CmdFrame *invoker, int word); /* 241 */
+    int (*tclNREvalObjv) (Tcl_Interp *interp, int objc, Tcl_Obj *const objv[], int flags, Command *cmdPtr); /* 242 */
+    void (*tclDbDumpActiveObjects) (FILE *outFile); /* 243 */
+    Tcl_HashTable * (*tclGetNamespaceChildTable) (Tcl_Namespace *nsPtr); /* 244 */
+    Tcl_HashTable * (*tclGetNamespaceCommandTable) (Tcl_Namespace *nsPtr); /* 245 */
+    int (*tclInitRewriteEnsemble) (Tcl_Interp *interp, int numRemoved, int numInserted, Tcl_Obj *const *objv); /* 246 */
+    void (*tclResetRewriteEnsemble) (Tcl_Interp *interp, int isRootEnsemble); /* 247 */
+    int (*tclCopyChannel) (Tcl_Interp *interp, Tcl_Channel inChan, Tcl_Channel outChan, Tcl_WideInt toRead, Tcl_Obj *cmdPtr); /* 248 */
+    char * (*tclDoubleDigits) (double dv, int ndigits, int flags, int *decpt, int *signum, char **endPtr); /* 249 */
+    void (*tclSetSlaveCancelFlags) (Tcl_Interp *interp, int flags, int force); /* 250 */
+    int (*tclRegisterLiteral) (void *envPtr, char *bytes, int length, int flags); /* 251 */
+    Tcl_Obj * (*tclPtrGetVar) (Tcl_Interp *interp, Tcl_Var varPtr, Tcl_Var arrayPtr, Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr, int flags); /* 252 */
+    Tcl_Obj * (*tclPtrSetVar) (Tcl_Interp *interp, Tcl_Var varPtr, Tcl_Var arrayPtr, Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr, Tcl_Obj *newValuePtr, int flags); /* 253 */
+    Tcl_Obj * (*tclPtrIncrObjVar) (Tcl_Interp *interp, Tcl_Var varPtr, Tcl_Var arrayPtr, Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr, Tcl_Obj *incrPtr, int flags); /* 254 */
+    int (*tclPtrObjMakeUpvar) (Tcl_Interp *interp, Tcl_Var otherPtr, Tcl_Obj *myNamePtr, int myFlags); /* 255 */
+    int (*tclPtrUnsetVar) (Tcl_Interp *interp, Tcl_Var varPtr, Tcl_Var arrayPtr, Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr, int flags); /* 256 */
+    void (*tclStaticPackage) (Tcl_Interp *interp, const char *prefix, Tcl_PackageInitProc *initProc, Tcl_PackageInitProc *safeInitProc); /* 257 */
+    void (*reserved258)(void);
+    void (*reserved259)(void);
+    void (*reserved260)(void);
+    void (*tclUnusedStubEntry) (void); /* 261 */
+} TclIntStubs;
+
+extern const TclIntStubs *tclIntStubsPtr;
+
+#ifdef __cplusplus
+}
+#endif
+
+#if defined(USE_TCL_STUBS)
+
+/*
+ * Inline function declarations:
+ */
+
+/* Slot 0 is reserved */
+/* Slot 1 is reserved */
+/* Slot 2 is reserved */
+#define TclAllocateFreeObjects \
+	(tclIntStubsPtr->tclAllocateFreeObjects) /* 3 */
+/* Slot 4 is reserved */
+#define TclCleanupChildren \
+	(tclIntStubsPtr->tclCleanupChildren) /* 5 */
+#define TclCleanupCommand \
+	(tclIntStubsPtr->tclCleanupCommand) /* 6 */
+#define TclCopyAndCollapse \
+	(tclIntStubsPtr->tclCopyAndCollapse) /* 7 */
+#define TclCopyChannelOld \
+	(tclIntStubsPtr->tclCopyChannelOld) /* 8 */
+#define TclCreatePipeline \
+	(tclIntStubsPtr->tclCreatePipeline) /* 9 */
+#define TclCreateProc \
+	(tclIntStubsPtr->tclCreateProc) /* 10 */
+#define TclDeleteCompiledLocalVars \
+	(tclIntStubsPtr->tclDeleteCompiledLocalVars) /* 11 */
+#define TclDeleteVars \
+	(tclIntStubsPtr->tclDeleteVars) /* 12 */
+/* Slot 13 is reserved */
+#define TclDumpMemoryInfo \
+	(tclIntStubsPtr->tclDumpMemoryInfo) /* 14 */
+/* Slot 15 is reserved */
+#define TclExprFloatError \
+	(tclIntStubsPtr->tclExprFloatError) /* 16 */
+/* Slot 17 is reserved */
+/* Slot 18 is reserved */
+/* Slot 19 is reserved */
+/* Slot 20 is reserved */
+/* Slot 21 is reserved */
+#define TclFindElement \
+	(tclIntStubsPtr->tclFindElement) /* 22 */
+#define TclFindProc \
+	(tclIntStubsPtr->tclFindProc) /* 23 */
+#define TclFormatInt \
+	(tclIntStubsPtr->tclFormatInt) /* 24 */
+#define TclFreePackageInfo \
+	(tclIntStubsPtr->tclFreePackageInfo) /* 25 */
+/* Slot 26 is reserved */
+/* Slot 27 is reserved */
+#define TclpGetDefaultStdChannel \
+	(tclIntStubsPtr->tclpGetDefaultStdChannel) /* 28 */
+/* Slot 29 is reserved */
+/* Slot 30 is reserved */
+#define TclGetExtension \
+	(tclIntStubsPtr->tclGetExtension) /* 31 */
+#define TclGetFrame \
+	(tclIntStubsPtr->tclGetFrame) /* 32 */
+/* Slot 33 is reserved */
+#define TclGetIntForIndex \
+	(tclIntStubsPtr->tclGetIntForIndex) /* 34 */
+/* Slot 35 is reserved */
+/* Slot 36 is reserved */
+#define TclGetLoadedPackages \
+	(tclIntStubsPtr->tclGetLoadedPackages) /* 37 */
+#define TclGetNamespaceForQualName \
+	(tclIntStubsPtr->tclGetNamespaceForQualName) /* 38 */
+#define TclGetObjInterpProc \
+	(tclIntStubsPtr->tclGetObjInterpProc) /* 39 */
+#define TclGetOpenMode \
+	(tclIntStubsPtr->tclGetOpenMode) /* 40 */
+#define TclGetOriginalCommand \
+	(tclIntStubsPtr->tclGetOriginalCommand) /* 41 */
+#define TclpGetUserHome \
+	(tclIntStubsPtr->tclpGetUserHome) /* 42 */
+/* Slot 43 is reserved */
+#define TclGuessPackageName \
+	(tclIntStubsPtr->tclGuessPackageName) /* 44 */
+#define TclHideUnsafeCommands \
+	(tclIntStubsPtr->tclHideUnsafeCommands) /* 45 */
+#define TclInExit \
+	(tclIntStubsPtr->tclInExit) /* 46 */
+/* Slot 47 is reserved */
+/* Slot 48 is reserved */
+/* Slot 49 is reserved */
+#define TclInitCompiledLocals \
+	(tclIntStubsPtr->tclInitCompiledLocals) /* 50 */
+#define TclInterpInit \
+	(tclIntStubsPtr->tclInterpInit) /* 51 */
+/* Slot 52 is reserved */
+#define TclInvokeObjectCommand \
+	(tclIntStubsPtr->tclInvokeObjectCommand) /* 53 */
+#define TclInvokeStringCommand \
+	(tclIntStubsPtr->tclInvokeStringCommand) /* 54 */
+#define TclIsProc \
+	(tclIntStubsPtr->tclIsProc) /* 55 */
+/* Slot 56 is reserved */
+/* Slot 57 is reserved */
+#define TclLookupVar \
+	(tclIntStubsPtr->tclLookupVar) /* 58 */
+/* Slot 59 is reserved */
+#define TclNeedSpace \
+	(tclIntStubsPtr->tclNeedSpace) /* 60 */
+#define TclNewProcBodyObj \
+	(tclIntStubsPtr->tclNewProcBodyObj) /* 61 */
+#define TclObjCommandComplete \
+	(tclIntStubsPtr->tclObjCommandComplete) /* 62 */
+#define TclObjInterpProc \
+	(tclIntStubsPtr->tclObjInterpProc) /* 63 */
+#define TclObjInvoke \
+	(tclIntStubsPtr->tclObjInvoke) /* 64 */
+/* Slot 65 is reserved */
+/* Slot 66 is reserved */
+/* Slot 67 is reserved */
+/* Slot 68 is reserved */
+#define TclpAlloc \
+	(tclIntStubsPtr->tclpAlloc) /* 69 */
+/* Slot 70 is reserved */
+/* Slot 71 is reserved */
+/* Slot 72 is reserved */
+/* Slot 73 is reserved */
+#define TclpFree \
+	(tclIntStubsPtr->tclpFree) /* 74 */
+#define TclpGetClicks \
+	(tclIntStubsPtr->tclpGetClicks) /* 75 */
+#define TclpGetSeconds \
+	(tclIntStubsPtr->tclpGetSeconds) /* 76 */
+#define TclpGetTime \
+	(tclIntStubsPtr->tclpGetTime) /* 77 */
+/* Slot 78 is reserved */
+/* Slot 79 is reserved */
+/* Slot 80 is reserved */
+#define TclpRealloc \
+	(tclIntStubsPtr->tclpRealloc) /* 81 */
+/* Slot 82 is reserved */
+/* Slot 83 is reserved */
+/* Slot 84 is reserved */
+/* Slot 85 is reserved */
+/* Slot 86 is reserved */
+/* Slot 87 is reserved */
+#define TclPrecTraceProc \
+	(tclIntStubsPtr->tclPrecTraceProc) /* 88 */
+#define TclPreventAliasLoop \
+	(tclIntStubsPtr->tclPreventAliasLoop) /* 89 */
+/* Slot 90 is reserved */
+#define TclProcCleanupProc \
+	(tclIntStubsPtr->tclProcCleanupProc) /* 91 */
+#define TclProcCompileProc \
+	(tclIntStubsPtr->tclProcCompileProc) /* 92 */
+#define TclProcDeleteProc \
+	(tclIntStubsPtr->tclProcDeleteProc) /* 93 */
+/* Slot 94 is reserved */
+/* Slot 95 is reserved */
+#define TclRenameCommand \
+	(tclIntStubsPtr->tclRenameCommand) /* 96 */
+#define TclResetShadowedCmdRefs \
+	(tclIntStubsPtr->tclResetShadowedCmdRefs) /* 97 */
+#define TclServiceIdle \
+	(tclIntStubsPtr->tclServiceIdle) /* 98 */
+/* Slot 99 is reserved */
+/* Slot 100 is reserved */
+#define TclSetPreInitScript \
+	(tclIntStubsPtr->tclSetPreInitScript) /* 101 */
+#define TclSetupEnv \
+	(tclIntStubsPtr->tclSetupEnv) /* 102 */
+#define TclSockGetPort \
+	(tclIntStubsPtr->tclSockGetPort) /* 103 */
+#define TclSockMinimumBuffersOld \
+	(tclIntStubsPtr->tclSockMinimumBuffersOld) /* 104 */
+/* Slot 105 is reserved */
+/* Slot 106 is reserved */
+/* Slot 107 is reserved */
+#define TclTeardownNamespace \
+	(tclIntStubsPtr->tclTeardownNamespace) /* 108 */
+#define TclUpdateReturnInfo \
+	(tclIntStubsPtr->tclUpdateReturnInfo) /* 109 */
+#define TclSockMinimumBuffers \
+	(tclIntStubsPtr->tclSockMinimumBuffers) /* 110 */
+#define Tcl_AddInterpResolvers \
+	(tclIntStubsPtr->tcl_AddInterpResolvers) /* 111 */
+#define Tcl_AppendExportList \
+	(tclIntStubsPtr->tcl_AppendExportList) /* 112 */
+#define Tcl_CreateNamespace \
+	(tclIntStubsPtr->tcl_CreateNamespace) /* 113 */
+#define Tcl_DeleteNamespace \
+	(tclIntStubsPtr->tcl_DeleteNamespace) /* 114 */
+#define Tcl_Export \
+	(tclIntStubsPtr->tcl_Export) /* 115 */
+#define Tcl_FindCommand \
+	(tclIntStubsPtr->tcl_FindCommand) /* 116 */
+#define Tcl_FindNamespace \
+	(tclIntStubsPtr->tcl_FindNamespace) /* 117 */
+#define Tcl_GetInterpResolvers \
+	(tclIntStubsPtr->tcl_GetInterpResolvers) /* 118 */
+#define Tcl_GetNamespaceResolvers \
+	(tclIntStubsPtr->tcl_GetNamespaceResolvers) /* 119 */
+#define Tcl_FindNamespaceVar \
+	(tclIntStubsPtr->tcl_FindNamespaceVar) /* 120 */
+#define Tcl_ForgetImport \
+	(tclIntStubsPtr->tcl_ForgetImport) /* 121 */
+#define Tcl_GetCommandFromObj \
+	(tclIntStubsPtr->tcl_GetCommandFromObj) /* 122 */
+#define Tcl_GetCommandFullName \
+	(tclIntStubsPtr->tcl_GetCommandFullName) /* 123 */
+#define Tcl_GetCurrentNamespace \
+	(tclIntStubsPtr->tcl_GetCurrentNamespace) /* 124 */
+#define Tcl_GetGlobalNamespace \
+	(tclIntStubsPtr->tcl_GetGlobalNamespace) /* 125 */
+#define Tcl_GetVariableFullName \
+	(tclIntStubsPtr->tcl_GetVariableFullName) /* 126 */
+#define Tcl_Import \
+	(tclIntStubsPtr->tcl_Import) /* 127 */
+#define Tcl_PopCallFrame \
+	(tclIntStubsPtr->tcl_PopCallFrame) /* 128 */
+#define Tcl_PushCallFrame \
+	(tclIntStubsPtr->tcl_PushCallFrame) /* 129 */
+#define Tcl_RemoveInterpResolvers \
+	(tclIntStubsPtr->tcl_RemoveInterpResolvers) /* 130 */
+#define Tcl_SetNamespaceResolvers \
+	(tclIntStubsPtr->tcl_SetNamespaceResolvers) /* 131 */
+#define TclpHasSockets \
+	(tclIntStubsPtr->tclpHasSockets) /* 132 */
+#define TclpGetDate \
+	(tclIntStubsPtr->tclpGetDate) /* 133 */
+/* Slot 134 is reserved */
+/* Slot 135 is reserved */
+/* Slot 136 is reserved */
+/* Slot 137 is reserved */
+#define TclGetEnv \
+	(tclIntStubsPtr->tclGetEnv) /* 138 */
+/* Slot 139 is reserved */
+/* Slot 140 is reserved */
+#define TclpGetCwd \
+	(tclIntStubsPtr->tclpGetCwd) /* 141 */
+#define TclSetByteCodeFromAny \
+	(tclIntStubsPtr->tclSetByteCodeFromAny) /* 142 */
+#define TclAddLiteralObj \
+	(tclIntStubsPtr->tclAddLiteralObj) /* 143 */
+#define TclHideLiteral \
+	(tclIntStubsPtr->tclHideLiteral) /* 144 */
+#define TclGetAuxDataType \
+	(tclIntStubsPtr->tclGetAuxDataType) /* 145 */
+#define TclHandleCreate \
+	(tclIntStubsPtr->tclHandleCreate) /* 146 */
+#define TclHandleFree \
+	(tclIntStubsPtr->tclHandleFree) /* 147 */
+#define TclHandlePreserve \
+	(tclIntStubsPtr->tclHandlePreserve) /* 148 */
+#define TclHandleRelease \
+	(tclIntStubsPtr->tclHandleRelease) /* 149 */
+#define TclRegAbout \
+	(tclIntStubsPtr->tclRegAbout) /* 150 */
+#define TclRegExpRangeUniChar \
+	(tclIntStubsPtr->tclRegExpRangeUniChar) /* 151 */
+#define TclSetLibraryPath \
+	(tclIntStubsPtr->tclSetLibraryPath) /* 152 */
+#define TclGetLibraryPath \
+	(tclIntStubsPtr->tclGetLibraryPath) /* 153 */
+/* Slot 154 is reserved */
+/* Slot 155 is reserved */
+#define TclRegError \
+	(tclIntStubsPtr->tclRegError) /* 156 */
+#define TclVarTraceExists \
+	(tclIntStubsPtr->tclVarTraceExists) /* 157 */
+#define TclSetStartupScriptFileName \
+	(tclIntStubsPtr->tclSetStartupScriptFileName) /* 158 */
+#define TclGetStartupScriptFileName \
+	(tclIntStubsPtr->tclGetStartupScriptFileName) /* 159 */
+/* Slot 160 is reserved */
+#define TclChannelTransform \
+	(tclIntStubsPtr->tclChannelTransform) /* 161 */
+#define TclChannelEventScriptInvoker \
+	(tclIntStubsPtr->tclChannelEventScriptInvoker) /* 162 */
+#define TclGetInstructionTable \
+	(tclIntStubsPtr->tclGetInstructionTable) /* 163 */
+#define TclExpandCodeArray \
+	(tclIntStubsPtr->tclExpandCodeArray) /* 164 */
+#define TclpSetInitialEncodings \
+	(tclIntStubsPtr->tclpSetInitialEncodings) /* 165 */
+#define TclListObjSetElement \
+	(tclIntStubsPtr->tclListObjSetElement) /* 166 */
+#define TclSetStartupScriptPath \
+	(tclIntStubsPtr->tclSetStartupScriptPath) /* 167 */
+#define TclGetStartupScriptPath \
+	(tclIntStubsPtr->tclGetStartupScriptPath) /* 168 */
+#define TclpUtfNcmp2 \
+	(tclIntStubsPtr->tclpUtfNcmp2) /* 169 */
+#define TclCheckInterpTraces \
+	(tclIntStubsPtr->tclCheckInterpTraces) /* 170 */
+#define TclCheckExecutionTraces \
+	(tclIntStubsPtr->tclCheckExecutionTraces) /* 171 */
+#define TclInThreadExit \
+	(tclIntStubsPtr->tclInThreadExit) /* 172 */
+#define TclUniCharMatch \
+	(tclIntStubsPtr->tclUniCharMatch) /* 173 */
+/* Slot 174 is reserved */
+#define TclCallVarTraces \
+	(tclIntStubsPtr->tclCallVarTraces) /* 175 */
+#define TclCleanupVar \
+	(tclIntStubsPtr->tclCleanupVar) /* 176 */
+#define TclVarErrMsg \
+	(tclIntStubsPtr->tclVarErrMsg) /* 177 */
+#define Tcl_SetStartupScript \
+	(tclIntStubsPtr->tcl_SetStartupScript) /* 178 */
+#define Tcl_GetStartupScript \
+	(tclIntStubsPtr->tcl_GetStartupScript) /* 179 */
+/* Slot 180 is reserved */
+/* Slot 181 is reserved */
+#define TclpLocaltime \
+	(tclIntStubsPtr->tclpLocaltime) /* 182 */
+#define TclpGmtime \
+	(tclIntStubsPtr->tclpGmtime) /* 183 */
+/* Slot 184 is reserved */
+/* Slot 185 is reserved */
+/* Slot 186 is reserved */
+/* Slot 187 is reserved */
+/* Slot 188 is reserved */
+/* Slot 189 is reserved */
+/* Slot 190 is reserved */
+/* Slot 191 is reserved */
+/* Slot 192 is reserved */
+/* Slot 193 is reserved */
+/* Slot 194 is reserved */
+/* Slot 195 is reserved */
+/* Slot 196 is reserved */
+/* Slot 197 is reserved */
+#define TclObjGetFrame \
+	(tclIntStubsPtr->tclObjGetFrame) /* 198 */
+/* Slot 199 is reserved */
+#define TclpObjRemoveDirectory \
+	(tclIntStubsPtr->tclpObjRemoveDirectory) /* 200 */
+#define TclpObjCopyDirectory \
+	(tclIntStubsPtr->tclpObjCopyDirectory) /* 201 */
+#define TclpObjCreateDirectory \
+	(tclIntStubsPtr->tclpObjCreateDirectory) /* 202 */
+#define TclpObjDeleteFile \
+	(tclIntStubsPtr->tclpObjDeleteFile) /* 203 */
+#define TclpObjCopyFile \
+	(tclIntStubsPtr->tclpObjCopyFile) /* 204 */
+#define TclpObjRenameFile \
+	(tclIntStubsPtr->tclpObjRenameFile) /* 205 */
+#define TclpObjStat \
+	(tclIntStubsPtr->tclpObjStat) /* 206 */
+#define TclpObjAccess \
+	(tclIntStubsPtr->tclpObjAccess) /* 207 */
+#define TclpOpenFileChannel \
+	(tclIntStubsPtr->tclpOpenFileChannel) /* 208 */
+/* Slot 209 is reserved */
+/* Slot 210 is reserved */
+/* Slot 211 is reserved */
+#define TclpFindExecutable \
+	(tclIntStubsPtr->tclpFindExecutable) /* 212 */
+#define TclGetObjNameOfExecutable \
+	(tclIntStubsPtr->tclGetObjNameOfExecutable) /* 213 */
+#define TclSetObjNameOfExecutable \
+	(tclIntStubsPtr->tclSetObjNameOfExecutable) /* 214 */
+#define TclStackAlloc \
+	(tclIntStubsPtr->tclStackAlloc) /* 215 */
+#define TclStackFree \
+	(tclIntStubsPtr->tclStackFree) /* 216 */
+#define TclPushStackFrame \
+	(tclIntStubsPtr->tclPushStackFrame) /* 217 */
+#define TclPopStackFrame \
+	(tclIntStubsPtr->tclPopStackFrame) /* 218 */
+/* Slot 219 is reserved */
+/* Slot 220 is reserved */
+/* Slot 221 is reserved */
+/* Slot 222 is reserved */
+#define TclGetCStackPtr \
+	(tclIntStubsPtr->tclGetCStackPtr) /* 223 */
+#define TclGetPlatform \
+	(tclIntStubsPtr->tclGetPlatform) /* 224 */
+#define TclTraceDictPath \
+	(tclIntStubsPtr->tclTraceDictPath) /* 225 */
+#define TclObjBeingDeleted \
+	(tclIntStubsPtr->tclObjBeingDeleted) /* 226 */
+#define TclSetNsPath \
+	(tclIntStubsPtr->tclSetNsPath) /* 227 */
+/* Slot 228 is reserved */
+#define TclPtrMakeUpvar \
+	(tclIntStubsPtr->tclPtrMakeUpvar) /* 229 */
+#define TclObjLookupVar \
+	(tclIntStubsPtr->tclObjLookupVar) /* 230 */
+#define TclGetNamespaceFromObj \
+	(tclIntStubsPtr->tclGetNamespaceFromObj) /* 231 */
+#define TclEvalObjEx \
+	(tclIntStubsPtr->tclEvalObjEx) /* 232 */
+#define TclGetSrcInfoForPc \
+	(tclIntStubsPtr->tclGetSrcInfoForPc) /* 233 */
+#define TclVarHashCreateVar \
+	(tclIntStubsPtr->tclVarHashCreateVar) /* 234 */
+#define TclInitVarHashTable \
+	(tclIntStubsPtr->tclInitVarHashTable) /* 235 */
+#define TclBackgroundException \
+	(tclIntStubsPtr->tclBackgroundException) /* 236 */
+#define TclResetCancellation \
+	(tclIntStubsPtr->tclResetCancellation) /* 237 */
+#define TclNRInterpProc \
+	(tclIntStubsPtr->tclNRInterpProc) /* 238 */
+#define TclNRInterpProcCore \
+	(tclIntStubsPtr->tclNRInterpProcCore) /* 239 */
+#define TclNRRunCallbacks \
+	(tclIntStubsPtr->tclNRRunCallbacks) /* 240 */
+#define TclNREvalObjEx \
+	(tclIntStubsPtr->tclNREvalObjEx) /* 241 */
+#define TclNREvalObjv \
+	(tclIntStubsPtr->tclNREvalObjv) /* 242 */
+#define TclDbDumpActiveObjects \
+	(tclIntStubsPtr->tclDbDumpActiveObjects) /* 243 */
+#define TclGetNamespaceChildTable \
+	(tclIntStubsPtr->tclGetNamespaceChildTable) /* 244 */
+#define TclGetNamespaceCommandTable \
+	(tclIntStubsPtr->tclGetNamespaceCommandTable) /* 245 */
+#define TclInitRewriteEnsemble \
+	(tclIntStubsPtr->tclInitRewriteEnsemble) /* 246 */
+#define TclResetRewriteEnsemble \
+	(tclIntStubsPtr->tclResetRewriteEnsemble) /* 247 */
+#define TclCopyChannel \
+	(tclIntStubsPtr->tclCopyChannel) /* 248 */
+#define TclDoubleDigits \
+	(tclIntStubsPtr->tclDoubleDigits) /* 249 */
+#define TclSetSlaveCancelFlags \
+	(tclIntStubsPtr->tclSetSlaveCancelFlags) /* 250 */
+#define TclRegisterLiteral \
+	(tclIntStubsPtr->tclRegisterLiteral) /* 251 */
+#define TclPtrGetVar \
+	(tclIntStubsPtr->tclPtrGetVar) /* 252 */
+#define TclPtrSetVar \
+	(tclIntStubsPtr->tclPtrSetVar) /* 253 */
+#define TclPtrIncrObjVar \
+	(tclIntStubsPtr->tclPtrIncrObjVar) /* 254 */
+#define TclPtrObjMakeUpvar \
+	(tclIntStubsPtr->tclPtrObjMakeUpvar) /* 255 */
+#define TclPtrUnsetVar \
+	(tclIntStubsPtr->tclPtrUnsetVar) /* 256 */
+#define TclStaticPackage \
+	(tclIntStubsPtr->tclStaticPackage) /* 257 */
+/* Slot 258 is reserved */
+/* Slot 259 is reserved */
+/* Slot 260 is reserved */
+#define TclUnusedStubEntry \
+	(tclIntStubsPtr->tclUnusedStubEntry) /* 261 */
+
+#endif /* defined(USE_TCL_STUBS) */
+
+/* !END!: Do not edit above this line. */
+
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLIMPORT
+
+#undef TclGetStartupScriptFileName
+#undef TclSetStartupScriptFileName
+#undef TclGetStartupScriptPath
+#undef TclSetStartupScriptPath
+#undef TclBackgroundException
+#undef TclUnusedStubEntry
+#undef TclObjInterpProc
+#define TclObjInterpProc TclGetObjInterpProc()
+
+#if defined(USE_TCL_STUBS) && defined(TCL_NO_DEPRECATED)
+#   undef Tcl_SetStartupScript
+#   define Tcl_SetStartupScript \
+	    (tclStubsPtr->tcl_SetStartupScript) /* 622 */
+#   undef Tcl_GetStartupScript
+#   define Tcl_GetStartupScript \
+	    (tclStubsPtr->tcl_GetStartupScript) /* 623 */
+#   undef Tcl_CreateNamespace
+#   define Tcl_CreateNamespace \
+	   (tclStubsPtr->tcl_CreateNamespace) /* 506 */
+#   undef Tcl_DeleteNamespace
+#   define Tcl_DeleteNamespace \
+	   (tclStubsPtr->tcl_DeleteNamespace) /* 507 */
+#   undef Tcl_AppendExportList
+#   define Tcl_AppendExportList \
+	   (tclStubsPtr->tcl_AppendExportList) /* 508 */
+#   undef Tcl_Export
+#   define Tcl_Export \
+	   (tclStubsPtr->tcl_Export) /* 509 */
+#   undef Tcl_Import
+#   define Tcl_Import \
+	   (tclStubsPtr->tcl_Import) /* 510 */
+#   undef Tcl_ForgetImport
+#   define Tcl_ForgetImport \
+	   (tclStubsPtr->tcl_ForgetImport) /* 511 */
+#   undef Tcl_GetCurrentNamespace
+#   define Tcl_GetCurrentNamespace \
+	   (tclStubsPtr->tcl_GetCurrentNamespace) /* 512 */
+#   undef Tcl_GetGlobalNamespace
+#   define Tcl_GetGlobalNamespace \
+	   (tclStubsPtr->tcl_GetGlobalNamespace) /* 513 */
+#   undef Tcl_FindNamespace
+#   define Tcl_FindNamespace \
+	   (tclStubsPtr->tcl_FindNamespace) /* 514 */
+#   undef Tcl_FindCommand
+#   define Tcl_FindCommand \
+	   (tclStubsPtr->tcl_FindCommand) /* 515 */
+#   undef Tcl_GetCommandFromObj
+#   define Tcl_GetCommandFromObj \
+	   (tclStubsPtr->tcl_GetCommandFromObj) /* 516 */
+#   undef Tcl_GetCommandFullName
+#   define Tcl_GetCommandFullName \
+	   (tclStubsPtr->tcl_GetCommandFullName) /* 517 */
+#endif
+
+#undef TclCopyChannelOld
+#undef TclSockMinimumBuffersOld
+
+#define TclSetChildCancelFlags TclSetSlaveCancelFlags
+
+#endif /* _TCLINTDECLS */
diff -Naur itcl/tcl_hdrs/tclInt.h ITCL_BLD/tcl_hdrs/tclInt.h
--- itcl/tcl_hdrs/tclInt.h	1969-12-31 19:00:00.000000000 -0500
+++ ITCL_BLD/tcl_hdrs/tclInt.h	2024-08-06 13:02:54.651985573 -0400
@@ -0,0 +1,4546 @@
+/*
+ * tclInt.h --
+ *
+ *	Declarations of things used internally by the Tcl interpreter.
+ *
+ * Copyright (c) 1987-1993 The Regents of the University of California.
+ * Copyright (c) 1993-1997 Lucent Technologies.
+ * Copyright (c) 1994-1998 Sun Microsystems, Inc.
+ * Copyright (c) 1998-1999 by Scriptics Corporation.
+ * Copyright (c) 2001, 2002 by Kevin B. Kenny.  All rights reserved.
+ * Copyright (c) 2007 Daniel A. Steffen <das@users.sourceforge.net>
+ * Copyright (c) 2006-2008 by Joe Mistachkin.  All rights reserved.
+ * Copyright (c) 2008 by Miguel Sofer. All rights reserved.
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TCLINT
+#define _TCLINT
+
+/*
+ * Some numerics configuration options.
+ */
+
+#undef ACCEPT_NAN
+
+/*
+ * Common include files needed by most of the Tcl source files are included
+ * here, so that system-dependent personalizations for the include files only
+ * have to be made in once place. This results in a few extra includes, but
+ * greater modularity. The order of the three groups of #includes is
+ * important. For example, stdio.h is needed by tcl.h.
+ */
+
+#include "tclPort.h"
+
+#include <stdio.h>
+
+#include <ctype.h>
+#ifdef NO_STDLIB_H
+#   include "../compat/stdlib.h"
+#else
+#   include <stdlib.h>
+#endif
+#ifdef NO_STRING_H
+#include "../compat/string.h"
+#else
+#include <string.h>
+#endif
+#if defined(STDC_HEADERS) || defined(__STDC__) || defined(__C99__FUNC__) \
+     || defined(__cplusplus) || defined(_MSC_VER) || defined(__ICC)
+#include <stddef.h>
+#else
+typedef int ptrdiff_t;
+#endif
+
+/*
+ * Ensure WORDS_BIGENDIAN is defined correctly:
+ * Needs to happen here in addition to configure to work with fat compiles on
+ * Darwin (where configure runs only once for multiple architectures).
+ */
+
+#ifdef HAVE_SYS_TYPES_H
+#    include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+#    include <sys/param.h>
+#endif
+#ifdef BYTE_ORDER
+#    ifdef BIG_ENDIAN
+#	 if BYTE_ORDER == BIG_ENDIAN
+#	     undef WORDS_BIGENDIAN
+#	     define WORDS_BIGENDIAN 1
+#	 endif
+#    endif
+#    ifdef LITTLE_ENDIAN
+#	 if BYTE_ORDER == LITTLE_ENDIAN
+#	     undef WORDS_BIGENDIAN
+#	 endif
+#    endif
+#endif
+
+/*
+ * Used to tag functions that are only to be visible within the module being
+ * built and not outside it (where this is supported by the linker).
+ */
+
+#ifndef MODULE_SCOPE
+#   ifdef __cplusplus
+#	define MODULE_SCOPE extern "C"
+#   else
+#	define MODULE_SCOPE extern
+#   endif
+#endif
+
+/*
+ * Macros used to cast between pointers and integers (e.g. when storing an int
+ * in ClientData), on 64-bit architectures they avoid gcc warning about "cast
+ * to/from pointer from/to integer of different size".
+ */
+
+#if !defined(INT2PTR) && !defined(PTR2INT)
+#   if defined(HAVE_INTPTR_T) || defined(intptr_t)
+#	define INT2PTR(p) ((void *)(intptr_t)(p))
+#	define PTR2INT(p) ((int)(intptr_t)(p))
+#   else
+#	define INT2PTR(p) ((void *)(p))
+#	define PTR2INT(p) ((int)(p))
+#   endif
+#endif
+#if !defined(UINT2PTR) && !defined(PTR2UINT)
+#   if defined(HAVE_UINTPTR_T) || defined(uintptr_t)
+#	define UINT2PTR(p) ((void *)(uintptr_t)(p))
+#	define PTR2UINT(p) ((unsigned int)(uintptr_t)(p))
+#   else
+#	define UINT2PTR(p) ((void *)(p))
+#	define PTR2UINT(p) ((unsigned int)(p))
+#   endif
+#endif
+
+#if defined(_WIN32) && defined(_MSC_VER)
+#   define vsnprintf _vsnprintf
+#   define snprintf _snprintf
+#endif
+
+/*
+ * The following procedures allow namespaces to be customized to support
+ * special name resolution rules for commands/variables.
+ */
+
+struct Tcl_ResolvedVarInfo;
+
+typedef Tcl_Var (Tcl_ResolveRuntimeVarProc)(Tcl_Interp *interp,
+	struct Tcl_ResolvedVarInfo *vinfoPtr);
+
+typedef void (Tcl_ResolveVarDeleteProc)(struct Tcl_ResolvedVarInfo *vinfoPtr);
+
+/*
+ * The following structure encapsulates the routines needed to resolve a
+ * variable reference at runtime. Any variable specific state will typically
+ * be appended to this structure.
+ */
+
+typedef struct Tcl_ResolvedVarInfo {
+    Tcl_ResolveRuntimeVarProc *fetchProc;
+    Tcl_ResolveVarDeleteProc *deleteProc;
+} Tcl_ResolvedVarInfo;
+
+typedef int (Tcl_ResolveCompiledVarProc)(Tcl_Interp *interp,
+	CONST84 char *name, int length, Tcl_Namespace *context,
+	Tcl_ResolvedVarInfo **rPtr);
+
+typedef int (Tcl_ResolveVarProc)(Tcl_Interp *interp, CONST84 char *name,
+	Tcl_Namespace *context, int flags, Tcl_Var *rPtr);
+
+typedef int (Tcl_ResolveCmdProc)(Tcl_Interp *interp, CONST84 char *name,
+	Tcl_Namespace *context, int flags, Tcl_Command *rPtr);
+
+typedef struct Tcl_ResolverInfo {
+    Tcl_ResolveCmdProc *cmdResProc;
+				/* Procedure handling command name
+				 * resolution. */
+    Tcl_ResolveVarProc *varResProc;
+				/* Procedure handling variable name resolution
+				 * for variables that can only be handled at
+				 * runtime. */
+    Tcl_ResolveCompiledVarProc *compiledVarResProc;
+				/* Procedure handling variable name resolution
+				 * at compile time. */
+} Tcl_ResolverInfo;
+
+/*
+ * This flag bit should not interfere with TCL_GLOBAL_ONLY,
+ * TCL_NAMESPACE_ONLY, or TCL_LEAVE_ERR_MSG; it signals that the variable
+ * lookup is performed for upvar (or similar) purposes, with slightly
+ * different rules:
+ *    - Bug #696893 - variable is either proc-local or in the current
+ *	namespace; never follow the second (global) resolution path
+ *    - Bug #631741 - do not use special namespace or interp resolvers
+ *
+ * It should also not collide with the (deprecated) TCL_PARSE_PART1 flag
+ * (Bug #835020)
+ */
+
+#define TCL_AVOID_RESOLVERS 0x40000
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to namespaces.
+ *----------------------------------------------------------------
+ */
+
+typedef struct Tcl_Ensemble Tcl_Ensemble;
+typedef struct NamespacePathEntry NamespacePathEntry;
+
+/*
+ * Special hashtable for variables:  This is just a Tcl_HashTable with a nsPtr
+ * field added at the end, so that variables can find their namespace
+ * without having to copy a pointer in their struct by accessing them via
+ * their hPtr->tablePtr.
+ */
+
+typedef struct TclVarHashTable {
+    Tcl_HashTable table;
+    struct Namespace *nsPtr;
+} TclVarHashTable;
+
+/*
+ * This is for itcl - it likes to search our varTables directly :(
+ */
+
+#define TclVarHashFindVar(tablePtr, key) \
+    TclVarHashCreateVar((tablePtr), (key), NULL)
+
+/*
+ * Define this to reduce the amount of space that the average namespace
+ * consumes by only allocating the table of child namespaces when necessary.
+ * Defining it breaks compatibility for Tcl extensions (e.g., itcl) which
+ * reach directly into the Namespace structure.
+ */
+
+#undef BREAK_NAMESPACE_COMPAT
+
+/*
+ * The structure below defines a namespace.
+ * Note: the first five fields must match exactly the fields in a
+ * Tcl_Namespace structure (see tcl.h). If you change one, be sure to change
+ * the other.
+ */
+
+typedef struct Namespace {
+    char *name;			/* The namespace's simple (unqualified) name.
+				 * This contains no ::'s. The name of the
+				 * global namespace is "" although "::" is an
+				 * synonym. */
+    char *fullName;		/* The namespace's fully qualified name. This
+				 * starts with ::. */
+    ClientData clientData;	/* An arbitrary value associated with this
+				 * namespace. */
+    Tcl_NamespaceDeleteProc *deleteProc;
+				/* Procedure invoked when deleting the
+				 * namespace to, e.g., free clientData. */
+    struct Namespace *parentPtr;/* Points to the namespace that contains this
+				 * one. NULL if this is the global
+				 * namespace. */
+#ifndef BREAK_NAMESPACE_COMPAT
+    Tcl_HashTable childTable;	/* Contains any child namespaces. Indexed by
+				 * strings; values have type (Namespace *). */
+#else
+    Tcl_HashTable *childTablePtr;
+				/* Contains any child namespaces. Indexed by
+				 * strings; values have type (Namespace *). If
+				 * NULL, there are no children. */
+#endif
+    long nsId;			/* Unique id for the namespace. */
+    Tcl_Interp *interp;		/* The interpreter containing this
+				 * namespace. */
+    int flags;			/* OR-ed combination of the namespace status
+				 * flags NS_DYING and NS_DEAD listed below. */
+    int activationCount;	/* Number of "activations" or active call
+				 * frames for this namespace that are on the
+				 * Tcl call stack. The namespace won't be
+				 * freed until activationCount becomes zero. */
+    int refCount;		/* Count of references by namespaceName
+				 * objects. The namespace can't be freed until
+				 * refCount becomes zero. */
+    Tcl_HashTable cmdTable;	/* Contains all the commands currently
+				 * registered in the namespace. Indexed by
+				 * strings; values have type (Command *).
+				 * Commands imported by Tcl_Import have
+				 * Command structures that point (via an
+				 * ImportedCmdRef structure) to the Command
+				 * structure in the source namespace's command
+				 * table. */
+    TclVarHashTable varTable;	/* Contains all the (global) variables
+				 * currently in this namespace. Indexed by
+				 * strings; values have type (Var *). */
+    char **exportArrayPtr;	/* Points to an array of string patterns
+				 * specifying which commands are exported. A
+				 * pattern may include "string match" style
+				 * wildcard characters to specify multiple
+				 * commands; however, no namespace qualifiers
+				 * are allowed. NULL if no export patterns are
+				 * registered. */
+    int numExportPatterns;	/* Number of export patterns currently
+				 * registered using "namespace export". */
+    int maxExportPatterns;	/* Number of export patterns for which space
+				 * is currently allocated. */
+    int cmdRefEpoch;		/* Incremented if a newly added command
+				 * shadows a command for which this namespace
+				 * has already cached a Command* pointer; this
+				 * causes all its cached Command* pointers to
+				 * be invalidated. */
+    int resolverEpoch;		/* Incremented whenever (a) the name
+				 * resolution rules change for this namespace
+				 * or (b) a newly added command shadows a
+				 * command that is compiled to bytecodes. This
+				 * invalidates all byte codes compiled in the
+				 * namespace, causing the code to be
+				 * recompiled under the new rules.*/
+    Tcl_ResolveCmdProc *cmdResProc;
+				/* If non-null, this procedure overrides the
+				 * usual command resolution mechanism in Tcl.
+				 * This procedure is invoked within
+				 * Tcl_FindCommand to resolve all command
+				 * references within the namespace. */
+    Tcl_ResolveVarProc *varResProc;
+				/* If non-null, this procedure overrides the
+				 * usual variable resolution mechanism in Tcl.
+				 * This procedure is invoked within
+				 * Tcl_FindNamespaceVar to resolve all
+				 * variable references within the namespace at
+				 * runtime. */
+    Tcl_ResolveCompiledVarProc *compiledVarResProc;
+				/* If non-null, this procedure overrides the
+				 * usual variable resolution mechanism in Tcl.
+				 * This procedure is invoked within
+				 * LookupCompiledLocal to resolve variable
+				 * references within the namespace at compile
+				 * time. */
+    int exportLookupEpoch;	/* Incremented whenever a command is added to
+				 * a namespace, removed from a namespace or
+				 * the exports of a namespace are changed.
+				 * Allows TIP#112-driven command lists to be
+				 * validated efficiently. */
+    Tcl_Ensemble *ensembles;	/* List of structures that contain the details
+				 * of the ensembles that are implemented on
+				 * top of this namespace. */
+    Tcl_Obj *unknownHandlerPtr;	/* A script fragment to be used when command
+				 * resolution in this namespace fails. TIP
+				 * 181. */
+    int commandPathLength;	/* The length of the explicit path. */
+    NamespacePathEntry *commandPathArray;
+				/* The explicit path of the namespace as an
+				 * array. */
+    NamespacePathEntry *commandPathSourceList;
+				/* Linked list of path entries that point to
+				 * this namespace. */
+    Tcl_NamespaceDeleteProc *earlyDeleteProc;
+				/* Just like the deleteProc field (and called
+				 * with the same clientData) but called at the
+				 * start of the deletion process, so there is
+				 * a chance for code to do stuff inside the
+				 * namespace before deletion completes. */
+} Namespace;
+
+/*
+ * An entry on a namespace's command resolution path.
+ */
+
+struct NamespacePathEntry {
+    Namespace *nsPtr;		/* What does this path entry point to? If it
+				 * is NULL, this path entry points is
+				 * redundant and should be skipped. */
+    Namespace *creatorNsPtr;	/* Where does this path entry point from? This
+				 * allows for efficient invalidation of
+				 * references when the path entry's target
+				 * updates its current list of defined
+				 * commands. */
+    NamespacePathEntry *prevPtr, *nextPtr;
+				/* Linked list pointers or NULL at either end
+				 * of the list that hangs off Namespace's
+				 * commandPathSourceList field. */
+};
+
+/*
+ * Flags used to represent the status of a namespace:
+ *
+ * NS_DYING -	1 means Tcl_DeleteNamespace has been called to delete the
+ *		namespace but there are still active call frames on the Tcl
+ *		stack that refer to the namespace. When the last call frame
+ *		referring to it has been popped, it's variables and command
+ *		will be destroyed and it will be marked "dead" (NS_DEAD). The
+ *		namespace can no longer be looked up by name.
+ * NS_DEAD -	1 means Tcl_DeleteNamespace has been called to delete the
+ *		namespace and no call frames still refer to it. Its variables
+ *		and command have already been destroyed. This bit allows the
+ *		namespace resolution code to recognize that the namespace is
+ *		"deleted". When the last namespaceName object in any byte code
+ *		unit that refers to the namespace has been freed (i.e., when
+ *		the namespace's refCount is 0), the namespace's storage will
+ *		be freed.
+ * NS_KILLED -	1 means that TclTeardownNamespace has already been called on
+ *		this namespace and it should not be called again [Bug 1355942]
+ * NS_SUPPRESS_COMPILATION -
+ *		Marks the commands in this namespace for not being compiled,
+ *		forcing them to be looked up every time.
+ */
+
+#define NS_DYING	0x01
+#define NS_DEAD		0x02
+#define NS_KILLED	0x04
+#define NS_SUPPRESS_COMPILATION	0x08
+
+/*
+ * Flags passed to TclGetNamespaceForQualName:
+ *
+ * TCL_GLOBAL_ONLY		- (see tcl.h) Look only in the global ns.
+ * TCL_NAMESPACE_ONLY		- (see tcl.h) Look only in the context ns.
+ * TCL_CREATE_NS_IF_UNKNOWN	- Create unknown namespaces.
+ * TCL_FIND_ONLY_NS		- The name sought is a namespace name.
+ */
+
+#define TCL_CREATE_NS_IF_UNKNOWN	0x800
+#define TCL_FIND_ONLY_NS		0x1000
+
+/*
+ * The client data for an ensemble command. This consists of the table of
+ * commands that are actually exported by the namespace, and an epoch counter
+ * that, combined with the exportLookupEpoch field of the namespace structure,
+ * defines whether the table contains valid data or will need to be recomputed
+ * next time the ensemble command is called.
+ */
+
+typedef struct EnsembleConfig {
+    Namespace *nsPtr;		/* The namespace backing this ensemble up. */
+    Tcl_Command token;		/* The token for the command that provides
+				 * ensemble support for the namespace, or NULL
+				 * if the command has been deleted (or never
+				 * existed; the global namespace never has an
+				 * ensemble command.) */
+    int epoch;			/* The epoch at which this ensemble's table of
+				 * exported commands is valid. */
+    char **subcommandArrayPtr;	/* Array of ensemble subcommand names. At all
+				 * consistent points, this will have the same
+				 * number of entries as there are entries in
+				 * the subcommandTable hash. */
+    Tcl_HashTable subcommandTable;
+				/* Hash table of ensemble subcommand names,
+				 * which are its keys so this also provides
+				 * the storage management for those subcommand
+				 * names. The contents of the entry values are
+				 * object version the prefix lists to use when
+				 * substituting for the command/subcommand to
+				 * build the ensemble implementation command.
+				 * Has to be stored here as well as in
+				 * subcommandDict because that field is NULL
+				 * when we are deriving the ensemble from the
+				 * namespace exports list. FUTURE WORK: use
+				 * object hash table here. */
+    struct EnsembleConfig *next;/* The next ensemble in the linked list of
+				 * ensembles associated with a namespace. If
+				 * this field points to this ensemble, the
+				 * structure has already been unlinked from
+				 * all lists, and cannot be found by scanning
+				 * the list from the namespace's ensemble
+				 * field. */
+    int flags;			/* OR'ed combo of TCL_ENSEMBLE_PREFIX,
+				 * ENSEMBLE_DEAD and ENSEMBLE_COMPILE. */
+
+    /* OBJECT FIELDS FOR ENSEMBLE CONFIGURATION */
+
+    Tcl_Obj *subcommandDict;	/* Dictionary providing mapping from
+				 * subcommands to their implementing command
+				 * prefixes, or NULL if we are to build the
+				 * map automatically from the namespace
+				 * exports. */
+    Tcl_Obj *subcmdList;	/* List of commands that this ensemble
+				 * actually provides, and whose implementation
+				 * will be built using the subcommandDict (if
+				 * present and defined) and by simple mapping
+				 * to the namespace otherwise. If NULL,
+				 * indicates that we are using the (dynamic)
+				 * list of currently exported commands. */
+    Tcl_Obj *unknownHandler;	/* Script prefix used to handle the case when
+				 * no match is found (according to the rule
+				 * defined by flag bit TCL_ENSEMBLE_PREFIX) or
+				 * NULL to use the default error-generating
+				 * behaviour. The script execution gets all
+				 * the arguments to the ensemble command
+				 * (including objv[0]) and will have the
+				 * results passed directly back to the caller
+				 * (including the error code) unless the code
+				 * is TCL_CONTINUE in which case the
+				 * subcommand will be re-parsed by the ensemble
+				 * core, presumably because the ensemble
+				 * itself has been updated. */
+    Tcl_Obj *parameterList;	/* List of ensemble parameter names. */
+    int numParameters;		/* Cached number of parameters. This is either
+				 * 0 (if the parameterList field is NULL) or
+				 * the length of the list in the parameterList
+				 * field. */
+} EnsembleConfig;
+
+/*
+ * Various bits for the EnsembleConfig.flags field.
+ */
+
+#define ENSEMBLE_DEAD	0x1	/* Flag value to say that the ensemble is dead
+				 * and on its way out. */
+#define ENSEMBLE_COMPILE 0x4	/* Flag to enable bytecode compilation of an
+				 * ensemble. */
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to variables. These are used primarily in tclVar.c
+ *----------------------------------------------------------------
+ */
+
+/*
+ * The following structure defines a variable trace, which is used to invoke a
+ * specific C procedure whenever certain operations are performed on a
+ * variable.
+ */
+
+typedef struct VarTrace {
+    Tcl_VarTraceProc *traceProc;/* Procedure to call when operations given by
+				 * flags are performed on variable. */
+    ClientData clientData;	/* Argument to pass to proc. */
+    int flags;			/* What events the trace procedure is
+				 * interested in: OR-ed combination of
+				 * TCL_TRACE_READS, TCL_TRACE_WRITES,
+				 * TCL_TRACE_UNSETS and TCL_TRACE_ARRAY. */
+    struct VarTrace *nextPtr;	/* Next in list of traces associated with a
+				 * particular variable. */
+} VarTrace;
+
+/*
+ * The following structure defines a command trace, which is used to invoke a
+ * specific C procedure whenever certain operations are performed on a
+ * command.
+ */
+
+typedef struct CommandTrace {
+    Tcl_CommandTraceProc *traceProc;
+				/* Procedure to call when operations given by
+				 * flags are performed on command. */
+    ClientData clientData;	/* Argument to pass to proc. */
+    int flags;			/* What events the trace procedure is
+				 * interested in: OR-ed combination of
+				 * TCL_TRACE_RENAME, TCL_TRACE_DELETE. */
+    struct CommandTrace *nextPtr;
+				/* Next in list of traces associated with a
+				 * particular command. */
+    int refCount;		/* Used to ensure this structure is not
+				 * deleted too early. Keeps track of how many
+				 * pieces of code have a pointer to this
+				 * structure. */
+} CommandTrace;
+
+/*
+ * When a command trace is active (i.e. its associated procedure is executing)
+ * one of the following structures is linked into a list associated with the
+ * command's interpreter. The information in the structure is needed in order
+ * for Tcl to behave reasonably if traces are deleted while traces are active.
+ */
+
+typedef struct ActiveCommandTrace {
+    struct Command *cmdPtr;	/* Command that's being traced. */
+    struct ActiveCommandTrace *nextPtr;
+				/* Next in list of all active command traces
+				 * for the interpreter, or NULL if no more. */
+    CommandTrace *nextTracePtr;	/* Next trace to check after current trace
+				 * procedure returns; if this trace gets
+				 * deleted, must update pointer to avoid using
+				 * free'd memory. */
+    int reverseScan;		/* Boolean set true when traces are scanning
+				 * in reverse order. */
+} ActiveCommandTrace;
+
+/*
+ * When a variable trace is active (i.e. its associated procedure is
+ * executing) one of the following structures is linked into a list associated
+ * with the variable's interpreter. The information in the structure is needed
+ * in order for Tcl to behave reasonably if traces are deleted while traces
+ * are active.
+ */
+
+typedef struct ActiveVarTrace {
+    struct Var *varPtr;		/* Variable that's being traced. */
+    struct ActiveVarTrace *nextPtr;
+				/* Next in list of all active variable traces
+				 * for the interpreter, or NULL if no more. */
+    VarTrace *nextTracePtr;	/* Next trace to check after current trace
+				 * procedure returns; if this trace gets
+				 * deleted, must update pointer to avoid using
+				 * free'd memory. */
+} ActiveVarTrace;
+
+/*
+ * The structure below defines a variable, which associates a string name with
+ * a Tcl_Obj value. These structures are kept in procedure call frames (for
+ * local variables recognized by the compiler) or in the heap (for global
+ * variables and any variable not known to the compiler). For each Var
+ * structure in the heap, a hash table entry holds the variable name and a
+ * pointer to the Var structure.
+ */
+
+typedef struct Var {
+    int flags;			/* Miscellaneous bits of information about
+				 * variable. See below for definitions. */
+    union {
+	Tcl_Obj *objPtr;	/* The variable's object value. Used for
+				 * scalar variables and array elements. */
+	TclVarHashTable *tablePtr;/* For array variables, this points to
+				 * information about the hash table used to
+				 * implement the associative array. Points to
+				 * ckalloc-ed data. */
+	struct Var *linkPtr;	/* If this is a global variable being referred
+				 * to in a procedure, or a variable created by
+				 * "upvar", this field points to the
+				 * referenced variable's Var struct. */
+    } value;
+} Var;
+
+typedef struct VarInHash {
+    Var var;
+    int refCount;		/* Counts number of active uses of this
+				 * variable: 1 for the entry in the hash
+				 * table, 1 for each additional variable whose
+				 * linkPtr points here, 1 for each nested
+				 * trace active on variable, and 1 if the
+				 * variable is a namespace variable. This
+				 * record can't be deleted until refCount
+				 * becomes 0. */
+    Tcl_HashEntry entry;	/* The hash table entry that refers to this
+				 * variable. This is used to find the name of
+				 * the variable and to delete it from its
+				 * hash table if it is no longer needed. It
+				 * also holds the variable's name. */
+} VarInHash;
+
+/*
+ * Flag bits for variables. The first two (VAR_ARRAY and VAR_LINK) are
+ * mutually exclusive and give the "type" of the variable. If none is set,
+ * this is a scalar variable.
+ *
+ * VAR_ARRAY -			1 means this is an array variable rather than
+ *				a scalar variable or link. The "tablePtr"
+ *				field points to the array's hash table for its
+ *				elements.
+ * VAR_LINK -			1 means this Var structure contains a pointer
+ *				to another Var structure that either has the
+ *				real value or is itself another VAR_LINK
+ *				pointer. Variables like this come about
+ *				through "upvar" and "global" commands, or
+ *				through references to variables in enclosing
+ *				namespaces.
+ *
+ * Flags that indicate the type and status of storage; none is set for
+ * compiled local variables (Var structs).
+ *
+ * VAR_IN_HASHTABLE -		1 means this variable is in a hash table and
+ *				the Var structure is malloc'ed. 0 if it is a
+ *				local variable that was assigned a slot in a
+ *				procedure frame by the compiler so the Var
+ *				storage is part of the call frame.
+ * VAR_DEAD_HASH		1 means that this var's entry in the hash table
+ *				has already been deleted.
+ * VAR_ARRAY_ELEMENT -		1 means that this variable is an array
+ *				element, so it is not legal for it to be an
+ *				array itself (the VAR_ARRAY flag had better
+ *				not be set).
+ * VAR_NAMESPACE_VAR -		1 means that this variable was declared as a
+ *				namespace variable. This flag ensures it
+ *				persists until its namespace is destroyed or
+ *				until the variable is unset; it will persist
+ *				even if it has not been initialized and is
+ *				marked undefined. The variable's refCount is
+ *				incremented to reflect the "reference" from
+ *				its namespace.
+ *
+ * Flag values relating to the variable's trace and search status.
+ *
+ * VAR_TRACED_READ
+ * VAR_TRACED_WRITE
+ * VAR_TRACED_UNSET
+ * VAR_TRACED_ARRAY
+ * VAR_TRACE_ACTIVE -		1 means that trace processing is currently
+ *				underway for a read or write access, so new
+ *				read or write accesses should not cause trace
+ *				procedures to be called and the variable can't
+ *				be deleted.
+ * VAR_SEARCH_ACTIVE
+ *
+ * The following additional flags are used with the CompiledLocal type defined
+ * below:
+ *
+ * VAR_ARGUMENT -		1 means that this variable holds a procedure
+ *				argument.
+ * VAR_TEMPORARY -		1 if the local variable is an anonymous
+ *				temporary variable. Temporaries have a NULL
+ *				name.
+ * VAR_RESOLVED -		1 if name resolution has been done for this
+ *				variable.
+ * VAR_IS_ARGS			1 if this variable is the last argument and is
+ *				named "args".
+ */
+
+/*
+ * FLAGS RENUMBERED: everything breaks already, make things simpler.
+ *
+ * IMPORTANT: skip the values 0x10, 0x20, 0x40, 0x800 corresponding to
+ * TCL_TRACE_(READS/WRITES/UNSETS/ARRAY): makes code simpler in tclTrace.c
+ *
+ * Keep the flag values for VAR_ARGUMENT and VAR_TEMPORARY so that old values
+ * in precompiled scripts keep working.
+ */
+
+/* Type of value (0 is scalar) */
+#define VAR_ARRAY		0x1
+#define VAR_LINK		0x2
+
+/* Type of storage (0 is compiled local) */
+#define VAR_IN_HASHTABLE	0x4
+#define VAR_DEAD_HASH		0x8
+#define VAR_ARRAY_ELEMENT	0x1000
+#define VAR_NAMESPACE_VAR	0x80	/* KEEP OLD VALUE for Itcl */
+
+#define VAR_ALL_HASH \
+	(VAR_IN_HASHTABLE|VAR_DEAD_HASH|VAR_NAMESPACE_VAR|VAR_ARRAY_ELEMENT)
+
+/* Trace and search state. */
+
+#define VAR_TRACED_READ		0x10	/* TCL_TRACE_READS */
+#define VAR_TRACED_WRITE	0x20	/* TCL_TRACE_WRITES */
+#define VAR_TRACED_UNSET	0x40	/* TCL_TRACE_UNSETS */
+#define VAR_TRACED_ARRAY	0x800	/* TCL_TRACE_ARRAY */
+#define VAR_TRACE_ACTIVE	0x2000
+#define VAR_SEARCH_ACTIVE	0x4000
+#define VAR_ALL_TRACES \
+	(VAR_TRACED_READ|VAR_TRACED_WRITE|VAR_TRACED_ARRAY|VAR_TRACED_UNSET)
+
+/* Special handling on initialisation (only CompiledLocal). */
+#define VAR_ARGUMENT		0x100	/* KEEP OLD VALUE! See tclProc.c */
+#define VAR_TEMPORARY		0x200	/* KEEP OLD VALUE! See tclProc.c */
+#define VAR_IS_ARGS		0x400
+#define VAR_RESOLVED		0x8000
+
+/*
+ * Macros to ensure that various flag bits are set properly for variables.
+ * The ANSI C "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE void	TclSetVarScalar(Var *varPtr);
+ * MODULE_SCOPE void	TclSetVarArray(Var *varPtr);
+ * MODULE_SCOPE void	TclSetVarLink(Var *varPtr);
+ * MODULE_SCOPE void	TclSetVarArrayElement(Var *varPtr);
+ * MODULE_SCOPE void	TclSetVarUndefined(Var *varPtr);
+ * MODULE_SCOPE void	TclClearVarUndefined(Var *varPtr);
+ */
+
+#define TclSetVarScalar(varPtr) \
+    (varPtr)->flags &= ~(VAR_ARRAY|VAR_LINK)
+
+#define TclSetVarArray(varPtr) \
+    (varPtr)->flags = ((varPtr)->flags & ~VAR_LINK) | VAR_ARRAY
+
+#define TclSetVarLink(varPtr) \
+    (varPtr)->flags = ((varPtr)->flags & ~VAR_ARRAY) | VAR_LINK
+
+#define TclSetVarArrayElement(varPtr) \
+    (varPtr)->flags = ((varPtr)->flags & ~VAR_ARRAY) | VAR_ARRAY_ELEMENT
+
+#define TclSetVarUndefined(varPtr) \
+    (varPtr)->flags &= ~(VAR_ARRAY|VAR_LINK);\
+    (varPtr)->value.objPtr = NULL
+
+#define TclClearVarUndefined(varPtr)
+
+#define TclSetVarTraceActive(varPtr) \
+    (varPtr)->flags |= VAR_TRACE_ACTIVE
+
+#define TclClearVarTraceActive(varPtr) \
+    (varPtr)->flags &= ~VAR_TRACE_ACTIVE
+
+#define TclSetVarNamespaceVar(varPtr) \
+    if (!TclIsVarNamespaceVar(varPtr)) {\
+	(varPtr)->flags |= VAR_NAMESPACE_VAR;\
+	if (TclIsVarInHash(varPtr)) {\
+	    ((VarInHash *)(varPtr))->refCount++;\
+	}\
+    }
+
+#define TclClearVarNamespaceVar(varPtr) \
+    if (TclIsVarNamespaceVar(varPtr)) {\
+	(varPtr)->flags &= ~VAR_NAMESPACE_VAR;\
+	if (TclIsVarInHash(varPtr)) {\
+	    ((VarInHash *)(varPtr))->refCount--;\
+	}\
+    }
+
+/*
+ * Macros to read various flag bits of variables.
+ * The ANSI C "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE int	TclIsVarScalar(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarLink(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarArray(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarUndefined(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarArrayElement(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarTemporary(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarArgument(Var *varPtr);
+ * MODULE_SCOPE int	TclIsVarResolved(Var *varPtr);
+ */
+
+#define TclIsVarScalar(varPtr) \
+    !((varPtr)->flags & (VAR_ARRAY|VAR_LINK))
+
+#define TclIsVarLink(varPtr) \
+    ((varPtr)->flags & VAR_LINK)
+
+#define TclIsVarArray(varPtr) \
+    ((varPtr)->flags & VAR_ARRAY)
+
+#define TclIsVarUndefined(varPtr) \
+    ((varPtr)->value.objPtr == NULL)
+
+#define TclIsVarArrayElement(varPtr) \
+    ((varPtr)->flags & VAR_ARRAY_ELEMENT)
+
+#define TclIsVarNamespaceVar(varPtr) \
+    ((varPtr)->flags & VAR_NAMESPACE_VAR)
+
+#define TclIsVarTemporary(varPtr) \
+    ((varPtr)->flags & VAR_TEMPORARY)
+
+#define TclIsVarArgument(varPtr) \
+    ((varPtr)->flags & VAR_ARGUMENT)
+
+#define TclIsVarResolved(varPtr) \
+    ((varPtr)->flags & VAR_RESOLVED)
+
+#define TclIsVarTraceActive(varPtr) \
+    ((varPtr)->flags & VAR_TRACE_ACTIVE)
+
+#define TclIsVarTraced(varPtr) \
+    ((varPtr)->flags & VAR_ALL_TRACES)
+
+#define TclIsVarInHash(varPtr) \
+    ((varPtr)->flags & VAR_IN_HASHTABLE)
+
+#define TclIsVarDeadHash(varPtr) \
+    ((varPtr)->flags & VAR_DEAD_HASH)
+
+#define TclGetVarNsPtr(varPtr) \
+    (TclIsVarInHash(varPtr) \
+	? ((TclVarHashTable *) ((((VarInHash *) (varPtr))->entry.tablePtr)))->nsPtr \
+	: NULL)
+
+#define VarHashRefCount(varPtr) \
+    ((VarInHash *) (varPtr))->refCount
+
+/*
+ * Macros for direct variable access by TEBC.
+ */
+
+#define TclIsVarDirectReadable(varPtr) \
+    (   !((varPtr)->flags & (VAR_ARRAY|VAR_LINK|VAR_TRACED_READ)) \
+    &&  (varPtr)->value.objPtr)
+
+#define TclIsVarDirectWritable(varPtr) \
+    !((varPtr)->flags & (VAR_ARRAY|VAR_LINK|VAR_TRACED_WRITE|VAR_DEAD_HASH))
+
+#define TclIsVarDirectUnsettable(varPtr) \
+    !((varPtr)->flags & (VAR_ARRAY|VAR_LINK|VAR_TRACED_READ|VAR_TRACED_WRITE|VAR_TRACED_UNSET|VAR_DEAD_HASH))
+
+#define TclIsVarDirectModifyable(varPtr) \
+    (   !((varPtr)->flags & (VAR_ARRAY|VAR_LINK|VAR_TRACED_READ|VAR_TRACED_WRITE)) \
+    &&  (varPtr)->value.objPtr)
+
+#define TclIsVarDirectReadable2(varPtr, arrayPtr) \
+    (TclIsVarDirectReadable(varPtr) &&\
+	(!(arrayPtr) || !((arrayPtr)->flags & VAR_TRACED_READ)))
+
+#define TclIsVarDirectWritable2(varPtr, arrayPtr) \
+    (TclIsVarDirectWritable(varPtr) &&\
+	(!(arrayPtr) || !((arrayPtr)->flags & VAR_TRACED_WRITE)))
+
+#define TclIsVarDirectModifyable2(varPtr, arrayPtr) \
+    (TclIsVarDirectModifyable(varPtr) &&\
+	(!(arrayPtr) || !((arrayPtr)->flags & (VAR_TRACED_READ|VAR_TRACED_WRITE))))
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to procedures. These are used primarily in
+ * tclProc.c, tclCompile.c, and tclExecute.c.
+ *----------------------------------------------------------------
+ */
+
+#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
+#   define TCLFLEXARRAY
+#elif defined(__GNUC__) && (__GNUC__ > 2)
+#   define TCLFLEXARRAY 0
+#else
+#   define TCLFLEXARRAY 1
+#endif
+
+/*
+ * Forward declaration to prevent an error when the forward reference to
+ * Command is encountered in the Proc and ImportRef types declared below.
+ */
+
+struct Command;
+
+/*
+ * The variable-length structure below describes a local variable of a
+ * procedure that was recognized by the compiler. These variables have a name,
+ * an element in the array of compiler-assigned local variables in the
+ * procedure's call frame, and various other items of information. If the
+ * local variable is a formal argument, it may also have a default value. The
+ * compiler can't recognize local variables whose names are expressions (these
+ * names are only known at runtime when the expressions are evaluated) or
+ * local variables that are created as a result of an "upvar" or "uplevel"
+ * command. These other local variables are kept separately in a hash table in
+ * the call frame.
+ */
+
+typedef struct CompiledLocal {
+    struct CompiledLocal *nextPtr;
+				/* Next compiler-recognized local variable for
+				 * this procedure, or NULL if this is the last
+				 * local. */
+    int nameLength;		/* The number of bytes in local variable's name.
+				 * Among others used to speed up var lookups. */
+    int frameIndex;		/* Index in the array of compiler-assigned
+				 * variables in the procedure call frame. */
+    int flags;			/* Flag bits for the local variable. Same as
+				 * the flags for the Var structure above,
+				 * although only VAR_ARGUMENT, VAR_TEMPORARY,
+				 * and VAR_RESOLVED make sense. */
+    Tcl_Obj *defValuePtr;	/* Pointer to the default value of an
+				 * argument, if any. NULL if not an argument
+				 * or, if an argument, no default value. */
+    Tcl_ResolvedVarInfo *resolveInfo;
+				/* Customized variable resolution info
+				 * supplied by the Tcl_ResolveCompiledVarProc
+				 * associated with a namespace. Each variable
+				 * is marked by a unique tag during
+				 * compilation, and that same tag is used to
+				 * find the variable at runtime. */
+    char name[TCLFLEXARRAY];		/* Name of the local variable starts here. If
+				 * the name is NULL, this will just be '\0'.
+				 * The actual size of this field will be large
+				 * enough to hold the name. MUST BE THE LAST
+				 * FIELD IN THE STRUCTURE! */
+} CompiledLocal;
+
+/*
+ * The structure below defines a command procedure, which consists of a
+ * collection of Tcl commands plus information about arguments and other local
+ * variables recognized at compile time.
+ */
+
+typedef struct Proc {
+    struct Interp *iPtr;	/* Interpreter for which this command is
+				 * defined. */
+    int refCount;		/* Reference count: 1 if still present in
+				 * command table plus 1 for each call to the
+				 * procedure that is currently active. This
+				 * structure can be freed when refCount
+				 * becomes zero. */
+    struct Command *cmdPtr;	/* Points to the Command structure for this
+				 * procedure. This is used to get the
+				 * namespace in which to execute the
+				 * procedure. */
+    Tcl_Obj *bodyPtr;		/* Points to the ByteCode object for
+				 * procedure's body command. */
+    int numArgs;		/* Number of formal parameters. */
+    int numCompiledLocals;	/* Count of local variables recognized by the
+				 * compiler including arguments and
+				 * temporaries. */
+    CompiledLocal *firstLocalPtr;
+				/* Pointer to first of the procedure's
+				 * compiler-allocated local variables, or NULL
+				 * if none. The first numArgs entries in this
+				 * list describe the procedure's formal
+				 * arguments. */
+    CompiledLocal *lastLocalPtr;/* Pointer to the last allocated local
+				 * variable or NULL if none. This has frame
+				 * index (numCompiledLocals-1). */
+} Proc;
+
+/*
+ * The type of functions called to process errors found during the execution
+ * of a procedure (or lambda term or ...).
+ */
+
+typedef void (ProcErrorProc)(Tcl_Interp *interp, Tcl_Obj *procNameObj);
+
+/*
+ * The structure below defines a command trace. This is used to allow Tcl
+ * clients to find out whenever a command is about to be executed.
+ */
+
+typedef struct Trace {
+    int level;		/* Only trace commands at nesting level less
+				 * than or equal to this. */
+    Tcl_CmdObjTraceProc *proc;	/* Procedure to call to trace command. */
+    ClientData clientData;	/* Arbitrary value to pass to proc. */
+    struct Trace *nextPtr;	/* Next in list of traces for this interp. */
+    int flags;			/* Flags governing the trace - see
+				 * Tcl_CreateObjTrace for details. */
+    Tcl_CmdObjTraceDeleteProc *delProc;
+				/* Procedure to call when trace is deleted. */
+} Trace;
+
+/*
+ * When an interpreter trace is active (i.e. its associated procedure is
+ * executing), one of the following structures is linked into a list
+ * associated with the interpreter. The information in the structure is needed
+ * in order for Tcl to behave reasonably if traces are deleted while traces
+ * are active.
+ */
+
+typedef struct ActiveInterpTrace {
+    struct ActiveInterpTrace *nextPtr;
+				/* Next in list of all active command traces
+				 * for the interpreter, or NULL if no more. */
+    Trace *nextTracePtr;	/* Next trace to check after current trace
+				 * procedure returns; if this trace gets
+				 * deleted, must update pointer to avoid using
+				 * free'd memory. */
+    int reverseScan;		/* Boolean set true when traces are scanning
+				 * in reverse order. */
+} ActiveInterpTrace;
+
+/*
+ * Flag values designating types of execution traces. See tclTrace.c for
+ * related flag values.
+ *
+ * TCL_TRACE_ENTER_EXEC		- triggers enter/enterstep traces.
+ * 				- passed to Tcl_CreateObjTrace to set up
+ *				  "enterstep" traces.
+ * TCL_TRACE_LEAVE_EXEC		- triggers leave/leavestep traces.
+ * 				- passed to Tcl_CreateObjTrace to set up
+ *				  "leavestep" traces.
+ */
+
+#define TCL_TRACE_ENTER_EXEC	1
+#define TCL_TRACE_LEAVE_EXEC	2
+
+/*
+ * The structure below defines an entry in the assocData hash table which is
+ * associated with an interpreter. The entry contains a pointer to a function
+ * to call when the interpreter is deleted, and a pointer to a user-defined
+ * piece of data.
+ */
+
+typedef struct AssocData {
+    Tcl_InterpDeleteProc *proc;	/* Proc to call when deleting. */
+    ClientData clientData;	/* Value to pass to proc. */
+} AssocData;
+
+/*
+ * The structure below defines a call frame. A call frame defines a naming
+ * context for a procedure call: its local naming scope (for local variables)
+ * and its global naming scope (a namespace, perhaps the global :: namespace).
+ * A call frame can also define the naming context for a namespace eval or
+ * namespace inscope command: the namespace in which the command's code should
+ * execute. The Tcl_CallFrame structures exist only while procedures or
+ * namespace eval/inscope's are being executed, and provide a kind of Tcl call
+ * stack.
+ *
+ * WARNING!! The structure definition must be kept consistent with the
+ * Tcl_CallFrame structure in tcl.h. If you change one, change the other.
+ */
+
+/*
+ * Will be grown to contain: pointers to the varnames (allocated at the end),
+ * plus the init values for each variable (suitable to be memcopied on init)
+ */
+
+typedef struct LocalCache {
+    int refCount;
+    int numVars;
+    Tcl_Obj *varName0;
+} LocalCache;
+
+#define localName(framePtr, i) \
+    ((&((framePtr)->localCachePtr->varName0))[(i)])
+
+MODULE_SCOPE void	TclFreeLocalCache(Tcl_Interp *interp,
+			    LocalCache *localCachePtr);
+
+typedef struct CallFrame {
+    Namespace *nsPtr;		/* Points to the namespace used to resolve
+				 * commands and global variables. */
+    int isProcCallFrame;	/* If 0, the frame was pushed to execute a
+				 * namespace command and var references are
+				 * treated as references to namespace vars;
+				 * varTablePtr and compiledLocals are ignored.
+				 * If FRAME_IS_PROC is set, the frame was
+				 * pushed to execute a Tcl procedure and may
+				 * have local vars. */
+    int objc;			/* This and objv below describe the arguments
+				 * for this procedure call. */
+    Tcl_Obj *const *objv;	/* Array of argument objects. */
+    struct CallFrame *callerPtr;
+				/* Value of interp->framePtr when this
+				 * procedure was invoked (i.e. next higher in
+				 * stack of all active procedures). */
+    struct CallFrame *callerVarPtr;
+				/* Value of interp->varFramePtr when this
+				 * procedure was invoked (i.e. determines
+				 * variable scoping within caller). Same as
+				 * callerPtr unless an "uplevel" command or
+				 * something equivalent was active in the
+				 * caller). */
+    int level;			/* Level of this procedure, for "uplevel"
+				 * purposes (i.e. corresponds to nesting of
+				 * callerVarPtr's, not callerPtr's). 1 for
+				 * outermost procedure, 0 for top-level. */
+    Proc *procPtr;		/* Points to the structure defining the called
+				 * procedure. Used to get information such as
+				 * the number of compiled local variables
+				 * (local variables assigned entries ["slots"]
+				 * in the compiledLocals array below). */
+    TclVarHashTable *varTablePtr;
+				/* Hash table containing local variables not
+				 * recognized by the compiler, or created at
+				 * execution time through, e.g., upvar.
+				 * Initially NULL and created if needed. */
+    int numCompiledLocals;	/* Count of local variables recognized
+				 * by the compiler including arguments. */
+    Var *compiledLocals;	/* Points to the array of local variables
+				 * recognized by the compiler. The compiler
+				 * emits code that refers to these variables
+				 * using an index into this array. */
+    ClientData clientData;	/* Pointer to some context that is used by
+				 * object systems. The meaning of the contents
+				 * of this field is defined by the code that
+				 * sets it, and it should only ever be set by
+				 * the code that is pushing the frame. In that
+				 * case, the code that sets it should also
+				 * have some means of discovering what the
+				 * meaning of the value is, which we do not
+				 * specify. */
+    LocalCache *localCachePtr;
+    Tcl_Obj    *tailcallPtr;
+				/* NULL if no tailcall is scheduled */
+} CallFrame;
+
+#define FRAME_IS_PROC	0x1
+#define FRAME_IS_LAMBDA 0x2
+#define FRAME_IS_METHOD	0x4	/* The frame is a method body, and the frame's
+				 * clientData field contains a CallContext
+				 * reference. Part of TIP#257. */
+#define FRAME_IS_OO_DEFINE 0x8	/* The frame is part of the inside workings of
+				 * the [oo::define] command; the clientData
+				 * field contains an Object reference that has
+				 * been confirmed to refer to a class. Part of
+				 * TIP#257. */
+
+/*
+ * TIP #280
+ * The structure below defines a command frame. A command frame provides
+ * location information for all commands executing a tcl script (source, eval,
+ * uplevel, procedure bodies, ...). The runtime structure essentially contains
+ * the stack trace as it would be if the currently executing command were to
+ * throw an error.
+ *
+ * For commands where it makes sense it refers to the associated CallFrame as
+ * well.
+ *
+ * The structures are chained in a single list, with the top of the stack
+ * anchored in the Interp structure.
+ *
+ * Instances can be allocated on the C stack, or the heap, the former making
+ * cleanup a bit simpler.
+ */
+
+typedef struct CmdFrame {
+    /*
+     * General data. Always available.
+     */
+
+    int type;			/* Values see below. */
+    int level;			/* Number of frames in stack, prevent O(n)
+				 * scan of list. */
+    int *line;		/* Lines the words of the command start on. */
+    int nline;
+    CallFrame *framePtr;	/* Procedure activation record, may be
+				 * NULL. */
+    struct CmdFrame *nextPtr;	/* Link to calling frame. */
+    /*
+     * Data needed for Eval vs TEBC
+     *
+     * EXECUTION CONTEXTS and usage of CmdFrame
+     *
+     * Field	  TEBC		  EvalEx
+     * =======	  ====		  ======
+     * level	  yes		  yes
+     * type	  BC/PREBC	  SRC/EVAL
+     * line0	  yes		  yes
+     * framePtr	  yes		  yes
+     * =======	  ====		  ======
+     *
+     * =======	  ====		  ========= union data
+     * line1	  -		  yes
+     * line3	  -		  yes
+     * path	  -		  yes
+     * -------	  ----		  ------
+     * codePtr	  yes		  -
+     * pc	  yes		  -
+     * =======	  ====		  ======
+     *
+     * =======	  ====		  ========= union cmd
+     * str.cmd	  yes		  yes
+     * str.len	  yes		  yes
+     * -------	  ----		  ------
+     */
+
+    union {
+	struct {
+	    Tcl_Obj *path;	/* Path of the sourced file the command is
+				 * in. */
+	} eval;
+	struct {
+	    const void *codePtr;/* Byte code currently executed... */
+	    const char *pc;	/* ... and instruction pointer. */
+	} tebc;
+    } data;
+    Tcl_Obj *cmdObj;
+    const char *cmd;		/* The executed command, if possible... */
+    int len;			/* ... and its length. */
+    const struct CFWordBC *litarg;
+				/* Link to set of literal arguments which have
+				 * ben pushed on the lineLABCPtr stack by
+				 * TclArgumentBCEnter(). These will be removed
+				 * by TclArgumentBCRelease. */
+} CmdFrame;
+
+typedef struct CFWord {
+    CmdFrame *framePtr;		/* CmdFrame to access. */
+    int word;			/* Index of the word in the command. */
+    int refCount;		/* Number of times the word is on the
+				 * stack. */
+} CFWord;
+
+typedef struct CFWordBC {
+    CmdFrame *framePtr;		/* CmdFrame to access. */
+    int pc;			/* Instruction pointer of a command in
+				 * ExtCmdLoc.loc[.] */
+    int word;			/* Index of word in
+				 * ExtCmdLoc.loc[cmd]->line[.] */
+    struct CFWordBC *prevPtr;	/* Previous entry in stack for same Tcl_Obj. */
+    struct CFWordBC *nextPtr;	/* Next entry for same command call. See
+				 * CmdFrame litarg field for the list start. */
+    Tcl_Obj *obj;		/* Back reference to hash table key */
+} CFWordBC;
+
+/*
+ * Structure to record the locations of invisible continuation lines in
+ * literal scripts, as character offset from the beginning of the script. Both
+ * compiler and direct evaluator use this information to adjust their line
+ * counters when tracking through the script, because when it is invoked the
+ * continuation line marker as a whole has been removed already, meaning that
+ * the \n which was part of it is gone as well, breaking regular line
+ * tracking.
+ *
+ * These structures are allocated and filled by both the function
+ * TclSubstTokens() in the file "tclParse.c" and its caller TclEvalEx() in the
+ * file "tclBasic.c", and stored in the thread-global hash table "lineCLPtr" in
+ * file "tclObj.c". They are used by the functions TclSetByteCodeFromAny() and
+ * TclCompileScript(), both found in the file "tclCompile.c". Their memory is
+ * released by the function TclFreeObj(), in the file "tclObj.c", and also by
+ * the function TclThreadFinalizeObjects(), in the same file.
+ */
+
+#define CLL_END		(-1)
+
+typedef struct ContLineLoc {
+    int num;			/* Number of entries in loc, not counting the
+				 * final -1 marker entry. */
+    int loc[TCLFLEXARRAY];/* Table of locations, as character offsets.
+				 * The table is allocated as part of the
+				 * structure, extending behind the nominal end
+				 * of the structure. An entry containing the
+				 * value -1 is put after the last location, as
+				 * end-marker/sentinel. */
+} ContLineLoc;
+
+/*
+ * The following macros define the allowed values for the type field of the
+ * CmdFrame structure above. Some of the values occur only in the extended
+ * location data referenced via the 'baseLocPtr'.
+ *
+ * TCL_LOCATION_EVAL	  : Frame is for a script evaluated by EvalEx.
+ * TCL_LOCATION_BC	  : Frame is for bytecode.
+ * TCL_LOCATION_PREBC	  : Frame is for precompiled bytecode.
+ * TCL_LOCATION_SOURCE	  : Frame is for a script evaluated by EvalEx, from a
+ *			    sourced file.
+ * TCL_LOCATION_PROC	  : Frame is for bytecode of a procedure.
+ *
+ * A TCL_LOCATION_BC type in a frame can be overridden by _SOURCE and _PROC
+ * types, per the context of the byte code in execution.
+ */
+
+#define TCL_LOCATION_EVAL	(0) /* Location in a dynamic eval script. */
+#define TCL_LOCATION_BC		(2) /* Location in byte code. */
+#define TCL_LOCATION_PREBC	(3) /* Location in precompiled byte code, no
+				     * location. */
+#define TCL_LOCATION_SOURCE	(4) /* Location in a file. */
+#define TCL_LOCATION_PROC	(5) /* Location in a dynamic proc. */
+#define TCL_LOCATION_LAST	(6) /* Number of values in the enum. */
+
+/*
+ * Structure passed to describe procedure-like "procedures" that are not
+ * procedures (e.g. a lambda) so that their details can be reported correctly
+ * by [info frame]. Contains a sub-structure for each extra field.
+ */
+
+typedef Tcl_Obj * (GetFrameInfoValueProc)(ClientData clientData);
+typedef struct {
+    const char *name;		/* Name of this field. */
+    GetFrameInfoValueProc *proc;	/* Function to generate a Tcl_Obj* from the
+				 * clientData, or just use the clientData
+				 * directly (after casting) if NULL. */
+    ClientData clientData;	/* Context for above function, or Tcl_Obj* if
+				 * proc field is NULL. */
+} ExtraFrameInfoField;
+typedef struct {
+    int length;			/* Length of array. */
+    ExtraFrameInfoField fields[2];
+				/* Really as long as necessary, but this is
+				 * long enough for nearly anything. */
+} ExtraFrameInfo;
+
+/*
+ *----------------------------------------------------------------
+ * Data structures and procedures related to TclHandles, which are a very
+ * lightweight method of preserving enough information to determine if an
+ * arbitrary malloc'd block has been deleted.
+ *----------------------------------------------------------------
+ */
+
+typedef void **TclHandle;
+
+/*
+ *----------------------------------------------------------------
+ * Experimental flag value passed to Tcl_GetRegExpFromObj. Intended for use
+ * only by Expect. It will probably go away in a later release.
+ *----------------------------------------------------------------
+ */
+
+#define TCL_REG_BOSONLY 002000	/* Prepend \A to pattern so it only matches at
+				 * the beginning of the string. */
+
+/*
+ * These are a thin layer over TclpThreadKeyDataGet and TclpThreadKeyDataSet
+ * when threads are used, or an emulation if there are no threads. These are
+ * really internal and Tcl clients should use Tcl_GetThreadData.
+ */
+
+MODULE_SCOPE void *	TclThreadDataKeyGet(Tcl_ThreadDataKey *keyPtr);
+MODULE_SCOPE void	TclThreadDataKeySet(Tcl_ThreadDataKey *keyPtr,
+			    void *data);
+
+/*
+ * This is a convenience macro used to initialize a thread local storage ptr.
+ */
+
+#define TCL_TSD_INIT(keyPtr) \
+  (ThreadSpecificData *)Tcl_GetThreadData((keyPtr), sizeof(ThreadSpecificData))
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to bytecode compilation and execution. These are
+ * used primarily in tclCompile.c, tclExecute.c, and tclBasic.c.
+ *----------------------------------------------------------------
+ */
+
+/*
+ * Forward declaration to prevent errors when the forward references to
+ * Tcl_Parse and CompileEnv are encountered in the procedure type CompileProc
+ * declared below.
+ */
+
+struct CompileEnv;
+
+/*
+ * The type of procedures called by the Tcl bytecode compiler to compile
+ * commands. Pointers to these procedures are kept in the Command structure
+ * describing each command. The integer value returned by a CompileProc must
+ * be one of the following:
+ *
+ * TCL_OK		Compilation completed normally.
+ * TCL_ERROR 		Compilation could not be completed. This can be just a
+ * 			judgment by the CompileProc that the command is too
+ * 			complex to compile effectively, or it can indicate
+ * 			that in the current state of the interp, the command
+ * 			would raise an error. The bytecode compiler will not
+ * 			do any error reporting at compiler time. Error
+ * 			reporting is deferred until the actual runtime,
+ * 			because by then changes in the interp state may allow
+ * 			the command to be successfully evaluated.
+ * TCL_OUT_LINE_COMPILE	A source-compatible alias for TCL_ERROR, kept for the
+ * 			sake of old code only.
+ */
+
+#define TCL_OUT_LINE_COMPILE	TCL_ERROR
+
+typedef int (CompileProc)(Tcl_Interp *interp, Tcl_Parse *parsePtr,
+	struct Command *cmdPtr, struct CompileEnv *compEnvPtr);
+
+/*
+ * The type of procedure called from the compilation hook point in
+ * SetByteCodeFromAny.
+ */
+
+typedef int (CompileHookProc)(Tcl_Interp *interp,
+	struct CompileEnv *compEnvPtr, ClientData clientData);
+
+/*
+ * The data structure for a (linked list of) execution stacks.
+ */
+
+typedef struct ExecStack {
+    struct ExecStack *prevPtr;
+    struct ExecStack *nextPtr;
+    Tcl_Obj **markerPtr;
+    Tcl_Obj **endPtr;
+    Tcl_Obj **tosPtr;
+    Tcl_Obj *stackWords[TCLFLEXARRAY];
+} ExecStack;
+
+/*
+ * The data structure defining the execution environment for ByteCode's.
+ * There is one ExecEnv structure per Tcl interpreter. It holds the evaluation
+ * stack that holds command operands and results. The stack grows towards
+ * increasing addresses. The member stackPtr points to the stackItems of the
+ * currently active execution stack.
+ */
+
+typedef struct CorContext {
+    struct CallFrame *framePtr;
+    struct CallFrame *varFramePtr;
+    struct CmdFrame *cmdFramePtr;  /* See Interp.cmdFramePtr */
+    Tcl_HashTable *lineLABCPtr;    /* See Interp.lineLABCPtr */
+} CorContext;
+
+typedef struct CoroutineData {
+    struct Command *cmdPtr;	/* The command handle for the coroutine. */
+    struct ExecEnv *eePtr;	/* The special execution environment (stacks,
+				 * etc.) for the coroutine. */
+    struct ExecEnv *callerEEPtr;/* The execution environment for the caller of
+				 * the coroutine, which might be the
+				 * interpreter global environment or another
+				 * coroutine. */
+    CorContext caller;
+    CorContext running;
+    Tcl_HashTable *lineLABCPtr;    /* See Interp.lineLABCPtr */
+    void *stackLevel;
+    int auxNumLevels;		/* While the coroutine is running the
+				 * numLevels of the create/resume command is
+				 * stored here; for suspended coroutines it
+				 * holds the nesting numLevels at yield. */
+    int nargs;                  /* Number of args required for resuming this
+				 * coroutine; -2 means "0 or 1" (default), -1
+				 * means "any" */
+} CoroutineData;
+
+typedef struct ExecEnv {
+    ExecStack *execStackPtr;	/* Points to the first item in the evaluation
+				 * stack on the heap. */
+    Tcl_Obj *constants[2];	/* Pointers to constant "0" and "1" objs. */
+    struct Tcl_Interp *interp;
+    struct NRE_callback *callbackPtr;
+				/* Top callback in NRE's stack. */
+    struct CoroutineData *corPtr;
+    int rewind;
+} ExecEnv;
+
+#define COR_IS_SUSPENDED(corPtr) \
+    ((corPtr)->stackLevel == NULL)
+
+/*
+ * The definitions for the LiteralTable and LiteralEntry structures. Each
+ * interpreter contains a LiteralTable. It is used to reduce the storage
+ * needed for all the Tcl objects that hold the literals of scripts compiled
+ * by the interpreter. A literal's object is shared by all the ByteCodes that
+ * refer to the literal. Each distinct literal has one LiteralEntry entry in
+ * the LiteralTable. A literal table is a specialized hash table that is
+ * indexed by the literal's string representation, which may contain null
+ * characters.
+ *
+ * Note that we reduce the space needed for literals by sharing literal
+ * objects both within a ByteCode (each ByteCode contains a local
+ * LiteralTable) and across all an interpreter's ByteCodes (with the
+ * interpreter's global LiteralTable).
+ */
+
+typedef struct LiteralEntry {
+    struct LiteralEntry *nextPtr;
+				/* Points to next entry in this hash bucket or
+				 * NULL if end of chain. */
+    Tcl_Obj *objPtr;		/* Points to Tcl object that holds the
+				 * literal's bytes and length. */
+    int refCount;		/* If in an interpreter's global literal
+				 * table, the number of ByteCode structures
+				 * that share the literal object; the literal
+				 * entry can be freed when refCount drops to
+				 * 0. If in a local literal table, -1. */
+    Namespace *nsPtr;		/* Namespace in which this literal is used. We
+				 * try to avoid sharing literal non-FQ command
+				 * names among different namespaces to reduce
+				 * shimmering. */
+} LiteralEntry;
+
+typedef struct LiteralTable {
+    LiteralEntry **buckets;	/* Pointer to bucket array. Each element
+				 * points to first entry in bucket's hash
+				 * chain, or NULL. */
+    LiteralEntry *staticBuckets[TCL_SMALL_HASH_TABLE];
+				/* Bucket array used for small tables to avoid
+				 * mallocs and frees. */
+    int numBuckets;		/* Total number of buckets allocated at
+				 * **buckets. */
+    int numEntries;		/* Total number of entries present in
+				 * table. */
+    int rebuildSize;		/* Enlarge table when numEntries gets to be
+				 * this large. */
+    int mask;			/* Mask value used in hashing function. */
+} LiteralTable;
+
+/*
+ * The following structure defines for each Tcl interpreter various
+ * statistics-related information about the bytecode compiler and
+ * interpreter's operation in that interpreter.
+ */
+
+#ifdef TCL_COMPILE_STATS
+typedef struct ByteCodeStats {
+    long numExecutions;		/* Number of ByteCodes executed. */
+    long numCompilations;	/* Number of ByteCodes created. */
+    long numByteCodesFreed;	/* Number of ByteCodes destroyed. */
+    long instructionCount[256];	/* Number of times each instruction was
+				 * executed. */
+
+    double totalSrcBytes;	/* Total source bytes ever compiled. */
+    double totalByteCodeBytes;	/* Total bytes for all ByteCodes. */
+    double currentSrcBytes;	/* Src bytes for all current ByteCodes. */
+    double currentByteCodeBytes;/* Code bytes in all current ByteCodes. */
+
+    long srcCount[32];		/* Source size distribution: # of srcs of
+				 * size [2**(n-1)..2**n), n in [0..32). */
+    long byteCodeCount[32];	/* ByteCode size distribution. */
+    long lifetimeCount[32];	/* ByteCode lifetime distribution (ms). */
+
+    double currentInstBytes;	/* Instruction bytes-current ByteCodes. */
+    double currentLitBytes;	/* Current literal bytes. */
+    double currentExceptBytes;	/* Current exception table bytes. */
+    double currentAuxBytes;	/* Current auxiliary information bytes. */
+    double currentCmdMapBytes;	/* Current src<->code map bytes. */
+
+    long numLiteralsCreated;	/* Total literal objects ever compiled. */
+    double totalLitStringBytes;	/* Total string bytes in all literals. */
+    double currentLitStringBytes;
+				/* String bytes in current literals. */
+    long literalCount[32];	/* Distribution of literal string sizes. */
+} ByteCodeStats;
+#endif /* TCL_COMPILE_STATS */
+
+/*
+ * Structure used in implementation of those core ensembles which are
+ * partially compiled. Used as an array of these, with a terminating field
+ * whose 'name' is NULL.
+ */
+
+typedef struct {
+    const char *name;		/* The name of the subcommand. */
+    Tcl_ObjCmdProc *proc;	/* The implementation of the subcommand. */
+    CompileProc *compileProc;	/* The compiler for the subcommand. */
+    Tcl_ObjCmdProc *nreProc;	/* NRE implementation of this command. */
+    ClientData clientData;	/* Any clientData to give the command. */
+    int unsafe;			/* Whether this command is to be hidden by
+				 * default in a safe interpreter. */
+} EnsembleImplMap;
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to commands.
+ *----------------------------------------------------------------
+ */
+
+/*
+ * An imported command is created in an namespace when it imports a "real"
+ * command from another namespace. An imported command has a Command structure
+ * that points (via its ClientData value) to the "real" Command structure in
+ * the source namespace's command table. The real command records all the
+ * imported commands that refer to it in a list of ImportRef structures so
+ * that they can be deleted when the real command is deleted.
+ */
+
+typedef struct ImportRef {
+    struct Command *importedCmdPtr;
+				/* Points to the imported command created in
+				 * an importing namespace; this command
+				 * redirects its invocations to the "real"
+				 * command. */
+    struct ImportRef *nextPtr;	/* Next element on the linked list of imported
+				 * commands that refer to the "real" command.
+				 * The real command deletes these imported
+				 * commands on this list when it is
+				 * deleted. */
+} ImportRef;
+
+/*
+ * Data structure used as the ClientData of imported commands: commands
+ * created in an namespace when it imports a "real" command from another
+ * namespace.
+ */
+
+typedef struct ImportedCmdData {
+    struct Command *realCmdPtr;	/* "Real" command that this imported command
+				 * refers to. */
+    struct Command *selfPtr;	/* Pointer to this imported command. Needed
+				 * only when deleting it in order to remove it
+				 * from the real command's linked list of
+				 * imported commands that refer to it. */
+} ImportedCmdData;
+
+/*
+ * A Command structure exists for each command in a namespace. The Tcl_Command
+ * opaque type actually refers to these structures.
+ */
+
+typedef struct Command {
+    Tcl_HashEntry *hPtr;	/* Pointer to the hash table entry that refers
+				 * to this command. The hash table is either a
+				 * namespace's command table or an
+				 * interpreter's hidden command table. This
+				 * pointer is used to get a command's name
+				 * from its Tcl_Command handle. NULL means
+				 * that the hash table entry has been removed
+				 * already (this can happen if deleteProc
+				 * causes the command to be deleted or
+				 * recreated). */
+    Namespace *nsPtr;		/* Points to the namespace containing this
+				 * command. */
+    int refCount;		/* 1 if in command hashtable plus 1 for each
+				 * reference from a CmdName Tcl object
+				 * representing a command's name in a ByteCode
+				 * instruction sequence. This structure can be
+				 * freed when refCount becomes zero. */
+    int cmdEpoch;		/* Incremented to invalidate any references
+				 * that point to this command when it is
+				 * renamed, deleted, hidden, or exposed. */
+    CompileProc *compileProc;	/* Procedure called to compile command. NULL
+				 * if no compile proc exists for command. */
+    Tcl_ObjCmdProc *objProc;	/* Object-based command procedure. */
+    ClientData objClientData;	/* Arbitrary value passed to object proc. */
+    Tcl_CmdProc *proc;		/* String-based command procedure. */
+    ClientData clientData;	/* Arbitrary value passed to string proc. */
+    Tcl_CmdDeleteProc *deleteProc;
+				/* Procedure invoked when deleting command to,
+				 * e.g., free all client data. */
+    ClientData deleteData;	/* Arbitrary value passed to deleteProc. */
+    int flags;			/* Miscellaneous bits of information about
+				 * command. See below for definitions. */
+    ImportRef *importRefPtr;	/* List of each imported Command created in
+				 * another namespace when this command is
+				 * imported. These imported commands redirect
+				 * invocations back to this command. The list
+				 * is used to remove all those imported
+				 * commands when deleting this "real"
+				 * command. */
+    CommandTrace *tracePtr;	/* First in list of all traces set for this
+				 * command. */
+    Tcl_ObjCmdProc *nreProc;	/* NRE implementation of this command. */
+} Command;
+
+/*
+ * Flag bits for commands.
+ *
+ * CMD_IS_DELETED -		If 1 the command is in the process of
+ *				being deleted (its deleteProc is currently
+ *				executing). Other attempts to delete the
+ *				command should be ignored.
+ * CMD_TRACE_ACTIVE -		If 1 the trace processing is currently
+ *				underway for a rename/delete change. See the
+ *				two flags below for which is currently being
+ *				processed.
+ * CMD_HAS_EXEC_TRACES -	If 1 means that this command has at least one
+ *				execution trace (as opposed to simple
+ *				delete/rename traces) in its tracePtr list.
+ * CMD_COMPILES_EXPANDED -	If 1 this command has a compiler that
+ *				can handle expansion (provided it is not the
+ *				first word).
+ * TCL_TRACE_RENAME -		A rename trace is in progress. Further
+ *				recursive renames will not be traced.
+ * TCL_TRACE_DELETE -		A delete trace is in progress. Further
+ *				recursive deletes will not be traced.
+ * (these last two flags are defined in tcl.h)
+ */
+
+#define CMD_IS_DELETED		    0x01
+#define CMD_TRACE_ACTIVE	    0x02
+#define CMD_HAS_EXEC_TRACES	    0x04
+#define CMD_COMPILES_EXPANDED	    0x08
+#define CMD_REDEF_IN_PROGRESS	    0x10
+#define CMD_VIA_RESOLVER	    0x20
+#define CMD_DEAD                    0x40
+
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to name resolution procedures.
+ *----------------------------------------------------------------
+ */
+
+/*
+ * The interpreter keeps a linked list of name resolution schemes. The scheme
+ * for a namespace is consulted first, followed by the list of schemes in an
+ * interpreter, followed by the default name resolution in Tcl. Schemes are
+ * added/removed from the interpreter's list by calling Tcl_AddInterpResolver
+ * and Tcl_RemoveInterpResolver.
+ */
+
+typedef struct ResolverScheme {
+    char *name;			/* Name identifying this scheme. */
+    Tcl_ResolveCmdProc *cmdResProc;
+				/* Procedure handling command name
+				 * resolution. */
+    Tcl_ResolveVarProc *varResProc;
+				/* Procedure handling variable name resolution
+				 * for variables that can only be handled at
+				 * runtime. */
+    Tcl_ResolveCompiledVarProc *compiledVarResProc;
+				/* Procedure handling variable name resolution
+				 * at compile time. */
+
+    struct ResolverScheme *nextPtr;
+				/* Pointer to next record in linked list. */
+} ResolverScheme;
+
+/*
+ * Forward declaration of the TIP#143 limit handler structure.
+ */
+
+typedef struct LimitHandler LimitHandler;
+
+/*
+ * TIP #268.
+ * Values for the selection mode, i.e the package require preferences.
+ */
+
+enum PkgPreferOptions {
+    PKG_PREFER_LATEST, PKG_PREFER_STABLE
+};
+
+/*
+ *----------------------------------------------------------------
+ * This structure shadows the first few fields of the memory cache for the
+ * allocator defined in tclThreadAlloc.c; it has to be kept in sync with the
+ * definition there.
+ * Some macros require knowledge of some fields in the struct in order to
+ * avoid hitting the TSD unnecessarily. In order to facilitate this, a pointer
+ * to the relevant fields is kept in the allocCache field in struct Interp.
+ *----------------------------------------------------------------
+ */
+
+typedef struct AllocCache {
+    struct Cache *nextPtr;	/* Linked list of cache entries. */
+    Tcl_ThreadId owner;		/* Which thread's cache is this? */
+    Tcl_Obj *firstObjPtr;	/* List of free objects for thread. */
+    int numObjects;		/* Number of objects for thread. */
+} AllocCache;
+
+/*
+ *----------------------------------------------------------------
+ * This structure defines an interpreter, which is a collection of commands
+ * plus other state information related to interpreting commands, such as
+ * variable storage. Primary responsibility for this data structure is in
+ * tclBasic.c, but almost every Tcl source file uses something in here.
+ *----------------------------------------------------------------
+ */
+
+typedef struct Interp {
+    /*
+     * Note: the first three fields must match exactly the fields in a
+     * Tcl_Interp struct (see tcl.h). If you change one, be sure to change the
+     * other.
+     *
+     * The interpreter's result is held in both the string and the
+     * objResultPtr fields. These fields hold, respectively, the result's
+     * string or object value. The interpreter's result is always in the
+     * result field if that is non-empty, otherwise it is in objResultPtr.
+     * The two fields are kept consistent unless some C code sets
+     * interp->result directly. Programs should not access result and
+     * objResultPtr directly; instead, they should always get and set the
+     * result using procedures such as Tcl_SetObjResult, Tcl_GetObjResult, and
+     * Tcl_GetStringResult. See the SetResult man page for details.
+     */
+
+    char *result;		/* If the last command returned a string
+				 * result, this points to it. Should not be
+				 * accessed directly; see comment above. */
+    Tcl_FreeProc *freeProc;	/* Zero means a string result is statically
+				 * allocated. TCL_DYNAMIC means string result
+				 * was allocated with ckalloc and should be
+				 * freed with ckfree. Other values give
+				 * address of procedure to invoke to free the
+				 * string result. Tcl_Eval must free it before
+				 * executing next command. */
+    int errorLine;		/* When TCL_ERROR is returned, this gives the
+				 * line number in the command where the error
+				 * occurred (1 means first line). */
+    const struct TclStubs *stubTable;
+				/* Pointer to the exported Tcl stub table. On
+				 * previous versions of Tcl this is a pointer
+				 * to the objResultPtr or a pointer to a
+				 * buckets array in a hash table. We therefore
+				 * have to do some careful checking before we
+				 * can use this. */
+
+    TclHandle handle;		/* Handle used to keep track of when this
+				 * interp is deleted. */
+
+    Namespace *globalNsPtr;	/* The interpreter's global namespace. */
+    Tcl_HashTable *hiddenCmdTablePtr;
+				/* Hash table used by tclBasic.c to keep track
+				 * of hidden commands on a per-interp
+				 * basis. */
+    ClientData interpInfo;	/* Information used by tclInterp.c to keep
+				 * track of parent/child interps on a
+				 * per-interp basis. */
+    union {
+	void (*optimizer)(void *envPtr);
+	Tcl_HashTable unused2;	/* No longer used (was mathFuncTable). The
+				 * unused space in interp was repurposed for
+				 * pluggable bytecode optimizers. The core
+				 * contains one optimizer, which can be
+				 * selectively overridden by extensions. */
+    } extra;
+    /*
+     * Information related to procedures and variables. See tclProc.c and
+     * tclVar.c for usage.
+     */
+
+    int numLevels;		/* Keeps track of how many nested calls to
+				 * Tcl_Eval are in progress for this
+				 * interpreter. It's used to delay deletion of
+				 * the table until all Tcl_Eval invocations
+				 * are completed. */
+    int maxNestingDepth;	/* If numLevels exceeds this value then Tcl
+				 * assumes that infinite recursion has
+				 * occurred and it generates an error. */
+    CallFrame *framePtr;	/* Points to top-most in stack of all nested
+				 * procedure invocations. */
+    CallFrame *varFramePtr;	/* Points to the call frame whose variables
+				 * are currently in use (same as framePtr
+				 * unless an "uplevel" command is
+				 * executing). */
+    ActiveVarTrace *activeVarTracePtr;
+				/* First in list of active traces for interp,
+				 * or NULL if no active traces. */
+    int returnCode;		/* [return -code] parameter. */
+    CallFrame *rootFramePtr;	/* Global frame pointer for this
+				 * interpreter. */
+    Namespace *lookupNsPtr;	/* Namespace to use ONLY on the next
+				 * TCL_EVAL_INVOKE call to Tcl_EvalObjv. */
+
+    /*
+     * Information used by Tcl_AppendResult to keep track of partial results.
+     * See Tcl_AppendResult code for details.
+     */
+
+    char *appendResult;		/* Storage space for results generated by
+				 * Tcl_AppendResult. Ckalloc-ed. NULL means
+				 * not yet allocated. */
+    int appendAvl;		/* Total amount of space available at
+				 * partialResult. */
+    int appendUsed;		/* Number of non-null bytes currently stored
+				 * at partialResult. */
+
+    /*
+     * Information about packages. Used only in tclPkg.c.
+     */
+
+    Tcl_HashTable packageTable;	/* Describes all of the packages loaded in or
+				 * available to this interpreter. Keys are
+				 * package names, values are (Package *)
+				 * pointers. */
+    char *packageUnknown;	/* Command to invoke during "package require"
+				 * commands for packages that aren't described
+				 * in packageTable. Ckalloc'ed, may be
+				 * NULL. */
+    /*
+     * Miscellaneous information:
+     */
+
+    int cmdCount;		/* Total number of times a command procedure
+				 * has been called for this interpreter. */
+    int evalFlags;		/* Flags to control next call to Tcl_Eval.
+				 * Normally zero, but may be set before
+				 * calling Tcl_Eval. See below for valid
+				 * values. */
+    int unused1;		/* No longer used (was termOffset) */
+    LiteralTable literalTable;	/* Contains LiteralEntry's describing all Tcl
+				 * objects holding literals of scripts
+				 * compiled by the interpreter. Indexed by the
+				 * string representations of literals. Used to
+				 * avoid creating duplicate objects. */
+    int compileEpoch;		/* Holds the current "compilation epoch" for
+				 * this interpreter. This is incremented to
+				 * invalidate existing ByteCodes when, e.g., a
+				 * command with a compile procedure is
+				 * redefined. */
+    Proc *compiledProcPtr;	/* If a procedure is being compiled, a pointer
+				 * to its Proc structure; otherwise, this is
+				 * NULL. Set by ObjInterpProc in tclProc.c and
+				 * used by tclCompile.c to process local
+				 * variables appropriately. */
+    ResolverScheme *resolverPtr;
+				/* Linked list of name resolution schemes
+				 * added to this interpreter. Schemes are
+				 * added and removed by calling
+				 * Tcl_AddInterpResolvers and
+				 * Tcl_RemoveInterpResolver respectively. */
+    Tcl_Obj *scriptFile;	/* NULL means there is no nested source
+				 * command active; otherwise this points to
+				 * pathPtr of the file being sourced. */
+    int flags;			/* Various flag bits. See below. */
+    long randSeed;		/* Seed used for rand() function. */
+    Trace *tracePtr;		/* List of traces for this interpreter. */
+    Tcl_HashTable *assocData;	/* Hash table for associating data with this
+				 * interpreter. Cleaned up when this
+				 * interpreter is deleted. */
+    struct ExecEnv *execEnvPtr;	/* Execution environment for Tcl bytecode
+				 * execution. Contains a pointer to the Tcl
+				 * evaluation stack. */
+    Tcl_Obj *emptyObjPtr;	/* Points to an object holding an empty
+				 * string. Returned by Tcl_ObjSetVar2 when
+				 * variable traces change a variable in a
+				 * gross way. */
+    char resultSpace[TCL_RESULT_SIZE+1];
+				/* Static space holding small results. */
+    Tcl_Obj *objResultPtr;	/* If the last command returned an object
+				 * result, this points to it. Should not be
+				 * accessed directly; see comment above. */
+    Tcl_ThreadId threadId;	/* ID of thread that owns the interpreter. */
+
+    ActiveCommandTrace *activeCmdTracePtr;
+				/* First in list of active command traces for
+				 * interp, or NULL if no active traces. */
+    ActiveInterpTrace *activeInterpTracePtr;
+				/* First in list of active traces for interp,
+				 * or NULL if no active traces. */
+
+    int tracesForbiddingInline;	/* Count of traces (in the list headed by
+				 * tracePtr) that forbid inline bytecode
+				 * compilation. */
+
+    /*
+     * Fields used to manage extensible return options (TIP 90).
+     */
+
+    Tcl_Obj *returnOpts;	/* A dictionary holding the options to the
+				 * last [return] command. */
+
+    Tcl_Obj *errorInfo;		/* errorInfo value (now as a Tcl_Obj). */
+    Tcl_Obj *eiVar;		/* cached ref to ::errorInfo variable. */
+    Tcl_Obj *errorCode;		/* errorCode value (now as a Tcl_Obj). */
+    Tcl_Obj *ecVar;		/* cached ref to ::errorInfo variable. */
+    int returnLevel;		/* [return -level] parameter. */
+
+    /*
+     * Resource limiting framework support (TIP#143).
+     */
+
+    struct {
+	int active;		/* Flag values defining which limits have been
+				 * set. */
+	int granularityTicker;	/* Counter used to determine how often to
+				 * check the limits. */
+	int exceeded;		/* Which limits have been exceeded, described
+				 * as flag values the same as the 'active'
+				 * field. */
+
+	int cmdCount;		/* Limit for how many commands to execute in
+				 * the interpreter. */
+	LimitHandler *cmdHandlers;
+				/* Handlers to execute when the limit is
+				 * reached. */
+	int cmdGranularity;	/* Mod factor used to determine how often to
+				 * evaluate the limit check. */
+
+	Tcl_Time time;		/* Time limit for execution within the
+				 * interpreter. */
+	LimitHandler *timeHandlers;
+				/* Handlers to execute when the limit is
+				 * reached. */
+	int timeGranularity;	/* Mod factor used to determine how often to
+				 * evaluate the limit check. */
+	Tcl_TimerToken timeEvent;
+				/* Handle for a timer callback that will occur
+				 * when the time-limit is exceeded. */
+
+	Tcl_HashTable callbacks;/* Mapping from (interp,type) pair to data
+				 * used to install a limit handler callback to
+				 * run in _this_ interp when the limit is
+				 * exceeded. */
+    } limit;
+
+    /*
+     * Information for improved default error generation from ensembles
+     * (TIP#112).
+     */
+
+    struct {
+	Tcl_Obj *const *sourceObjs;
+				/* What arguments were actually input into the
+				 * *root* ensemble command? (Nested ensembles
+				 * don't rewrite this.) NULL if we're not
+				 * processing an ensemble. */
+	int numRemovedObjs;	/* How many arguments have been stripped off
+				 * because of ensemble processing. */
+	int numInsertedObjs;	/* How many of the current arguments were
+				 * inserted by an ensemble. */
+    } ensembleRewrite;
+
+    /*
+     * TIP #219: Global info for the I/O system.
+     */
+
+    Tcl_Obj *chanMsg;		/* Error message set by channel drivers, for
+				 * the propagation of arbitrary Tcl errors.
+				 * This information, if present (chanMsg not
+				 * NULL), takes precedence over a POSIX error
+				 * code returned by a channel operation. */
+
+    /*
+     * Source code origin information (TIP #280).
+     */
+
+    CmdFrame *cmdFramePtr;	/* Points to the command frame containing the
+				 * location information for the current
+				 * command. */
+    const CmdFrame *invokeCmdFramePtr;
+				/* Points to the command frame which is the
+				 * invoking context of the bytecode compiler.
+				 * NULL when the byte code compiler is not
+				 * active. */
+    int invokeWord;		/* Index of the word in the command which
+				 * is getting compiled. */
+    Tcl_HashTable *linePBodyPtr;/* This table remembers for each statically
+				 * defined procedure the location information
+				 * for its body. It is keyed by the address of
+				 * the Proc structure for a procedure. The
+				 * values are "struct CmdFrame*". */
+    Tcl_HashTable *lineBCPtr;	/* This table remembers for each ByteCode
+				 * object the location information for its
+				 * body. It is keyed by the address of the
+				 * Proc structure for a procedure. The values
+				 * are "struct ExtCmdLoc*". (See
+				 * tclCompile.h) */
+    Tcl_HashTable *lineLABCPtr;
+    Tcl_HashTable *lineLAPtr;	/* This table remembers for each argument of a
+				 * command on the execution stack the index of
+				 * the argument in the command, and the
+				 * location data of the command. It is keyed
+				 * by the address of the Tcl_Obj containing
+				 * the argument. The values are "struct
+				 * CFWord*" (See tclBasic.c). This allows
+				 * commands like uplevel, eval, etc. to find
+				 * location information for their arguments,
+				 * if they are a proper literal argument to an
+				 * invoking command. Alt view: An index to the
+				 * CmdFrame stack keyed by command argument
+				 * holders. */
+    ContLineLoc *scriptCLLocPtr;/* This table points to the location data for
+				 * invisible continuation lines in the script,
+				 * if any. This pointer is set by the function
+				 * TclEvalObjEx() in file "tclBasic.c", and
+				 * used by function ...() in the same file.
+				 * It does for the eval/direct path of script
+				 * execution what CompileEnv.clLoc does for
+				 * the bytecode compiler.
+				 */
+    /*
+     * TIP #268. The currently active selection mode, i.e. the package require
+     * preferences.
+     */
+
+    int packagePrefer;		/* Current package selection mode. */
+
+    /*
+     * Hashtables for variable traces and searches.
+     */
+
+    Tcl_HashTable varTraces;	/* Hashtable holding the start of a variable's
+				 * active trace list; varPtr is the key. */
+    Tcl_HashTable varSearches;	/* Hashtable holding the start of a variable's
+				 * active searches list; varPtr is the key. */
+    /*
+     * The thread-specific data ekeko: cache pointers or values that
+     *  (a) do not change during the thread's lifetime
+     *  (b) require access to TSD to determine at runtime
+     *  (c) are accessed very often (e.g., at each command call)
+     *
+     * Note that these are the same for all interps in the same thread. They
+     * just have to be initialised for the thread's parent interp, children
+     * inherit the value.
+     *
+     * They are used by the macros defined below.
+     */
+
+    AllocCache *allocCache;
+    void *pendingObjDataPtr;	/* Pointer to the Cache and PendingObjData
+				 * structs for this interp's thread; see
+				 * tclObj.c and tclThreadAlloc.c */
+    int *asyncReadyPtr;		/* Pointer to the asyncReady indicator for
+				 * this interp's thread; see tclAsync.c */
+    /*
+     * The pointer to the object system root ekeko. c.f. TIP #257.
+     */
+    void *objectFoundation;	/* Pointer to the Foundation structure of the
+				 * object system, which contains things like
+				 * references to key namespaces. See
+				 * tclOOInt.h and tclOO.c for real definition
+				 * and setup. */
+
+    struct NRE_callback *deferredCallbacks;
+				/* Callbacks that are set previous to a call
+				 * to some Eval function but that actually
+				 * belong to the command that is about to be
+				 * called - i.e., they should be run *before*
+				 * any tailcall is invoked. */
+
+    /*
+     * TIP #285, Script cancellation support.
+     */
+
+    Tcl_AsyncHandler asyncCancel;
+				/* Async handler token for Tcl_CancelEval. */
+    Tcl_Obj *asyncCancelMsg;	/* Error message set by async cancel handler
+				 * for the propagation of arbitrary Tcl
+				 * errors. This information, if present
+				 * (asyncCancelMsg not NULL), takes precedence
+				 * over the default error messages returned by
+				 * a script cancellation operation. */
+
+	/*
+	 * TIP #348 IMPLEMENTATION  -  Substituted error stack
+	 */
+    Tcl_Obj *errorStack;	/* [info errorstack] value (as a Tcl_Obj). */
+    Tcl_Obj *upLiteral;		/* "UP" literal for [info errorstack] */
+    Tcl_Obj *callLiteral;	/* "CALL" literal for [info errorstack] */
+    Tcl_Obj *innerLiteral;	/* "INNER" literal for [info errorstack] */
+    Tcl_Obj *innerContext;	/* cached list for fast reallocation */
+    int resetErrorStack;        /* controls cleaning up of ::errorStack */
+
+#ifdef TCL_COMPILE_STATS
+    /*
+     * Statistical information about the bytecode compiler and interpreter's
+     * operation. This should be the last field of Interp.
+     */
+
+    ByteCodeStats stats;	/* Holds compilation and execution statistics
+				 * for this interpreter. */
+#endif /* TCL_COMPILE_STATS */
+} Interp;
+
+/*
+ * Macros that use the TSD-ekeko.
+ */
+
+#define TclAsyncReady(iPtr) \
+    *((iPtr)->asyncReadyPtr)
+
+/*
+ * Macros for script cancellation support (TIP #285).
+ */
+
+#define TclCanceled(iPtr) \
+    (((iPtr)->flags & CANCELED) || ((iPtr)->flags & TCL_CANCEL_UNWIND))
+
+#define TclSetCancelFlags(iPtr, cancelFlags)   \
+    (iPtr)->flags |= CANCELED;                 \
+    if ((cancelFlags) & TCL_CANCEL_UNWIND) {   \
+        (iPtr)->flags |= TCL_CANCEL_UNWIND;    \
+    }
+
+#define TclUnsetCancelFlags(iPtr) \
+    (iPtr)->flags &= (~(CANCELED | TCL_CANCEL_UNWIND))
+
+/*
+ * Macros for splicing into and out of doubly linked lists. They assume
+ * existence of struct items 'prevPtr' and 'nextPtr'.
+ *
+ * a = element to add or remove.
+ * b = list head.
+ *
+ * TclSpliceIn adds to the head of the list.
+ */
+
+#define TclSpliceIn(a,b)			\
+    (a)->nextPtr = (b);				\
+    if ((b) != NULL) {				\
+	(b)->prevPtr = (a);			\
+    }						\
+    (a)->prevPtr = NULL, (b) = (a);
+
+#define TclSpliceOut(a,b)			\
+    if ((a)->prevPtr != NULL) {			\
+	(a)->prevPtr->nextPtr = (a)->nextPtr;	\
+    } else {					\
+	(b) = (a)->nextPtr;			\
+    }						\
+    if ((a)->nextPtr != NULL) {			\
+	(a)->nextPtr->prevPtr = (a)->prevPtr;	\
+    }
+
+/*
+ * EvalFlag bits for Interp structures:
+ *
+ * TCL_ALLOW_EXCEPTIONS	1 means it's OK for the script to terminate with a
+ *			code other than TCL_OK or TCL_ERROR; 0 means codes
+ *			other than these should be turned into errors.
+ */
+
+#define TCL_ALLOW_EXCEPTIONS		0x04
+#define TCL_EVAL_FILE			0x02
+#define TCL_EVAL_SOURCE_IN_FRAME	0x10
+#define TCL_EVAL_NORESOLVE		0x20
+#define TCL_EVAL_DISCARD_RESULT		0x40
+
+/*
+ * Flag bits for Interp structures:
+ *
+ * DELETED:		Non-zero means the interpreter has been deleted:
+ *			don't process any more commands for it, and destroy
+ *			the structure as soon as all nested invocations of
+ *			Tcl_Eval are done.
+ * ERR_ALREADY_LOGGED:	Non-zero means information has already been logged in
+ *			iPtr->errorInfo for the current Tcl_Eval instance, so
+ *			Tcl_Eval needn't log it (used to implement the "error
+ *			message log" command).
+ * DONT_COMPILE_CMDS_INLINE: Non-zero means that the bytecode compiler should
+ *			not compile any commands into an inline sequence of
+ *			instructions. This is set 1, for example, when command
+ *			traces are requested.
+ * RAND_SEED_INITIALIZED: Non-zero means that the randSeed value of the interp
+ *			has not be initialized. This is set 1 when we first
+ *			use the rand() or srand() functions.
+ * SAFE_INTERP:		Non zero means that the current interp is a safe
+ *			interp (i.e. it has only the safe commands installed,
+ *			less privilege than a regular interp).
+ * INTERP_DEBUG_FRAME:	Used for switching on various extra interpreter
+ *			debug/info mechanisms (e.g. info frame eval/uplevel
+ *			tracing) which are performance intensive.
+ * INTERP_TRACE_IN_PROGRESS: Non-zero means that an interp trace is currently
+ *			active; so no further trace callbacks should be
+ *			invoked.
+ * INTERP_ALTERNATE_WRONG_ARGS: Used for listing second and subsequent forms
+ *			of the wrong-num-args string in Tcl_WrongNumArgs.
+ *			Makes it append instead of replacing and uses
+ *			different intermediate text.
+ * CANCELED:		Non-zero means that the script in progress should be
+ *			canceled as soon as possible. This can be checked by
+ *			extensions (and the core itself) by calling
+ *			Tcl_Canceled and checking if TCL_ERROR is returned.
+ *			This is a one-shot flag that is reset immediately upon
+ *			being detected; however, if the TCL_CANCEL_UNWIND flag
+ *			is set Tcl_Canceled will continue to report that the
+ *			script in progress has been canceled thereby allowing
+ *			the evaluation stack for the interp to be fully
+ *			unwound.
+ *
+ * WARNING: For the sake of some extensions that have made use of former
+ * internal values, do not re-use the flag values 2 (formerly ERR_IN_PROGRESS)
+ * or 8 (formerly ERROR_CODE_SET).
+ */
+
+#define DELETED				     1
+#define ERR_ALREADY_LOGGED		     4
+#define INTERP_DEBUG_FRAME		  0x10
+#define DONT_COMPILE_CMDS_INLINE	  0x20
+#define RAND_SEED_INITIALIZED		  0x40
+#define SAFE_INTERP			  0x80
+#define INTERP_TRACE_IN_PROGRESS	 0x200
+#define INTERP_ALTERNATE_WRONG_ARGS	 0x400
+#define ERR_LEGACY_COPY			 0x800
+#define CANCELED			0x1000
+
+/*
+ * Maximum number of levels of nesting permitted in Tcl commands (used to
+ * catch infinite recursion).
+ */
+
+#define MAX_NESTING_DEPTH	1000
+
+/*
+ * The macro below is used to modify a "char" value (e.g. by casting it to an
+ * unsigned character) so that it can be used safely with macros such as
+ * isspace.
+ */
+
+#define UCHAR(c) ((unsigned char) (c))
+
+/*
+ * This macro is used to properly align the memory allocated by Tcl, giving
+ * the same alignment as the native malloc.
+ */
+
+#if defined(__APPLE__)
+#define TCL_ALLOCALIGN	16
+#else
+#define TCL_ALLOCALIGN	(2*sizeof(void *))
+#endif
+
+/*
+ * This macro is used to determine the offset needed to safely allocate any
+ * data structure in memory. Given a starting offset or size, it "rounds up"
+ * or "aligns" the offset to the next 8-byte boundary so that any data
+ * structure can be placed at the resulting offset without fear of an
+ * alignment error.
+ *
+ * WARNING!! DO NOT USE THIS MACRO TO ALIGN POINTERS: it will produce the
+ * wrong result on platforms that allocate addresses that are divisible by 4
+ * or 2. Only use it for offsets or sizes.
+ *
+ * This macro is only used by tclCompile.c in the core (Bug 926445). It
+ * however not be made file static, as extensions that touch bytecodes
+ * (notably tbcload) require it.
+ */
+
+#define TCL_ALIGN(x) (((int)(x) + 7) & ~7)
+
+/*
+ * The following enum values are used to specify the runtime platform setting
+ * of the tclPlatform variable.
+ */
+
+typedef enum {
+    TCL_PLATFORM_UNIX = 0,	/* Any Unix-like OS. */
+    TCL_PLATFORM_WINDOWS = 2	/* Any Microsoft Windows OS. */
+} TclPlatformType;
+
+/*
+ * The following enum values are used to indicate the translation of a Tcl
+ * channel. Declared here so that each platform can define
+ * TCL_PLATFORM_TRANSLATION to the native translation on that platform.
+ */
+
+typedef enum TclEolTranslation {
+    TCL_TRANSLATE_AUTO,		/* Eol == \r, \n and \r\n. */
+    TCL_TRANSLATE_CR,		/* Eol == \r. */
+    TCL_TRANSLATE_LF,		/* Eol == \n. */
+    TCL_TRANSLATE_CRLF		/* Eol == \r\n. */
+} TclEolTranslation;
+
+/*
+ * Flags for TclInvoke:
+ *
+ * TCL_INVOKE_HIDDEN		Invoke a hidden command; if not set, invokes
+ *				an exposed command.
+ * TCL_INVOKE_NO_UNKNOWN	If set, "unknown" is not invoked if the
+ *				command to be invoked is not found. Only has
+ *				an effect if invoking an exposed command,
+ *				i.e. if TCL_INVOKE_HIDDEN is not also set.
+ * TCL_INVOKE_NO_TRACEBACK	Does not record traceback information if the
+ *				invoked command returns an error. Used if the
+ *				caller plans on recording its own traceback
+ *				information.
+ */
+
+#define	TCL_INVOKE_HIDDEN	(1<<0)
+#define TCL_INVOKE_NO_UNKNOWN	(1<<1)
+#define TCL_INVOKE_NO_TRACEBACK	(1<<2)
+
+/*
+ * The structure used as the internal representation of Tcl list objects. This
+ * struct is grown (reallocated and copied) as necessary to hold all the
+ * list's element pointers. The struct might contain more slots than currently
+ * used to hold all element pointers. This is done to make append operations
+ * faster.
+ */
+
+typedef struct List {
+    int refCount;
+    int maxElemCount;		/* Total number of element array slots. */
+    int elemCount;		/* Current number of list elements. */
+    int canonicalFlag;		/* Set if the string representation was
+				 * derived from the list representation. May
+				 * be ignored if there is no string rep at
+				 * all.*/
+    Tcl_Obj *elements;		/* First list element; the struct is grown to
+				 * accommodate all elements. */
+} List;
+
+#define LIST_MAX \
+	(1 + (int)(((size_t)UINT_MAX - sizeof(List))/sizeof(Tcl_Obj *)))
+#define LIST_SIZE(numElems) \
+	(unsigned)(sizeof(List) + (((numElems) - 1) * sizeof(Tcl_Obj *)))
+
+/*
+ * Macro used to get the elements of a list object.
+ */
+
+#define ListRepPtr(listPtr) \
+    ((List *) (listPtr)->internalRep.twoPtrValue.ptr1)
+
+/* Not used any more */
+#define ListSetIntRep(objPtr, listRepPtr) \
+    (objPtr)->internalRep.twoPtrValue.ptr1 = (void *)(listRepPtr), \
+    (objPtr)->internalRep.twoPtrValue.ptr2 = NULL, \
+    (listRepPtr)->refCount++, \
+    (objPtr)->typePtr = &tclListType
+
+#define ListObjGetElements(listPtr, objc, objv) \
+    ((objv) = &(ListRepPtr(listPtr)->elements), \
+     (objc) = ListRepPtr(listPtr)->elemCount)
+
+#define ListObjLength(listPtr, len) \
+    ((len) = ListRepPtr(listPtr)->elemCount)
+
+#define ListObjIsCanonical(listPtr) \
+    (((listPtr)->bytes == NULL) || ListRepPtr(listPtr)->canonicalFlag)
+
+#define TclListObjGetElements(interp, listPtr, objcPtr, objvPtr) \
+    (((listPtr)->typePtr == &tclListType) \
+	    ? ((ListObjGetElements((listPtr), *(objcPtr), *(objvPtr))), TCL_OK)\
+	    : Tcl_ListObjGetElements((interp), (listPtr), (objcPtr), (objvPtr)))
+
+#define TclListObjLength(interp, listPtr, lenPtr) \
+    (((listPtr)->typePtr == &tclListType) \
+	    ? ((ListObjLength((listPtr), *(lenPtr))), TCL_OK)\
+	    : Tcl_ListObjLength((interp), (listPtr), (lenPtr)))
+
+#define TclListObjIsCanonical(listPtr) \
+    (((listPtr)->typePtr == &tclListType) ? ListObjIsCanonical((listPtr)) : 0)
+
+/*
+ * Modes for collecting (or not) in the implementations of TclNRForeachCmd,
+ * TclNRLmapCmd and their compilations.
+ */
+
+#define TCL_EACH_KEEP_NONE  0	/* Discard iteration result like [foreach] */
+#define TCL_EACH_COLLECT    1	/* Collect iteration result like [lmap] */
+
+/*
+ * Macros providing a faster path to integers: Tcl_GetLongFromObj,
+ * Tcl_GetIntFromObj and TclGetIntForIndex.
+ *
+ * WARNING: these macros eval their args more than once.
+ */
+
+#define TclGetLongFromObj(interp, objPtr, longPtr) \
+    (((objPtr)->typePtr == &tclIntType)	\
+	    ? ((*(longPtr) = (objPtr)->internalRep.longValue), TCL_OK) \
+	    : Tcl_GetLongFromObj((interp), (objPtr), (longPtr)))
+
+#if (LONG_MAX == INT_MAX)
+#define TclGetIntFromObj(interp, objPtr, intPtr) \
+    (((objPtr)->typePtr == &tclIntType)	\
+	    ? ((*(intPtr) = (objPtr)->internalRep.longValue), TCL_OK) \
+	    : Tcl_GetIntFromObj((interp), (objPtr), (intPtr)))
+#define TclGetIntForIndexM(interp, objPtr, endValue, idxPtr) \
+    (((objPtr)->typePtr == &tclIntType)	\
+	    ? ((*(idxPtr) = (objPtr)->internalRep.longValue), TCL_OK) \
+	    : TclGetIntForIndex((interp), (objPtr), (endValue), (idxPtr)))
+#else
+#define TclGetIntFromObj(interp, objPtr, intPtr) \
+    (((objPtr)->typePtr == &tclIntType \
+	    && (objPtr)->internalRep.longValue >= -(Tcl_WideInt)(UINT_MAX) \
+	    && (objPtr)->internalRep.longValue <= (Tcl_WideInt)(UINT_MAX))	\
+	    ? ((*(intPtr) = (objPtr)->internalRep.longValue), TCL_OK) \
+	    : Tcl_GetIntFromObj((interp), (objPtr), (intPtr)))
+#define TclGetIntForIndexM(interp, objPtr, endValue, idxPtr) \
+    (((objPtr)->typePtr == &tclIntType \
+	    && (objPtr)->internalRep.longValue >= INT_MIN \
+	    && (objPtr)->internalRep.longValue <= INT_MAX)	\
+	    ? ((*(idxPtr) = (objPtr)->internalRep.longValue), TCL_OK) \
+	    : TclGetIntForIndex((interp), (objPtr), (endValue), (idxPtr)))
+#endif
+
+/*
+ * Macro used to save a function call for common uses of
+ * Tcl_GetWideIntFromObj(). The ANSI C "prototype" is:
+ *
+ * MODULE_SCOPE int TclGetWideIntFromObj(Tcl_Interp *interp, Tcl_Obj *objPtr,
+ *			Tcl_WideInt *wideIntPtr);
+ */
+
+#ifdef TCL_WIDE_INT_IS_LONG
+#define TclGetWideIntFromObj(interp, objPtr, wideIntPtr) \
+    (((objPtr)->typePtr == &tclIntType)					\
+	? (*(wideIntPtr) = (Tcl_WideInt)				\
+		((objPtr)->internalRep.longValue), TCL_OK) :		\
+	Tcl_GetWideIntFromObj((interp), (objPtr), (wideIntPtr)))
+#else /* !TCL_WIDE_INT_IS_LONG */
+#define TclGetWideIntFromObj(interp, objPtr, wideIntPtr)		\
+    (((objPtr)->typePtr == &tclWideIntType)				\
+	? (*(wideIntPtr) = (objPtr)->internalRep.wideValue, TCL_OK) :	\
+    ((objPtr)->typePtr == &tclIntType)					\
+	? (*(wideIntPtr) = (Tcl_WideInt)				\
+		((objPtr)->internalRep.longValue), TCL_OK) :		\
+	Tcl_GetWideIntFromObj((interp), (objPtr), (wideIntPtr)))
+#endif /* TCL_WIDE_INT_IS_LONG */
+
+/*
+ * Flag values for TclTraceDictPath().
+ *
+ * DICT_PATH_READ indicates that all entries on the path must exist but no
+ * updates will be needed.
+ *
+ * DICT_PATH_UPDATE indicates that we are going to be doing an update at the
+ * tip of the path, so duplication of shared objects should be done along the
+ * way.
+ *
+ * DICT_PATH_EXISTS indicates that we are performing an existence test and a
+ * lookup failure should therefore not be an error. If (and only if) this flag
+ * is set, TclTraceDictPath() will return the special value
+ * DICT_PATH_NON_EXISTENT if the path is not traceable.
+ *
+ * DICT_PATH_CREATE (which also requires the DICT_PATH_UPDATE bit to be set)
+ * indicates that we are to create non-existent dictionaries on the path.
+ */
+
+#define DICT_PATH_READ		0
+#define DICT_PATH_UPDATE	1
+#define DICT_PATH_EXISTS	2
+#define DICT_PATH_CREATE	5
+
+#define DICT_PATH_NON_EXISTENT	((Tcl_Obj *) (void *) 1)
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to the filesystem internals
+ *----------------------------------------------------------------
+ */
+
+/*
+ * The version_2 filesystem is private to Tcl. As and when these changes have
+ * been thoroughly tested and investigated a new public filesystem interface
+ * will be released. The aim is more versatile virtual filesystem interfaces,
+ * more efficiency in 'path' manipulation and usage, and cleaner filesystem
+ * code internally.
+ */
+
+#define TCL_FILESYSTEM_VERSION_2	((Tcl_FSVersion) 0x2)
+typedef ClientData (TclFSGetCwdProc2)(ClientData clientData);
+typedef int (Tcl_FSLoadFileProc2) (Tcl_Interp *interp, Tcl_Obj *pathPtr,
+	Tcl_LoadHandle *handlePtr, Tcl_FSUnloadFileProc **unloadProcPtr, int flags);
+
+/*
+ * The following types are used for getting and storing platform-specific file
+ * attributes in tclFCmd.c and the various platform-versions of that file.
+ * This is done to have as much common code as possible in the file attributes
+ * code. For more information about the callbacks, see TclFileAttrsCmd in
+ * tclFCmd.c.
+ */
+
+typedef int (TclGetFileAttrProc)(Tcl_Interp *interp, int objIndex,
+	Tcl_Obj *fileName, Tcl_Obj **attrObjPtrPtr);
+typedef int (TclSetFileAttrProc)(Tcl_Interp *interp, int objIndex,
+	Tcl_Obj *fileName, Tcl_Obj *attrObjPtr);
+
+typedef struct TclFileAttrProcs {
+    TclGetFileAttrProc *getProc;/* The procedure for getting attrs. */
+    TclSetFileAttrProc *setProc;/* The procedure for setting attrs. */
+} TclFileAttrProcs;
+
+/*
+ * Opaque handle used in pipeline routines to encapsulate platform-dependent
+ * state.
+ */
+
+typedef struct TclFile_ *TclFile;
+
+/*
+ * The "globParameters" argument of the function TclGlob is an or'ed
+ * combination of the following values:
+ */
+
+#define TCL_GLOBMODE_NO_COMPLAIN	1
+#define TCL_GLOBMODE_JOIN		2
+#define TCL_GLOBMODE_DIR		4
+#define TCL_GLOBMODE_TAILS		8
+
+typedef enum Tcl_PathPart {
+    TCL_PATH_DIRNAME,
+    TCL_PATH_TAIL,
+    TCL_PATH_EXTENSION,
+    TCL_PATH_ROOT
+} Tcl_PathPart;
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to obsolete filesystem hooks
+ *----------------------------------------------------------------
+ */
+
+typedef int (TclStatProc_)(const char *path, struct stat *buf);
+typedef int (TclAccessProc_)(const char *path, int mode);
+typedef Tcl_Channel (TclOpenFileChannelProc_)(Tcl_Interp *interp,
+	const char *fileName, const char *modeString, int permissions);
+
+/*
+ *----------------------------------------------------------------
+ * Data structures related to procedures
+ *----------------------------------------------------------------
+ */
+
+typedef Tcl_CmdProc *TclCmdProcType;
+typedef Tcl_ObjCmdProc *TclObjCmdProcType;
+
+/*
+ *----------------------------------------------------------------
+ * Data structures for process-global values.
+ *----------------------------------------------------------------
+ */
+
+typedef void (TclInitProcessGlobalValueProc)(char **valuePtr, int *lengthPtr,
+	Tcl_Encoding *encodingPtr);
+
+/*
+ * A ProcessGlobalValue struct exists for each internal value in Tcl that is
+ * to be shared among several threads. Each thread sees a (Tcl_Obj) copy of
+ * the value, and the gobal value is kept as a counted string, with epoch and
+ * mutex control. Each ProcessGlobalValue struct should be a static variable in
+ * some file.
+ */
+
+typedef struct ProcessGlobalValue {
+    int epoch;			/* Epoch counter to detect changes in the
+				 * global value. */
+    int numBytes;		/* Length of the global string. */
+    char *value;		/* The global string value. */
+    Tcl_Encoding encoding;	/* system encoding when global string was
+				 * initialized. */
+    TclInitProcessGlobalValueProc *proc;
+    				/* A procedure to initialize the global string
+				 * copy when a "get" request comes in before
+				 * any "set" request has been received. */
+    Tcl_Mutex mutex;		/* Enforce orderly access from multiple
+				 * threads. */
+    Tcl_ThreadDataKey key;	/* Key for per-thread data holding the
+				 * (Tcl_Obj) copy for each thread. */
+} ProcessGlobalValue;
+
+/*
+ *----------------------------------------------------------------------
+ * Flags for TclParseNumber
+ *----------------------------------------------------------------------
+ */
+
+#define TCL_PARSE_DECIMAL_ONLY		1
+				/* Leading zero doesn't denote octal or
+				 * hex. */
+#define TCL_PARSE_OCTAL_ONLY		2
+				/* Parse octal even without prefix. */
+#define TCL_PARSE_HEXADECIMAL_ONLY	4
+				/* Parse hexadecimal even without prefix. */
+#define TCL_PARSE_INTEGER_ONLY		8
+				/* Disable floating point parsing. */
+#define TCL_PARSE_SCAN_PREFIXES		16
+				/* Use [scan] rules dealing with 0?
+				 * prefixes. */
+#define TCL_PARSE_NO_WHITESPACE		32
+				/* Reject leading/trailing whitespace. */
+#define TCL_PARSE_BINARY_ONLY	64
+				/* Parse binary even without prefix. */
+
+/*
+ *----------------------------------------------------------------------
+ * Type values TclGetNumberFromObj
+ *----------------------------------------------------------------------
+ */
+
+#define TCL_NUMBER_LONG		1
+#define TCL_NUMBER_WIDE		2
+#define TCL_NUMBER_BIG		3
+#define TCL_NUMBER_DOUBLE	4
+#define TCL_NUMBER_NAN		5
+
+/*
+ *----------------------------------------------------------------
+ * Variables shared among Tcl modules but not used by the outside world.
+ *----------------------------------------------------------------
+ */
+
+MODULE_SCOPE char *tclNativeExecutableName;
+MODULE_SCOPE int tclFindExecutableSearchDone;
+MODULE_SCOPE char *tclMemDumpFileName;
+MODULE_SCOPE TclPlatformType tclPlatform;
+MODULE_SCOPE Tcl_NotifierProcs tclNotifierHooks;
+
+MODULE_SCOPE Tcl_Encoding tclIdentityEncoding;
+
+/*
+ * TIP #233 (Virtualized Time)
+ * Data for the time hooks, if any.
+ */
+
+MODULE_SCOPE Tcl_GetTimeProc *tclGetTimeProcPtr;
+MODULE_SCOPE Tcl_ScaleTimeProc *tclScaleTimeProcPtr;
+MODULE_SCOPE ClientData tclTimeClientData;
+
+/*
+ * Variables denoting the Tcl object types defined in the core.
+ */
+
+MODULE_SCOPE const Tcl_ObjType tclBignumType;
+MODULE_SCOPE const Tcl_ObjType tclBooleanType;
+MODULE_SCOPE const Tcl_ObjType tclByteArrayType;
+MODULE_SCOPE const Tcl_ObjType tclByteCodeType;
+MODULE_SCOPE const Tcl_ObjType tclDoubleType;
+MODULE_SCOPE const Tcl_ObjType tclEndOffsetType;
+MODULE_SCOPE const Tcl_ObjType tclIntType;
+MODULE_SCOPE const Tcl_ObjType tclListType;
+MODULE_SCOPE const Tcl_ObjType tclDictType;
+MODULE_SCOPE const Tcl_ObjType tclProcBodyType;
+MODULE_SCOPE const Tcl_ObjType tclStringType;
+MODULE_SCOPE const Tcl_ObjType tclArraySearchType;
+MODULE_SCOPE const Tcl_ObjType tclEnsembleCmdType;
+#ifndef TCL_WIDE_INT_IS_LONG
+MODULE_SCOPE const Tcl_ObjType tclWideIntType;
+#endif
+MODULE_SCOPE const Tcl_ObjType tclRegexpType;
+MODULE_SCOPE Tcl_ObjType tclCmdNameType;
+
+/*
+ * Variables denoting the hash key types defined in the core.
+ */
+
+MODULE_SCOPE const Tcl_HashKeyType tclArrayHashKeyType;
+MODULE_SCOPE const Tcl_HashKeyType tclOneWordHashKeyType;
+MODULE_SCOPE const Tcl_HashKeyType tclStringHashKeyType;
+MODULE_SCOPE const Tcl_HashKeyType tclObjHashKeyType;
+
+/*
+ * The head of the list of free Tcl objects, and the total number of Tcl
+ * objects ever allocated and freed.
+ */
+
+MODULE_SCOPE Tcl_Obj *	tclFreeObjList;
+
+#ifdef TCL_COMPILE_STATS
+MODULE_SCOPE long	tclObjsAlloced;
+MODULE_SCOPE long	tclObjsFreed;
+#define TCL_MAX_SHARED_OBJ_STATS 5
+MODULE_SCOPE long	tclObjsShared[TCL_MAX_SHARED_OBJ_STATS];
+#endif /* TCL_COMPILE_STATS */
+
+/*
+ * Pointer to a heap-allocated string of length zero that the Tcl core uses as
+ * the value of an empty string representation for an object. This value is
+ * shared by all new objects allocated by Tcl_NewObj.
+ */
+
+MODULE_SCOPE char *	tclEmptyStringRep;
+MODULE_SCOPE char	tclEmptyString;
+
+enum CheckEmptyStringResult {
+	TCL_EMPTYSTRING_UNKNOWN = -1, TCL_EMPTYSTRING_NO, TCL_EMPTYSTRING_YES
+};
+
+/*
+ *----------------------------------------------------------------
+ * Procedures shared among Tcl modules but not used by the outside world,
+ * introduced by/for NRE.
+ *----------------------------------------------------------------
+ */
+
+MODULE_SCOPE Tcl_ObjCmdProc TclNRApplyObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNREvalObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRCatchObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRExprObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRForObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRForeachCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRIfObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRLmapCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRPackageObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRSourceObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRSubstObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRSwitchObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRTryObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRUplevelObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRWhileObjCmd;
+
+MODULE_SCOPE Tcl_NRPostProc TclNRForIterCallback;
+MODULE_SCOPE Tcl_NRPostProc TclNRCoroutineActivateCallback;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRTailcallObjCmd;
+MODULE_SCOPE Tcl_NRPostProc TclNRTailcallEval;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRCoroutineObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRYieldObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRYieldmObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRYieldToObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRInvoke;
+MODULE_SCOPE Tcl_NRPostProc TclNRReleaseValues;
+
+MODULE_SCOPE void  TclSetTailcall(Tcl_Interp *interp, Tcl_Obj *tailcallPtr);
+MODULE_SCOPE void  TclPushTailcallPoint(Tcl_Interp *interp);
+
+/* These two can be considered for the public api */
+MODULE_SCOPE void  TclMarkTailcall(Tcl_Interp *interp);
+MODULE_SCOPE void  TclSkipTailcall(Tcl_Interp *interp);
+
+/*
+ * This structure holds the data for the various iteration callbacks used to
+ * NRE the 'for' and 'while' commands. We need a separate structure because we
+ * have more than the 4 client data entries we can provide directly thorugh
+ * the callback API. It is the 'word' information which puts us over the
+ * limit. It is needed because the loop body is argument 4 of 'for' and
+ * argument 2 of 'while'. Not providing the correct index confuses the #280
+ * code. We TclSmallAlloc/Free this.
+ */
+
+typedef struct ForIterData {
+    Tcl_Obj *cond;		/* Loop condition expression. */
+    Tcl_Obj *body;		/* Loop body. */
+    Tcl_Obj *next;		/* Loop step script, NULL for 'while'. */
+    const char *msg;		/* Error message part. */
+    int word;			/* Index of the body script in the command */
+} ForIterData;
+
+/* TIP #357 - Structure doing the bookkeeping of handles for Tcl_LoadFile
+ *            and Tcl_FindSymbol. This structure corresponds to an opaque
+ *            typedef in tcl.h */
+
+typedef void* TclFindSymbolProc(Tcl_Interp* interp, Tcl_LoadHandle loadHandle,
+				const char* symbol);
+struct Tcl_LoadHandle_ {
+    ClientData clientData;	/* Client data is the load handle in the
+				 * native filesystem if a module was loaded
+				 * there, or an opaque pointer to a structure
+				 * for further bookkeeping on load-from-VFS
+				 * and load-from-memory */
+    TclFindSymbolProc* findSymbolProcPtr;
+				/* Procedure that resolves symbols in a
+				 * loaded module */
+    Tcl_FSUnloadFileProc* unloadFileProcPtr;
+				/* Procedure that unloads a loaded module */
+};
+
+/* Flags for conversion of doubles to digit strings */
+
+#define TCL_DD_SHORTEST 		0x4
+				/* Use the shortest possible string */
+#define TCL_DD_STEELE   		0x5
+				/* Use the original Steele&White algorithm */
+#define TCL_DD_E_FORMAT 		0x2
+				/* Use a fixed-length string of digits,
+				 * suitable for E format*/
+#define TCL_DD_F_FORMAT 		0x3
+				/* Use a fixed number of digits after the
+				 * decimal point, suitable for F format */
+
+#define TCL_DD_SHORTEN_FLAG 		0x4
+				/* Allow return of a shorter digit string
+				 * if it converts losslessly */
+#define TCL_DD_NO_QUICK 		0x8
+				/* Debug flag: forbid quick FP conversion */
+
+#define TCL_DD_CONVERSION_TYPE_MASK	0x3
+				/* Mask to isolate the conversion type */
+#define TCL_DD_STEELE0 			0x1
+				/* 'Steele&White' after masking */
+#define TCL_DD_SHORTEST0		0x0
+				/* 'Shortest possible' after masking */
+
+/*
+ *----------------------------------------------------------------
+ * Procedures shared among Tcl modules but not used by the outside world:
+ *----------------------------------------------------------------
+ */
+
+MODULE_SCOPE void	TclAppendBytesToByteArray(Tcl_Obj *objPtr,
+			    const unsigned char *bytes, int len);
+MODULE_SCOPE void	TclAppendUtfToUtf(Tcl_Obj *objPtr,
+			    const char *bytes, int numBytes);
+MODULE_SCOPE void	TclAdvanceContinuations(int *line, int **next,
+			    int loc);
+MODULE_SCOPE void	TclAdvanceLines(int *line, const char *start,
+			    const char *end);
+MODULE_SCOPE void	TclArgumentEnter(Tcl_Interp *interp,
+			    Tcl_Obj *objv[], int objc, CmdFrame *cf);
+MODULE_SCOPE void	TclArgumentRelease(Tcl_Interp *interp,
+			    Tcl_Obj *objv[], int objc);
+MODULE_SCOPE void	TclArgumentBCEnter(Tcl_Interp *interp,
+			    Tcl_Obj *objv[], int objc,
+			    void *codePtr, CmdFrame *cfPtr, int cmd, int pc);
+MODULE_SCOPE void	TclArgumentBCRelease(Tcl_Interp *interp,
+			    CmdFrame *cfPtr);
+MODULE_SCOPE void	TclArgumentGet(Tcl_Interp *interp, Tcl_Obj *obj,
+			    CmdFrame **cfPtrPtr, int *wordPtr);
+MODULE_SCOPE double	TclBignumToDouble(const mp_int *bignum);
+MODULE_SCOPE int	TclByteArrayMatch(const unsigned char *string,
+			    int strLen, const unsigned char *pattern,
+			    int ptnLen, int flags);
+MODULE_SCOPE double	TclCeil(const mp_int *a);
+MODULE_SCOPE void	TclChannelPreserve(Tcl_Channel chan);
+MODULE_SCOPE void	TclChannelRelease(Tcl_Channel chan);
+MODULE_SCOPE int	TclCheckArrayTraces(Tcl_Interp *interp, Var *varPtr,
+			    Var *arrayPtr, Tcl_Obj *name, int index);
+MODULE_SCOPE int	TclCheckBadOctal(Tcl_Interp *interp,
+			    const char *value);
+MODULE_SCOPE int	TclCheckEmptyString(Tcl_Obj *objPtr);
+MODULE_SCOPE int	TclChanCaughtErrorBypass(Tcl_Interp *interp,
+			    Tcl_Channel chan);
+MODULE_SCOPE Tcl_ObjCmdProc TclChannelNamesCmd;
+MODULE_SCOPE Tcl_NRPostProc TclClearRootEnsemble;
+MODULE_SCOPE ContLineLoc *TclContinuationsEnter(Tcl_Obj *objPtr, int num,
+			    int *loc);
+MODULE_SCOPE void	TclContinuationsEnterDerived(Tcl_Obj *objPtr,
+			    int start, int *clNext);
+MODULE_SCOPE ContLineLoc *TclContinuationsGet(Tcl_Obj *objPtr);
+MODULE_SCOPE void	TclContinuationsCopy(Tcl_Obj *objPtr,
+			    Tcl_Obj *originObjPtr);
+MODULE_SCOPE int	TclConvertElement(const char *src, int length,
+			    char *dst, int flags);
+MODULE_SCOPE Tcl_Command TclCreateObjCommandInNs(Tcl_Interp *interp,
+			    const char *cmdName, Tcl_Namespace *nsPtr,
+			    Tcl_ObjCmdProc *proc, ClientData clientData,
+			    Tcl_CmdDeleteProc *deleteProc);
+MODULE_SCOPE Tcl_Command TclCreateEnsembleInNs(Tcl_Interp *interp,
+			    const char *name, Tcl_Namespace *nameNamespacePtr,
+			    Tcl_Namespace *ensembleNamespacePtr, int flags);
+MODULE_SCOPE void	TclDeleteNamespaceVars(Namespace *nsPtr);
+MODULE_SCOPE int	TclFindDictElement(Tcl_Interp *interp,
+			    const char *dict, int dictLength,
+			    const char **elementPtr, const char **nextPtr,
+			    int *sizePtr, int *literalPtr);
+/* TIP #280 - Modified token based evaluation, with line information. */
+MODULE_SCOPE int	TclEvalEx(Tcl_Interp *interp, const char *script,
+			    int numBytes, int flags, int line,
+			    int *clNextOuter, const char *outerScript);
+MODULE_SCOPE Tcl_ObjCmdProc TclFileAttrsCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileCopyCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileDeleteCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileLinkCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileMakeDirsCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileReadLinkCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileRenameCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileTemporaryCmd;
+MODULE_SCOPE void	TclCreateLateExitHandler(Tcl_ExitProc *proc,
+			    ClientData clientData);
+MODULE_SCOPE void	TclDeleteLateExitHandler(Tcl_ExitProc *proc,
+			    ClientData clientData);
+MODULE_SCOPE char *	TclDStringAppendObj(Tcl_DString *dsPtr,
+			    Tcl_Obj *objPtr);
+MODULE_SCOPE char *	TclDStringAppendDString(Tcl_DString *dsPtr,
+			    Tcl_DString *toAppendPtr);
+MODULE_SCOPE Tcl_Obj *	TclDStringToObj(Tcl_DString *dsPtr);
+MODULE_SCOPE Tcl_Obj *const *TclFetchEnsembleRoot(Tcl_Interp *interp,
+			    Tcl_Obj *const *objv, int objc, int *objcPtr);
+MODULE_SCOPE Tcl_Obj *const *TclEnsembleGetRewriteValues(Tcl_Interp *interp);
+MODULE_SCOPE Tcl_Namespace *TclEnsureNamespace(Tcl_Interp *interp,
+			    Tcl_Namespace *namespacePtr);
+MODULE_SCOPE void	TclFinalizeAllocSubsystem(void);
+MODULE_SCOPE void	TclFinalizeAsync(void);
+MODULE_SCOPE void	TclFinalizeDoubleConversion(void);
+MODULE_SCOPE void	TclFinalizeEncodingSubsystem(void);
+MODULE_SCOPE void	TclFinalizeEnvironment(void);
+MODULE_SCOPE void	TclFinalizeEvaluation(void);
+MODULE_SCOPE void	TclFinalizeExecution(void);
+MODULE_SCOPE void	TclFinalizeIOSubsystem(void);
+MODULE_SCOPE void	TclFinalizeFilesystem(void);
+MODULE_SCOPE void	TclResetFilesystem(void);
+MODULE_SCOPE void	TclFinalizeLoad(void);
+MODULE_SCOPE void	TclFinalizeLock(void);
+MODULE_SCOPE void	TclFinalizeMemorySubsystem(void);
+MODULE_SCOPE void	TclFinalizeNotifier(void);
+MODULE_SCOPE void	TclFinalizeObjects(void);
+MODULE_SCOPE void	TclFinalizePreserve(void);
+MODULE_SCOPE void	TclFinalizeSynchronization(void);
+MODULE_SCOPE void	TclFinalizeThreadAlloc(void);
+MODULE_SCOPE void	TclFinalizeThreadAllocThread(void);
+MODULE_SCOPE void	TclFinalizeThreadData(int quick);
+MODULE_SCOPE void	TclFinalizeThreadObjects(void);
+MODULE_SCOPE double	TclFloor(const mp_int *a);
+MODULE_SCOPE void	TclFormatNaN(double value, char *buffer);
+MODULE_SCOPE int	TclFSFileAttrIndex(Tcl_Obj *pathPtr,
+			    const char *attributeName, int *indexPtr);
+MODULE_SCOPE Tcl_Command TclNRCreateCommandInNs(Tcl_Interp *interp,
+			    const char *cmdName, Tcl_Namespace *nsPtr,
+			    Tcl_ObjCmdProc *proc, Tcl_ObjCmdProc *nreProc,
+			    ClientData clientData, Tcl_CmdDeleteProc *deleteProc);
+MODULE_SCOPE int	TclNREvalFile(Tcl_Interp *interp, Tcl_Obj *pathPtr,
+			    const char *encodingName);
+MODULE_SCOPE int *	TclGetAsyncReadyPtr(void);
+MODULE_SCOPE Tcl_Obj *	TclGetBgErrorHandler(Tcl_Interp *interp);
+MODULE_SCOPE int	TclGetChannelFromObj(Tcl_Interp *interp,
+			    Tcl_Obj *objPtr, Tcl_Channel *chanPtr,
+			    int *modePtr, int flags);
+MODULE_SCOPE CmdFrame *	TclGetCmdFrameForProcedure(Proc *procPtr);
+MODULE_SCOPE int	TclGetCompletionCodeFromObj(Tcl_Interp *interp,
+			    Tcl_Obj *value, int *code);
+MODULE_SCOPE int	TclGetNumberFromObj(Tcl_Interp *interp,
+			    Tcl_Obj *objPtr, ClientData *clientDataPtr,
+			    int *typePtr);
+MODULE_SCOPE int	TclGetOpenModeEx(Tcl_Interp *interp,
+			    const char *modeString, int *seekFlagPtr,
+			    int *binaryPtr);
+MODULE_SCOPE Tcl_Obj *	TclGetProcessGlobalValue(ProcessGlobalValue *pgvPtr);
+MODULE_SCOPE Tcl_Obj *	TclGetSourceFromFrame(CmdFrame *cfPtr, int objc,
+			    Tcl_Obj *const objv[]);
+MODULE_SCOPE char *	TclGetStringStorage(Tcl_Obj *objPtr,
+			    unsigned int *sizePtr);
+MODULE_SCOPE int	TclGlob(Tcl_Interp *interp, char *pattern,
+			    Tcl_Obj *unquotedPrefix, int globFlags,
+			    Tcl_GlobTypeData *types);
+MODULE_SCOPE int	TclIncrObj(Tcl_Interp *interp, Tcl_Obj *valuePtr,
+			    Tcl_Obj *incrPtr);
+MODULE_SCOPE Tcl_Obj *	TclIncrObjVar2(Tcl_Interp *interp, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, Tcl_Obj *incrPtr, int flags);
+MODULE_SCOPE Tcl_ObjCmdProc TclInfoExistsCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclInfoCoroutineCmd;
+MODULE_SCOPE Tcl_Obj *	TclInfoFrame(Tcl_Interp *interp, CmdFrame *framePtr);
+MODULE_SCOPE Tcl_ObjCmdProc TclInfoGlobalsCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclInfoLocalsCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclInfoVarsCmd;
+MODULE_SCOPE void	TclInitAlloc(void);
+MODULE_SCOPE void	TclInitDbCkalloc(void);
+MODULE_SCOPE void	TclInitDoubleConversion(void);
+MODULE_SCOPE void	TclInitEmbeddedConfigurationInformation(
+			    Tcl_Interp *interp);
+MODULE_SCOPE void	TclInitEncodingSubsystem(void);
+MODULE_SCOPE void	TclInitIOSubsystem(void);
+MODULE_SCOPE void	TclInitLimitSupport(Tcl_Interp *interp);
+MODULE_SCOPE void	TclInitNamespaceSubsystem(void);
+MODULE_SCOPE void	TclInitNotifier(void);
+MODULE_SCOPE void	TclInitObjSubsystem(void);
+MODULE_SCOPE const char *TclInitSubsystems(void);
+MODULE_SCOPE int	TclInterpReady(Tcl_Interp *interp);
+MODULE_SCOPE int	TclIsBareword(int byte);
+MODULE_SCOPE Tcl_Obj *	TclJoinPath(int elements, Tcl_Obj * const objv[],
+			    int forceRelative);
+MODULE_SCOPE int	TclJoinThread(Tcl_ThreadId id, int *result);
+MODULE_SCOPE void	TclLimitRemoveAllHandlers(Tcl_Interp *interp);
+MODULE_SCOPE Tcl_Obj *	TclLindexList(Tcl_Interp *interp,
+			    Tcl_Obj *listPtr, Tcl_Obj *argPtr);
+MODULE_SCOPE Tcl_Obj *	TclLindexFlat(Tcl_Interp *interp, Tcl_Obj *listPtr,
+			    int indexCount, Tcl_Obj *const indexArray[]);
+/* TIP #280 */
+MODULE_SCOPE void	TclListLines(Tcl_Obj *listObj, int line, int n,
+			    int *lines, Tcl_Obj *const *elems);
+MODULE_SCOPE Tcl_Obj *	TclListObjCopy(Tcl_Interp *interp, Tcl_Obj *listPtr);
+MODULE_SCOPE Tcl_Obj *	TclLsetList(Tcl_Interp *interp, Tcl_Obj *listPtr,
+			    Tcl_Obj *indexPtr, Tcl_Obj *valuePtr);
+MODULE_SCOPE Tcl_Obj *	TclLsetFlat(Tcl_Interp *interp, Tcl_Obj *listPtr,
+			    int indexCount, Tcl_Obj *const indexArray[],
+			    Tcl_Obj *valuePtr);
+MODULE_SCOPE Tcl_Command TclMakeEnsemble(Tcl_Interp *interp, const char *name,
+			    const EnsembleImplMap map[]);
+MODULE_SCOPE int	TclMaxListLength(const char *bytes, int numBytes,
+			    const char **endPtr);
+MODULE_SCOPE int	TclMergeReturnOptions(Tcl_Interp *interp, int objc,
+			    Tcl_Obj *const objv[], Tcl_Obj **optionsPtrPtr,
+			    int *codePtr, int *levelPtr);
+MODULE_SCOPE Tcl_Obj *  TclNoErrorStack(Tcl_Interp *interp, Tcl_Obj *options);
+MODULE_SCOPE int	TclNokia770Doubles(void);
+MODULE_SCOPE void	TclNsDecrRefCount(Namespace *nsPtr);
+MODULE_SCOPE int	TclNamespaceDeleted(Namespace *nsPtr);
+MODULE_SCOPE void	TclObjVarErrMsg(Tcl_Interp *interp, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, const char *operation,
+			    const char *reason, int index);
+MODULE_SCOPE int	TclObjInvokeNamespace(Tcl_Interp *interp,
+			    int objc, Tcl_Obj *const objv[],
+			    Tcl_Namespace *nsPtr, int flags);
+MODULE_SCOPE int	TclObjUnsetVar2(Tcl_Interp *interp,
+			    Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr, int flags);
+MODULE_SCOPE int	TclParseBackslash(const char *src,
+			    int numBytes, int *readPtr, char *dst);
+MODULE_SCOPE int	TclParseNumber(Tcl_Interp *interp, Tcl_Obj *objPtr,
+			    const char *expected, const char *bytes,
+			    int numBytes, const char **endPtrPtr, int flags);
+MODULE_SCOPE void	TclParseInit(Tcl_Interp *interp, const char *string,
+			    int numBytes, Tcl_Parse *parsePtr);
+MODULE_SCOPE int	TclParseAllWhiteSpace(const char *src, int numBytes);
+MODULE_SCOPE int	TclProcessReturn(Tcl_Interp *interp,
+			    int code, int level, Tcl_Obj *returnOpts);
+MODULE_SCOPE int	TclpObjLstat(Tcl_Obj *pathPtr, Tcl_StatBuf *buf);
+MODULE_SCOPE Tcl_Obj *	TclpTempFileName(void);
+MODULE_SCOPE Tcl_Obj *  TclpTempFileNameForLibrary(Tcl_Interp *interp, Tcl_Obj* pathPtr);
+MODULE_SCOPE Tcl_Obj *	TclNewFSPathObj(Tcl_Obj *dirPtr, const char *addStrRep,
+			    int len);
+MODULE_SCOPE int	TclpDeleteFile(const void *path);
+MODULE_SCOPE void	TclpFinalizeCondition(Tcl_Condition *condPtr);
+MODULE_SCOPE void	TclpFinalizeMutex(Tcl_Mutex *mutexPtr);
+MODULE_SCOPE void	TclpFinalizePipes(void);
+MODULE_SCOPE void	TclpFinalizeSockets(void);
+MODULE_SCOPE int	TclCreateSocketAddress(Tcl_Interp *interp,
+			    struct addrinfo **addrlist,
+			    const char *host, int port, int willBind,
+			    const char **errorMsgPtr);
+MODULE_SCOPE int	TclpThreadCreate(Tcl_ThreadId *idPtr,
+			    Tcl_ThreadCreateProc *proc, ClientData clientData,
+			    int stackSize, int flags);
+MODULE_SCOPE int	TclpFindVariable(const char *name, int *lengthPtr);
+MODULE_SCOPE void	TclpInitLibraryPath(char **valuePtr,
+			    int *lengthPtr, Tcl_Encoding *encodingPtr);
+MODULE_SCOPE void	TclpInitLock(void);
+MODULE_SCOPE void	TclpInitPlatform(void);
+MODULE_SCOPE void	TclpInitUnlock(void);
+MODULE_SCOPE Tcl_Obj *	TclpObjListVolumes(void);
+MODULE_SCOPE void	TclpGlobalLock(void);
+MODULE_SCOPE void	TclpGlobalUnlock(void);
+MODULE_SCOPE int	TclpObjNormalizePath(Tcl_Interp *interp,
+			    Tcl_Obj *pathPtr, int nextCheckpoint);
+MODULE_SCOPE void	TclpNativeJoinPath(Tcl_Obj *prefix, const char *joining);
+MODULE_SCOPE Tcl_Obj *	TclpNativeSplitPath(Tcl_Obj *pathPtr, int *lenPtr);
+MODULE_SCOPE Tcl_PathType TclpGetNativePathType(Tcl_Obj *pathPtr,
+			    int *driveNameLengthPtr, Tcl_Obj **driveNameRef);
+MODULE_SCOPE int	TclCrossFilesystemCopy(Tcl_Interp *interp,
+			    Tcl_Obj *source, Tcl_Obj *target);
+MODULE_SCOPE int	TclpMatchInDirectory(Tcl_Interp *interp,
+			    Tcl_Obj *resultPtr, Tcl_Obj *pathPtr,
+			    const char *pattern, Tcl_GlobTypeData *types);
+MODULE_SCOPE ClientData	TclpGetNativeCwd(ClientData clientData);
+MODULE_SCOPE Tcl_FSDupInternalRepProc TclNativeDupInternalRep;
+MODULE_SCOPE Tcl_Obj *	TclpObjLink(Tcl_Obj *pathPtr, Tcl_Obj *toPtr,
+			    int linkType);
+MODULE_SCOPE int	TclpObjChdir(Tcl_Obj *pathPtr);
+MODULE_SCOPE Tcl_Channel TclpOpenTemporaryFile(Tcl_Obj *dirObj,
+			    Tcl_Obj *basenameObj, Tcl_Obj *extensionObj,
+			    Tcl_Obj *resultingNameObj);
+MODULE_SCOPE Tcl_Obj *	TclPathPart(Tcl_Interp *interp, Tcl_Obj *pathPtr,
+			    Tcl_PathPart portion);
+MODULE_SCOPE char *	TclpReadlink(const char *fileName,
+			    Tcl_DString *linkPtr);
+MODULE_SCOPE void	TclpSetVariables(Tcl_Interp *interp);
+MODULE_SCOPE void *	TclThreadStorageKeyGet(Tcl_ThreadDataKey *keyPtr);
+MODULE_SCOPE void	TclThreadStorageKeySet(Tcl_ThreadDataKey *keyPtr,
+			    void *data);
+MODULE_SCOPE void	TclpThreadExit(int status);
+MODULE_SCOPE void	TclRememberCondition(Tcl_Condition *mutex);
+MODULE_SCOPE void	TclRememberJoinableThread(Tcl_ThreadId id);
+MODULE_SCOPE void	TclRememberMutex(Tcl_Mutex *mutex);
+MODULE_SCOPE void	TclRemoveScriptLimitCallbacks(Tcl_Interp *interp);
+MODULE_SCOPE int	TclReToGlob(Tcl_Interp *interp, const char *reStr,
+			    int reStrLen, Tcl_DString *dsPtr, int *flagsPtr,
+			    int *quantifiersFoundPtr);
+MODULE_SCOPE unsigned int TclScanElement(const char *string, int length,
+			    char *flagPtr);
+MODULE_SCOPE void	TclSetBgErrorHandler(Tcl_Interp *interp,
+			    Tcl_Obj *cmdPrefix);
+MODULE_SCOPE void	TclSetBignumInternalRep(Tcl_Obj *objPtr,
+			    mp_int *bignumValue);
+MODULE_SCOPE int	TclSetBooleanFromAny(Tcl_Interp *interp, Tcl_Obj *objPtr);
+MODULE_SCOPE void	TclSetCmdNameObj(Tcl_Interp *interp, Tcl_Obj *objPtr,
+			    Command *cmdPtr);
+MODULE_SCOPE void	TclSetDuplicateObj(Tcl_Obj *dupPtr, Tcl_Obj *objPtr);
+MODULE_SCOPE void	TclSetProcessGlobalValue(ProcessGlobalValue *pgvPtr,
+			    Tcl_Obj *newValue, Tcl_Encoding encoding);
+MODULE_SCOPE void	TclSignalExitThread(Tcl_ThreadId id, int result);
+MODULE_SCOPE void	TclSpellFix(Tcl_Interp *interp,
+			    Tcl_Obj *const *objv, int objc, int subIdx,
+			    Tcl_Obj *bad, Tcl_Obj *fix);
+MODULE_SCOPE void *	TclStackRealloc(Tcl_Interp *interp, void *ptr,
+			    int numBytes);
+
+typedef int (*memCmpFn_t)(const void*, const void*, size_t);
+MODULE_SCOPE int	TclStringCmp(Tcl_Obj *value1Ptr, Tcl_Obj *value2Ptr,
+			    int checkEq, int nocase, int reqlength);
+MODULE_SCOPE int	TclUniCharNcasecmp(const void*, const void*, size_t);
+MODULE_SCOPE int	TclUtfNcasecmp(const void*, const void*, size_t);
+MODULE_SCOPE int	TclUtfNcmp(const void*, const void*, size_t);
+MODULE_SCOPE int	TclUniCharNcmp(const void*, const void*, size_t);
+MODULE_SCOPE int	TclUtfNcmp2(const void*, const void*, size_t);
+MODULE_SCOPE int	TclStringCmpOpts(Tcl_Interp *interp, int objc, Tcl_Obj *const objv[],
+			    int *nocase, int *reqlength);
+MODULE_SCOPE int	TclStringMatch(const char *str, int strLen,
+			    const char *pattern, int ptnLen, int flags);
+MODULE_SCOPE int	TclStringMatchObj(Tcl_Obj *stringObj,
+			    Tcl_Obj *patternObj, int flags);
+MODULE_SCOPE Tcl_Obj *	TclStringReverse(Tcl_Obj *objPtr);
+MODULE_SCOPE void	TclSubstCompile(Tcl_Interp *interp, const char *bytes,
+			    int numBytes, int flags, int line,
+			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclSubstOptions(Tcl_Interp *interp, int numOpts,
+			    Tcl_Obj *const opts[], int *flagPtr);
+MODULE_SCOPE void	TclSubstParse(Tcl_Interp *interp, const char *bytes,
+			    int numBytes, int flags, Tcl_Parse *parsePtr,
+			    Tcl_InterpState *statePtr);
+MODULE_SCOPE int	TclSubstTokens(Tcl_Interp *interp, Tcl_Token *tokenPtr,
+			    int count, int *tokensLeftPtr, int line,
+			    int *clNextOuter, const char *outerScript);
+MODULE_SCOPE int	TclTrim(const char *bytes, int numBytes,
+			    const char *trim, int numTrim, int *trimRight);
+MODULE_SCOPE int	TclTrimLeft(const char *bytes, int numBytes,
+			    const char *trim, int numTrim);
+MODULE_SCOPE int	TclTrimRight(const char *bytes, int numBytes,
+			    const char *trim, int numTrim);
+MODULE_SCOPE int	TclUtfCasecmp(const char *cs, const char *ct);
+MODULE_SCOPE int	TclUtfToUCS4(const char *, int *);
+MODULE_SCOPE int	TclUCS4ToUtf(int, char *);
+MODULE_SCOPE int	TclUCS4ToLower(int ch);
+#if TCL_UTF_MAX == 4
+    MODULE_SCOPE int	TclGetUCS4(Tcl_Obj *, int);
+    MODULE_SCOPE int	TclUniCharToUCS4(const Tcl_UniChar *, int *);
+#else
+#   define TclGetUCS4 Tcl_GetUniChar
+#   define TclUniCharToUCS4(src, ptr) (*ptr = *(src),1)
+#endif
+
+/*
+ * Bytes F0-F4 are start-bytes for 4-byte sequences.
+ * Byte 0xED can be the start-byte of an upper surrogate. In that case,
+ * TclUtfToUCS4() might read the lower surrogate following it too.
+ */
+#   define TclUCS4Complete(src, length) (((unsigned)(UCHAR(*(src)) - 0xF0) < 5) \
+	    ? ((length) >= 4) : (UCHAR(*(src)) == 0xED) ? ((length) >= 6) : Tcl_UtfCharComplete((src), (length)))
+MODULE_SCOPE Tcl_Obj *	TclpNativeToNormalized(ClientData clientData);
+MODULE_SCOPE Tcl_Obj *	TclpFilesystemPathType(Tcl_Obj *pathPtr);
+MODULE_SCOPE int	TclpDlopen(Tcl_Interp *interp, Tcl_Obj *pathPtr,
+			    Tcl_LoadHandle *loadHandle,
+			    Tcl_FSUnloadFileProc **unloadProcPtr, int flags);
+MODULE_SCOPE int	TclpUtime(Tcl_Obj *pathPtr, struct utimbuf *tval);
+#ifdef TCL_LOAD_FROM_MEMORY
+MODULE_SCOPE void *	TclpLoadMemoryGetBuffer(Tcl_Interp *interp, int size);
+MODULE_SCOPE int	TclpLoadMemory(Tcl_Interp *interp, void *buffer,
+			    int size, int codeSize, Tcl_LoadHandle *loadHandle,
+			    Tcl_FSUnloadFileProc **unloadProcPtr, int flags);
+#endif
+MODULE_SCOPE void	TclInitThreadStorage(void);
+MODULE_SCOPE void	TclFinalizeThreadDataThread(void);
+MODULE_SCOPE void	TclFinalizeThreadStorage(void);
+
+/* TclWideMUInt -- wide integer used for measurement calculations: */
+#if (!defined(_WIN32) || !defined(_MSC_VER) || (_MSC_VER >= 1400))
+#   define TclWideMUInt Tcl_WideUInt
+#else
+/* older MSVS may not allow conversions between unsigned __int64 and double) */
+#   define TclWideMUInt Tcl_WideInt
+#endif
+#ifdef TCL_WIDE_CLICKS
+MODULE_SCOPE Tcl_WideInt TclpGetWideClicks(void);
+MODULE_SCOPE double	TclpWideClicksToNanoseconds(Tcl_WideInt clicks);
+MODULE_SCOPE double	TclpWideClickInMicrosec(void);
+#else
+#   ifdef _WIN32
+#	define TCL_WIDE_CLICKS 1
+MODULE_SCOPE Tcl_WideInt TclpGetWideClicks(void);
+MODULE_SCOPE double	TclpWideClickInMicrosec(void);
+#	define		TclpWideClicksToNanoseconds(clicks) \
+				((double)(clicks) * TclpWideClickInMicrosec() * 1000)
+#   endif
+#endif
+MODULE_SCOPE Tcl_WideInt TclpGetMicroseconds(void);
+
+MODULE_SCOPE int	TclZlibInit(Tcl_Interp *interp);
+MODULE_SCOPE void *	TclpThreadCreateKey(void);
+MODULE_SCOPE void	TclpThreadDeleteKey(void *keyPtr);
+MODULE_SCOPE void	TclpThreadSetGlobalTSD(void *tsdKeyPtr, void *ptr);
+MODULE_SCOPE void *	TclpThreadGetGlobalTSD(void *tsdKeyPtr);
+MODULE_SCOPE void	TclErrorStackResetIf(Tcl_Interp *interp,
+			    const char *msg, int length);
+
+/*
+ * Many parsing tasks need a common definition of whitespace.
+ * Use this routine and macro to achieve that and place
+ * optimization (fragile on changes) in one place.
+ */
+
+MODULE_SCOPE int	TclIsSpaceProc(int byte);
+#	define TclIsSpaceProcM(byte) \
+		(((byte) > 0x20) ? 0 : TclIsSpaceProc(byte))
+
+/*
+ *----------------------------------------------------------------
+ * Command procedures in the generic core:
+ *----------------------------------------------------------------
+ */
+
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_AfterObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_AppendObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_ApplyObjCmd;
+MODULE_SCOPE Tcl_Command TclInitArrayCmd(Tcl_Interp *interp);
+MODULE_SCOPE Tcl_Command TclInitBinaryCmd(Tcl_Interp *interp);
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_BreakObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_CaseObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_CatchObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_CdObjCmd;
+MODULE_SCOPE Tcl_Command TclInitChanCmd(Tcl_Interp *interp);
+MODULE_SCOPE Tcl_ObjCmdProc TclChanCreateObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclChanPostEventObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclChanPopObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclChanPushObjCmd;
+MODULE_SCOPE void	TclClockInit(Tcl_Interp *interp);
+MODULE_SCOPE Tcl_ObjCmdProc TclClockOldscanObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_CloseObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_ConcatObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_ContinueObjCmd;
+MODULE_SCOPE Tcl_TimerToken TclCreateAbsoluteTimerHandler(
+			    Tcl_Time *timePtr, Tcl_TimerProc *proc,
+			    ClientData clientData);
+MODULE_SCOPE Tcl_ObjCmdProc TclDefaultBgErrorHandlerObjCmd;
+MODULE_SCOPE Tcl_Command TclInitDictCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	TclDictWithFinish(Tcl_Interp *interp, Var *varPtr,
+			    Var *arrayPtr, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, int index, int pathc,
+			    Tcl_Obj *const pathv[], Tcl_Obj *keysPtr);
+MODULE_SCOPE Tcl_Obj *	TclDictWithInit(Tcl_Interp *interp, Tcl_Obj *dictPtr,
+			    int pathc, Tcl_Obj *const pathv[]);
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_DisassembleObjCmd;
+
+/* Assemble command function */
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_AssembleObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRAssembleObjCmd;
+MODULE_SCOPE Tcl_Command TclInitEncodingCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	TclMakeEncodingCommandSafe(Tcl_Interp *interp);
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_EofObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_ErrorObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_EvalObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_ExecObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_ExitObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_ExprObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_FblockedObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_FconfigureObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_FcopyObjCmd;
+MODULE_SCOPE Tcl_Command TclInitFileCmd(Tcl_Interp *interp);
+MODULE_SCOPE int	TclMakeFileCommandSafe(Tcl_Interp *interp);
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_FileEventObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_FlushObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_ForObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_ForeachObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_FormatObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_GetsObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_GlobalObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_GlobObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_IfObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_IncrObjCmd;
+MODULE_SCOPE Tcl_Command TclInitInfoCmd(Tcl_Interp *interp);
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_InterpObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_JoinObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_LappendObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_LassignObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_LindexObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_LinsertObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_LlengthObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_ListObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_LmapObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_LoadObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_LrangeObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_LrepeatObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_LreplaceObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_LreverseObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_LsearchObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_LsetObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_LsortObjCmd;
+MODULE_SCOPE Tcl_Command TclInitNamespaceCmd(Tcl_Interp *interp);
+MODULE_SCOPE Tcl_ObjCmdProc TclNamespaceEnsembleCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_OpenObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_PackageObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_PidObjCmd;
+MODULE_SCOPE Tcl_Command TclInitPrefixCmd(Tcl_Interp *interp);
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_PutsObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_PwdObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_ReadObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_RegexpObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_RegsubObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_RenameObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_RepresentationCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_ReturnObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_ScanObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_SeekObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_SetObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_SplitObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_SocketObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_SourceObjCmd;
+MODULE_SCOPE Tcl_Command TclInitStringCmd(Tcl_Interp *interp);
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_SubstObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_SwitchObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_TellObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_ThrowObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_TimeObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_TimeRateObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_TraceObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_TryObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_UnloadObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_UnsetObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_UpdateObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_UplevelObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_UpvarObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_VariableObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_VwaitObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc Tcl_WhileObjCmd;
+
+/*
+ *----------------------------------------------------------------
+ * Compilation procedures for commands in the generic core:
+ *----------------------------------------------------------------
+ */
+
+MODULE_SCOPE CompileProc TclCompileAppendCmd;
+MODULE_SCOPE CompileProc TclCompileArrayExistsCmd;
+MODULE_SCOPE CompileProc TclCompileArraySetCmd;
+MODULE_SCOPE CompileProc TclCompileArrayUnsetCmd;
+MODULE_SCOPE CompileProc TclCompileBreakCmd;
+MODULE_SCOPE CompileProc TclCompileCatchCmd;
+MODULE_SCOPE CompileProc TclCompileClockClicksCmd;
+MODULE_SCOPE CompileProc TclCompileClockReadingCmd;
+MODULE_SCOPE CompileProc TclCompileConcatCmd;
+MODULE_SCOPE CompileProc TclCompileContinueCmd;
+MODULE_SCOPE CompileProc TclCompileDictAppendCmd;
+MODULE_SCOPE CompileProc TclCompileDictCreateCmd;
+MODULE_SCOPE CompileProc TclCompileDictExistsCmd;
+MODULE_SCOPE CompileProc TclCompileDictForCmd;
+MODULE_SCOPE CompileProc TclCompileDictGetCmd;
+MODULE_SCOPE CompileProc TclCompileDictIncrCmd;
+MODULE_SCOPE CompileProc TclCompileDictLappendCmd;
+MODULE_SCOPE CompileProc TclCompileDictMapCmd;
+MODULE_SCOPE CompileProc TclCompileDictMergeCmd;
+MODULE_SCOPE CompileProc TclCompileDictSetCmd;
+MODULE_SCOPE CompileProc TclCompileDictUnsetCmd;
+MODULE_SCOPE CompileProc TclCompileDictUpdateCmd;
+MODULE_SCOPE CompileProc TclCompileDictWithCmd;
+MODULE_SCOPE CompileProc TclCompileEnsemble;
+MODULE_SCOPE CompileProc TclCompileErrorCmd;
+MODULE_SCOPE CompileProc TclCompileExprCmd;
+MODULE_SCOPE CompileProc TclCompileForCmd;
+MODULE_SCOPE CompileProc TclCompileForeachCmd;
+MODULE_SCOPE CompileProc TclCompileFormatCmd;
+MODULE_SCOPE CompileProc TclCompileGlobalCmd;
+MODULE_SCOPE CompileProc TclCompileIfCmd;
+MODULE_SCOPE CompileProc TclCompileInfoCommandsCmd;
+MODULE_SCOPE CompileProc TclCompileInfoCoroutineCmd;
+MODULE_SCOPE CompileProc TclCompileInfoExistsCmd;
+MODULE_SCOPE CompileProc TclCompileInfoLevelCmd;
+MODULE_SCOPE CompileProc TclCompileInfoObjectClassCmd;
+MODULE_SCOPE CompileProc TclCompileInfoObjectIsACmd;
+MODULE_SCOPE CompileProc TclCompileInfoObjectNamespaceCmd;
+MODULE_SCOPE CompileProc TclCompileIncrCmd;
+MODULE_SCOPE CompileProc TclCompileLappendCmd;
+MODULE_SCOPE CompileProc TclCompileLassignCmd;
+MODULE_SCOPE CompileProc TclCompileLindexCmd;
+MODULE_SCOPE CompileProc TclCompileLinsertCmd;
+MODULE_SCOPE CompileProc TclCompileListCmd;
+MODULE_SCOPE CompileProc TclCompileLlengthCmd;
+MODULE_SCOPE CompileProc TclCompileLmapCmd;
+MODULE_SCOPE CompileProc TclCompileLrangeCmd;
+MODULE_SCOPE CompileProc TclCompileLreplaceCmd;
+MODULE_SCOPE CompileProc TclCompileLsetCmd;
+MODULE_SCOPE CompileProc TclCompileNamespaceCodeCmd;
+MODULE_SCOPE CompileProc TclCompileNamespaceCurrentCmd;
+MODULE_SCOPE CompileProc TclCompileNamespaceOriginCmd;
+MODULE_SCOPE CompileProc TclCompileNamespaceQualifiersCmd;
+MODULE_SCOPE CompileProc TclCompileNamespaceTailCmd;
+MODULE_SCOPE CompileProc TclCompileNamespaceUpvarCmd;
+MODULE_SCOPE CompileProc TclCompileNamespaceWhichCmd;
+MODULE_SCOPE CompileProc TclCompileNoOp;
+MODULE_SCOPE CompileProc TclCompileObjectNextCmd;
+MODULE_SCOPE CompileProc TclCompileObjectNextToCmd;
+MODULE_SCOPE CompileProc TclCompileObjectSelfCmd;
+MODULE_SCOPE CompileProc TclCompileRegexpCmd;
+MODULE_SCOPE CompileProc TclCompileRegsubCmd;
+MODULE_SCOPE CompileProc TclCompileReturnCmd;
+MODULE_SCOPE CompileProc TclCompileSetCmd;
+MODULE_SCOPE CompileProc TclCompileStringCatCmd;
+MODULE_SCOPE CompileProc TclCompileStringCmpCmd;
+MODULE_SCOPE CompileProc TclCompileStringEqualCmd;
+MODULE_SCOPE CompileProc TclCompileStringFirstCmd;
+MODULE_SCOPE CompileProc TclCompileStringIndexCmd;
+MODULE_SCOPE CompileProc TclCompileStringIsCmd;
+MODULE_SCOPE CompileProc TclCompileStringLastCmd;
+MODULE_SCOPE CompileProc TclCompileStringLenCmd;
+MODULE_SCOPE CompileProc TclCompileStringMapCmd;
+MODULE_SCOPE CompileProc TclCompileStringMatchCmd;
+MODULE_SCOPE CompileProc TclCompileStringRangeCmd;
+MODULE_SCOPE CompileProc TclCompileStringReplaceCmd;
+MODULE_SCOPE CompileProc TclCompileStringToLowerCmd;
+MODULE_SCOPE CompileProc TclCompileStringToTitleCmd;
+MODULE_SCOPE CompileProc TclCompileStringToUpperCmd;
+MODULE_SCOPE CompileProc TclCompileStringTrimCmd;
+MODULE_SCOPE CompileProc TclCompileStringTrimLCmd;
+MODULE_SCOPE CompileProc TclCompileStringTrimRCmd;
+MODULE_SCOPE CompileProc TclCompileSubstCmd;
+MODULE_SCOPE CompileProc TclCompileSwitchCmd;
+MODULE_SCOPE CompileProc TclCompileTailcallCmd;
+MODULE_SCOPE CompileProc TclCompileThrowCmd;
+MODULE_SCOPE CompileProc TclCompileTryCmd;
+MODULE_SCOPE CompileProc TclCompileUnsetCmd;
+MODULE_SCOPE CompileProc TclCompileUpvarCmd;
+MODULE_SCOPE CompileProc TclCompileVariableCmd;
+MODULE_SCOPE CompileProc TclCompileWhileCmd;
+MODULE_SCOPE CompileProc TclCompileYieldCmd;
+MODULE_SCOPE CompileProc TclCompileYieldToCmd;
+MODULE_SCOPE CompileProc TclCompileBasic0ArgCmd;
+MODULE_SCOPE CompileProc TclCompileBasic1ArgCmd;
+MODULE_SCOPE CompileProc TclCompileBasic2ArgCmd;
+MODULE_SCOPE CompileProc TclCompileBasic3ArgCmd;
+MODULE_SCOPE CompileProc TclCompileBasic0Or1ArgCmd;
+MODULE_SCOPE CompileProc TclCompileBasic1Or2ArgCmd;
+MODULE_SCOPE CompileProc TclCompileBasic2Or3ArgCmd;
+MODULE_SCOPE CompileProc TclCompileBasic0To2ArgCmd;
+MODULE_SCOPE CompileProc TclCompileBasic1To3ArgCmd;
+MODULE_SCOPE CompileProc TclCompileBasicMin0ArgCmd;
+MODULE_SCOPE CompileProc TclCompileBasicMin1ArgCmd;
+MODULE_SCOPE CompileProc TclCompileBasicMin2ArgCmd;
+
+MODULE_SCOPE Tcl_ObjCmdProc TclInvertOpCmd;
+MODULE_SCOPE CompileProc TclCompileInvertOpCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNotOpCmd;
+MODULE_SCOPE CompileProc TclCompileNotOpCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclAddOpCmd;
+MODULE_SCOPE CompileProc TclCompileAddOpCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclMulOpCmd;
+MODULE_SCOPE CompileProc TclCompileMulOpCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclAndOpCmd;
+MODULE_SCOPE CompileProc TclCompileAndOpCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclOrOpCmd;
+MODULE_SCOPE CompileProc TclCompileOrOpCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclXorOpCmd;
+MODULE_SCOPE CompileProc TclCompileXorOpCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclPowOpCmd;
+MODULE_SCOPE CompileProc TclCompilePowOpCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclLshiftOpCmd;
+MODULE_SCOPE CompileProc TclCompileLshiftOpCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclRshiftOpCmd;
+MODULE_SCOPE CompileProc TclCompileRshiftOpCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclModOpCmd;
+MODULE_SCOPE CompileProc TclCompileModOpCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNeqOpCmd;
+MODULE_SCOPE CompileProc TclCompileNeqOpCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclStrneqOpCmd;
+MODULE_SCOPE CompileProc TclCompileStrneqOpCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclInOpCmd;
+MODULE_SCOPE CompileProc TclCompileInOpCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNiOpCmd;
+MODULE_SCOPE CompileProc TclCompileNiOpCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclMinusOpCmd;
+MODULE_SCOPE CompileProc TclCompileMinusOpCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclDivOpCmd;
+MODULE_SCOPE CompileProc TclCompileDivOpCmd;
+MODULE_SCOPE CompileProc TclCompileLessOpCmd;
+MODULE_SCOPE CompileProc TclCompileLeqOpCmd;
+MODULE_SCOPE CompileProc TclCompileGreaterOpCmd;
+MODULE_SCOPE CompileProc TclCompileGeqOpCmd;
+MODULE_SCOPE CompileProc TclCompileEqOpCmd;
+MODULE_SCOPE CompileProc TclCompileStreqOpCmd;
+
+MODULE_SCOPE CompileProc TclCompileAssembleCmd;
+
+/*
+ * Functions defined in generic/tclVar.c and currently exported only for use
+ * by the bytecode compiler and engine. Some of these could later be placed in
+ * the public interface.
+ */
+
+MODULE_SCOPE Var *	TclObjLookupVarEx(Tcl_Interp * interp,
+			    Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr, int flags,
+			    const char *msg, int createPart1,
+			    int createPart2, Var **arrayPtrPtr);
+MODULE_SCOPE Var *	TclLookupArrayElement(Tcl_Interp *interp,
+			    Tcl_Obj *arrayNamePtr, Tcl_Obj *elNamePtr,
+			    int flags, const char *msg,
+			    int createPart1, int createPart2,
+			    Var *arrayPtr, int index);
+MODULE_SCOPE Tcl_Obj *	TclPtrGetVarIdx(Tcl_Interp *interp,
+			    Var *varPtr, Var *arrayPtr, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, int flags, int index);
+MODULE_SCOPE Tcl_Obj *	TclPtrSetVarIdx(Tcl_Interp *interp,
+			    Var *varPtr, Var *arrayPtr, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, Tcl_Obj *newValuePtr,
+			    int flags, int index);
+MODULE_SCOPE Tcl_Obj *	TclPtrIncrObjVarIdx(Tcl_Interp *interp,
+			    Var *varPtr, Var *arrayPtr, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, Tcl_Obj *incrPtr,
+			    int flags, int index);
+MODULE_SCOPE int	TclPtrObjMakeUpvarIdx(Tcl_Interp *interp,
+			    Var *otherPtr, Tcl_Obj *myNamePtr, int myFlags,
+			    int index);
+MODULE_SCOPE int	TclPtrUnsetVarIdx(Tcl_Interp *interp, Var *varPtr,
+			    Var *arrayPtr, Tcl_Obj *part1Ptr,
+			    Tcl_Obj *part2Ptr, int flags,
+			    int index);
+MODULE_SCOPE void	TclInvalidateNsPath(Namespace *nsPtr);
+MODULE_SCOPE void	TclFindArrayPtrElements(Var *arrayPtr,
+			    Tcl_HashTable *tablePtr);
+
+/*
+ * The new extended interface to the variable traces.
+ */
+
+MODULE_SCOPE int	TclObjCallVarTraces(Interp *iPtr, Var *arrayPtr,
+			    Var *varPtr, Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr,
+			    int flags, int leaveErrMsg, int index);
+
+/*
+ * So tclObj.c and tclDictObj.c can share these implementations.
+ */
+
+MODULE_SCOPE int	TclCompareObjKeys(void *keyPtr, Tcl_HashEntry *hPtr);
+MODULE_SCOPE void	TclFreeObjEntry(Tcl_HashEntry *hPtr);
+MODULE_SCOPE unsigned	TclHashObjKey(Tcl_HashTable *tablePtr, void *keyPtr);
+
+MODULE_SCOPE int	TclFullFinalizationRequested(void);
+
+/*
+ * Utility routines for encoding index values as integers. Used by both
+ * some of the command compilers and by [lsort] and [lsearch].
+ */
+
+MODULE_SCOPE int	TclIndexEncode(Tcl_Interp *interp, Tcl_Obj *objPtr,
+			    int before, int after, int *indexPtr);
+MODULE_SCOPE int	TclIndexDecode(int encoded, int endValue);
+
+MODULE_SCOPE void	TclBN_s_mp_reverse(unsigned char *s, size_t len);
+
+/* Constants used in index value encoding routines. */
+#define TCL_INDEX_END           (-2)
+#define TCL_INDEX_BEFORE        (-1)
+#define TCL_INDEX_START         (0)
+#define TCL_INDEX_AFTER         (INT_MAX)
+
+/*
+ *----------------------------------------------------------------
+ * Macros used by the Tcl core to create and release Tcl objects.
+ * TclNewObj(objPtr) creates a new object denoting an empty string.
+ * TclDecrRefCount(objPtr) decrements the object's reference count, and frees
+ * the object if its reference count is zero. These macros are inline versions
+ * of Tcl_NewObj() and Tcl_DecrRefCount(). Notice that the names differ in not
+ * having a "_" after the "Tcl". Notice also that these macros reference their
+ * argument more than once, so you should avoid calling them with an
+ * expression that is expensive to compute or has side effects. The ANSI C
+ * "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE void	TclNewObj(Tcl_Obj *objPtr);
+ * MODULE_SCOPE void	TclDecrRefCount(Tcl_Obj *objPtr);
+ *
+ * These macros are defined in terms of two macros that depend on memory
+ * allocator in use: TclAllocObjStorage, TclFreeObjStorage. They are defined
+ * below.
+ *----------------------------------------------------------------
+ */
+
+/*
+ * DTrace object allocation probe macros.
+ */
+
+#ifdef USE_DTRACE
+#ifndef _TCLDTRACE_H
+#include "tclDTrace.h"
+#endif
+#define	TCL_DTRACE_OBJ_CREATE(objPtr)	TCL_OBJ_CREATE(objPtr)
+#define	TCL_DTRACE_OBJ_FREE(objPtr)	TCL_OBJ_FREE(objPtr)
+#else /* USE_DTRACE */
+#define	TCL_DTRACE_OBJ_CREATE(objPtr)	{}
+#define	TCL_DTRACE_OBJ_FREE(objPtr)	{}
+#endif /* USE_DTRACE */
+
+#ifdef TCL_COMPILE_STATS
+#  define TclIncrObjsAllocated() \
+    tclObjsAlloced++
+#  define TclIncrObjsFreed() \
+    tclObjsFreed++
+#else
+#  define TclIncrObjsAllocated()
+#  define TclIncrObjsFreed()
+#endif /* TCL_COMPILE_STATS */
+
+#  define TclAllocObjStorage(objPtr)		\
+	TclAllocObjStorageEx(NULL, (objPtr))
+
+#  define TclFreeObjStorage(objPtr)		\
+	TclFreeObjStorageEx(NULL, (objPtr))
+
+#ifndef TCL_MEM_DEBUG
+# define TclNewObj(objPtr) \
+    TclIncrObjsAllocated(); \
+    TclAllocObjStorage(objPtr); \
+    (objPtr)->refCount = 0; \
+    (objPtr)->bytes    = tclEmptyStringRep; \
+    (objPtr)->length   = 0; \
+    (objPtr)->typePtr  = NULL; \
+    TCL_DTRACE_OBJ_CREATE(objPtr)
+
+/*
+ * Invalidate the string rep first so we can use the bytes value for our
+ * pointer chain, and signal an obj deletion (as opposed to shimmering) with
+ * 'length == -1'.
+ * Use empty 'if ; else' to handle use in unbraced outer if/else conditions.
+ */
+
+# define TclDecrRefCount(objPtr) \
+    if ((objPtr)->refCount-- > 1) ; else { \
+	if (!(objPtr)->typePtr || !(objPtr)->typePtr->freeIntRepProc) { \
+	    TCL_DTRACE_OBJ_FREE(objPtr); \
+	    if ((objPtr)->bytes \
+		    && ((objPtr)->bytes != tclEmptyStringRep)) { \
+		ckfree((char *)(objPtr)->bytes); \
+	    } \
+	    (objPtr)->length = -1; \
+	    TclFreeObjStorage(objPtr); \
+	    TclIncrObjsFreed(); \
+	} else { \
+	    TclFreeObj(objPtr); \
+	} \
+    }
+
+#if defined(PURIFY)
+
+/*
+ * The PURIFY mode is like the regular mode, but instead of doing block
+ * Tcl_Obj allocation and keeping a freed list for efficiency, it always
+ * allocates and frees a single Tcl_Obj so that tools like Purify can better
+ * track memory leaks.
+ */
+
+#  define TclAllocObjStorageEx(interp, objPtr) \
+	(objPtr) = (Tcl_Obj *)ckalloc(sizeof(Tcl_Obj))
+
+#  define TclFreeObjStorageEx(interp, objPtr) \
+	ckfree((char *)(objPtr))
+
+#undef USE_THREAD_ALLOC
+#undef USE_TCLALLOC
+#elif defined(TCL_THREADS) && defined(USE_THREAD_ALLOC)
+
+/*
+ * The TCL_THREADS mode is like the regular mode but allocates Tcl_Obj's from
+ * per-thread caches.
+ */
+
+MODULE_SCOPE Tcl_Obj *	TclThreadAllocObj(void);
+MODULE_SCOPE void	TclThreadFreeObj(Tcl_Obj *);
+MODULE_SCOPE Tcl_Mutex *TclpNewAllocMutex(void);
+MODULE_SCOPE void	TclFreeAllocCache(void *);
+MODULE_SCOPE void *	TclpGetAllocCache(void);
+MODULE_SCOPE void	TclpSetAllocCache(void *);
+MODULE_SCOPE void	TclpFreeAllocMutex(Tcl_Mutex *mutex);
+MODULE_SCOPE void	TclpFreeAllocCache(void *);
+
+/*
+ * These macros need to be kept in sync with the code of TclThreadAllocObj()
+ * and TclThreadFreeObj().
+ *
+ * Note that the optimiser should resolve the case (interp==NULL) at compile
+ * time.
+ */
+
+#  define ALLOC_NOBJHIGH 1200
+
+#  define TclAllocObjStorageEx(interp, objPtr)				\
+    do {								\
+	AllocCache *cachePtr;						\
+	if (((interp) == NULL) ||					\
+		((cachePtr = ((Interp *)(interp))->allocCache),		\
+			(cachePtr->numObjects == 0))) {			\
+	    (objPtr) = TclThreadAllocObj();				\
+	} else {							\
+	    (objPtr) = cachePtr->firstObjPtr;				\
+	    cachePtr->firstObjPtr = (Tcl_Obj *)(objPtr)->internalRep.twoPtrValue.ptr1; \
+	    --cachePtr->numObjects;					\
+	}								\
+    } while (0)
+
+#  define TclFreeObjStorageEx(interp, objPtr)				\
+    do {								\
+	AllocCache *cachePtr;						\
+	if (((interp) == NULL) ||					\
+		((cachePtr = ((Interp *)(interp))->allocCache),		\
+			((cachePtr->numObjects == 0) ||			\
+			(cachePtr->numObjects >= ALLOC_NOBJHIGH)))) {	\
+	    TclThreadFreeObj(objPtr);					\
+	} else {							\
+	    (objPtr)->internalRep.twoPtrValue.ptr1 = cachePtr->firstObjPtr; \
+	    cachePtr->firstObjPtr = objPtr;				\
+	    ++cachePtr->numObjects;					\
+	}								\
+    } while (0)
+
+#else /* not PURIFY or USE_THREAD_ALLOC */
+
+#if defined(USE_TCLALLOC) && USE_TCLALLOC
+    MODULE_SCOPE void TclFinalizeAllocSubsystem();
+    MODULE_SCOPE void TclInitAlloc();
+#else
+#   define USE_TCLALLOC 0
+#endif
+
+#ifdef TCL_THREADS
+/* declared in tclObj.c */
+MODULE_SCOPE Tcl_Mutex	tclObjMutex;
+#endif
+
+#  define TclAllocObjStorageEx(interp, objPtr) \
+    do {								\
+	Tcl_MutexLock(&tclObjMutex);					\
+	if (tclFreeObjList == NULL) {					\
+	    TclAllocateFreeObjects();					\
+	}								\
+	(objPtr) = tclFreeObjList;					\
+	tclFreeObjList = (Tcl_Obj *)					\
+		tclFreeObjList->internalRep.twoPtrValue.ptr1;		\
+	Tcl_MutexUnlock(&tclObjMutex);					\
+    } while (0)
+
+#  define TclFreeObjStorageEx(interp, objPtr) \
+    do {							       \
+	Tcl_MutexLock(&tclObjMutex);				       \
+	(objPtr)->internalRep.twoPtrValue.ptr1 = (void *) tclFreeObjList; \
+	tclFreeObjList = (objPtr);				       \
+	Tcl_MutexUnlock(&tclObjMutex);				       \
+    } while (0)
+#endif
+
+#else /* TCL_MEM_DEBUG */
+MODULE_SCOPE void	TclDbInitNewObj(Tcl_Obj *objPtr, const char *file,
+			    int line);
+
+# define TclDbNewObj(objPtr, file, line) \
+    do { \
+	TclIncrObjsAllocated();						\
+	(objPtr) = (Tcl_Obj *)						\
+		Tcl_DbCkalloc(sizeof(Tcl_Obj), (file), (line));		\
+	TclDbInitNewObj((objPtr), (file), (line));			\
+	TCL_DTRACE_OBJ_CREATE(objPtr);					\
+    } while (0)
+
+# define TclNewObj(objPtr) \
+    TclDbNewObj(objPtr, __FILE__, __LINE__);
+
+# define TclDecrRefCount(objPtr) \
+    Tcl_DbDecrRefCount(objPtr, __FILE__, __LINE__)
+
+# define TclNewListObjDirect(objc, objv) \
+    TclDbNewListObjDirect(objc, objv, __FILE__, __LINE__)
+
+#undef USE_THREAD_ALLOC
+#endif /* TCL_MEM_DEBUG */
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to set a Tcl_Obj's string representation to a
+ * copy of the "len" bytes starting at "bytePtr". This code works even if the
+ * byte array contains NULLs as long as the length is correct. Because "len"
+ * is referenced multiple times, it should be as simple an expression as
+ * possible. The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void TclInitStringRep(Tcl_Obj *objPtr, char *bytePtr, int len);
+ *
+ * This macro should only be called on an unshared objPtr where
+ *  objPtr->typePtr->freeIntRepProc == NULL
+ *----------------------------------------------------------------
+ */
+
+#define TclInitStringRep(objPtr, bytePtr, len) \
+    if ((len) == 0) { \
+	(objPtr)->bytes	 = tclEmptyStringRep; \
+	(objPtr)->length = 0; \
+    } else { \
+	(objPtr)->bytes = (char *) ckalloc((unsigned int)(len) + 1U); \
+	memcpy((objPtr)->bytes, (bytePtr), (len)); \
+	(objPtr)->bytes[len] = '\0'; \
+	(objPtr)->length = (len); \
+    }
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to get the string representation's byte array
+ * pointer from a Tcl_Obj. This is an inline version of Tcl_GetString(). The
+ * macro's expression result is the string rep's byte pointer which might be
+ * NULL. The bytes referenced by this pointer must not be modified by the
+ * caller. The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE char *	TclGetString(Tcl_Obj *objPtr);
+ *----------------------------------------------------------------
+ */
+
+#define TclGetString(objPtr) \
+    ((objPtr)->bytes? (objPtr)->bytes : Tcl_GetString(objPtr))
+
+#define TclGetStringFromObj(objPtr, lenPtr) \
+    ((objPtr)->bytes \
+	    ? (*(lenPtr) = (objPtr)->length, (objPtr)->bytes)	\
+	    : Tcl_GetStringFromObj((objPtr), (lenPtr)))
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to clean out an object's internal
+ * representation. Does not actually reset the rep's bytes. The ANSI C
+ * "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void	TclFreeIntRep(Tcl_Obj *objPtr);
+ *----------------------------------------------------------------
+ */
+
+#define TclFreeIntRep(objPtr) \
+    if ((objPtr)->typePtr != NULL) { \
+	if ((objPtr)->typePtr->freeIntRepProc != NULL) { \
+	    (objPtr)->typePtr->freeIntRepProc(objPtr); \
+	} \
+	(objPtr)->typePtr = NULL; \
+    }
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to clean out an object's string representation.
+ * The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void	TclInvalidateStringRep(Tcl_Obj *objPtr);
+ *----------------------------------------------------------------
+ */
+
+#define TclInvalidateStringRep(objPtr) \
+    do { \
+	Tcl_Obj *_isobjPtr = (Tcl_Obj *)(objPtr); \
+	if (_isobjPtr->bytes != NULL) { \
+	    if (_isobjPtr->bytes != tclEmptyStringRep) { \
+		ckfree((char *)_isobjPtr->bytes); \
+	    } \
+	    _isobjPtr->bytes = NULL; \
+	} \
+    } while (0)
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to test whether an object has a
+ * string representation (or is a 'pure' internal value).
+ * The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE int	TclHasStringRep(Tcl_Obj *objPtr);
+ *----------------------------------------------------------------
+ */
+
+#define TclHasStringRep(objPtr) \
+    ((objPtr)->bytes != NULL)
+
+/*
+ *----------------------------------------------------------------
+ * Macros used by the Tcl core to grow Tcl_Token arrays. They use the same
+ * growth algorithm as used in tclStringObj.c for growing strings. The ANSI C
+ * "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void	TclGrowTokenArray(Tcl_Token *tokenPtr, int used,
+ *				int available, int append,
+ *				Tcl_Token *staticPtr);
+ * MODULE_SCOPE void	TclGrowParseTokenArray(Tcl_Parse *parsePtr,
+ *				int append);
+ *----------------------------------------------------------------
+ */
+
+/* General tuning for minimum growth in Tcl growth algorithms */
+#ifndef TCL_MIN_GROWTH
+#  ifdef TCL_GROWTH_MIN_ALLOC
+     /* Support for any legacy tuners */
+#    define TCL_MIN_GROWTH TCL_GROWTH_MIN_ALLOC
+#  else
+#    define TCL_MIN_GROWTH 1024
+#  endif
+#endif
+
+/* Token growth tuning, default to the general value. */
+#ifndef TCL_MIN_TOKEN_GROWTH
+#define TCL_MIN_TOKEN_GROWTH TCL_MIN_GROWTH/sizeof(Tcl_Token)
+#endif
+
+#define TCL_MAX_TOKENS (int)(UINT_MAX / sizeof(Tcl_Token))
+#define TclGrowTokenArray(tokenPtr, used, available, append, staticPtr)	\
+    do {								\
+	int _needed = (used) + (append);					\
+	if (_needed > TCL_MAX_TOKENS) {					\
+	    Tcl_Panic("max # of tokens for a Tcl parse (%d) exceeded",	\
+		    TCL_MAX_TOKENS);					\
+	}								\
+	if (_needed > (available)) {					\
+	    int allocated = 2 * _needed;					\
+	    Tcl_Token *oldPtr = (tokenPtr);				\
+	    Tcl_Token *newPtr;						\
+	    if (oldPtr == (staticPtr)) {				\
+		oldPtr = NULL;						\
+	    }								\
+	    if (allocated > TCL_MAX_TOKENS) {				\
+		allocated = TCL_MAX_TOKENS;				\
+	    }								\
+	    newPtr = (Tcl_Token *) attemptckrealloc((char *) oldPtr,	\
+		    allocated * sizeof(Tcl_Token));	\
+	    if (newPtr == NULL) {					\
+		allocated = _needed + (append) + TCL_MIN_TOKEN_GROWTH;	\
+		if (allocated > TCL_MAX_TOKENS) {			\
+		    allocated = TCL_MAX_TOKENS;				\
+		}							\
+		newPtr = (Tcl_Token *) ckrealloc((char *) oldPtr,	\
+			allocated * sizeof(Tcl_Token)); \
+	    }								\
+	    (available) = allocated;					\
+	    if (oldPtr == NULL) {					\
+		memcpy(newPtr, staticPtr,				\
+			(used) * sizeof(Tcl_Token));		\
+	    }								\
+	    (tokenPtr) = newPtr;					\
+	}								\
+    } while (0)
+
+#define TclGrowParseTokenArray(parsePtr, append)			\
+    TclGrowTokenArray((parsePtr)->tokenPtr, (parsePtr)->numTokens,	\
+	    (parsePtr)->tokensAvailable, (append),			\
+	    (parsePtr)->staticTokens)
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core get a unicode char from a utf string. It checks
+ * to see if we have a one-byte utf char before calling the real
+ * Tcl_UtfToUniChar, as this will save a lot of time for primarily ASCII
+ * string handling. The macro's expression result is 1 for the 1-byte case or
+ * the result of Tcl_UtfToUniChar. The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE int	TclUtfToUniChar(const char *string, Tcl_UniChar *ch);
+ *----------------------------------------------------------------
+ */
+
+#define TclUtfToUniChar(str, chPtr) \
+	(((UCHAR(*(str))) < 0x80) ?		\
+	    ((*(chPtr) = UCHAR(*(str))), 1)	\
+	    : Tcl_UtfToUniChar(str, chPtr))
+
+/*
+ *----------------------------------------------------------------
+ * Macro counterpart of the Tcl_NumUtfChars() function. To be used in speed-
+ * -sensitive points where it pays to avoid a function call in the common case
+ * of counting along a string of all one-byte characters.  The ANSI C
+ * "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void	TclNumUtfChars(int numChars, const char *bytes,
+ *				int numBytes);
+ *----------------------------------------------------------------
+ */
+
+#define TclNumUtfChars(numChars, bytes, numBytes) \
+    do { \
+	int _count, _i = (numBytes); \
+	unsigned char *_str = (unsigned char *) (bytes); \
+	while (_i && (*_str < 0xC0)) { _i--; _str++; } \
+	_count = (numBytes) - _i; \
+	if (_i) { \
+	    _count += Tcl_NumUtfChars((bytes) + _count, _i); \
+	} \
+	(numChars) = _count; \
+    } while (0);
+
+#define TclUtfPrev(src, start) \
+	(((src) < (start)+2) ? (start) : \
+	(UCHAR(*((src) - 1))) < 0x80 ? (src)-1 : \
+	Tcl_UtfPrev(src, start))
+
+/*
+ *----------------------------------------------------------------
+ * Macro that encapsulates the logic that determines when it is safe to
+ * interpret a string as a byte array directly. In summary, the object must be
+ * a byte array and must not have a string representation (as the operations
+ * that it is used in are defined on strings, not byte arrays). Theoretically
+ * it is possible to also be efficient in the case where the object's bytes
+ * field is filled by generation from the byte array (c.f. list canonicality)
+ * but we don't do that at the moment since this is purely about efficiency.
+ * The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE int	TclIsPureByteArray(Tcl_Obj *objPtr);
+ *----------------------------------------------------------------
+ */
+
+#define TclIsPureByteArray(objPtr) \
+	(((objPtr)->typePtr==&tclByteArrayType) && ((objPtr)->bytes==NULL))
+#define TclIsPureDict(objPtr) \
+	(((objPtr)->bytes==NULL) && ((objPtr)->typePtr==&tclDictType))
+
+#define TclIsPureList(objPtr) \
+	(((objPtr)->bytes==NULL) && ((objPtr)->typePtr==&tclListType))
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to compare Unicode strings. On big-endian
+ * systems we can use the more efficient memcmp, but this would not be
+ * lexically correct on little-endian systems. The ANSI C "prototype" for
+ * this macro is:
+ *
+ * MODULE_SCOPE int	TclUniCharNcmp(const void *cs,
+ *			    const void *ct, size_t n);
+ *----------------------------------------------------------------
+ */
+
+#if defined(WORDS_BIGENDIAN) && (TCL_UTF_MAX != 4)
+#   define TclUniCharNcmp(cs,ct,n) memcmp((cs),(ct),(n)*sizeof(Tcl_UniChar))
+#endif /* WORDS_BIGENDIAN */
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to increment a namespace's export epoch
+ * counter. The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void	TclInvalidateNsCmdLookup(Namespace *nsPtr);
+ *----------------------------------------------------------------
+ */
+
+#define TclInvalidateNsCmdLookup(nsPtr) \
+    if ((nsPtr)->numExportPatterns) {		\
+	(nsPtr)->exportLookupEpoch++;		\
+    }						\
+    if ((nsPtr)->commandPathLength) {		\
+	(nsPtr)->cmdRefEpoch++;			\
+    }
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * Core procedure added to libtommath for bignum manipulation.
+ *
+ *----------------------------------------------------------------------
+ */
+
+MODULE_SCOPE Tcl_PackageInitProc TclTommath_Init;
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * External (platform specific) initialization routine, these declarations
+ * explicitly don't use EXTERN since this code does not get compiled into the
+ * library:
+ *
+ *----------------------------------------------------------------------
+ */
+
+MODULE_SCOPE Tcl_PackageInitProc TclplatformtestInit;
+MODULE_SCOPE Tcl_PackageInitProc TclObjTest_Init;
+MODULE_SCOPE Tcl_PackageInitProc TclThread_Init;
+MODULE_SCOPE Tcl_PackageInitProc Procbodytest_Init;
+MODULE_SCOPE Tcl_PackageInitProc Procbodytest_SafeInit;
+
+/*
+ *----------------------------------------------------------------
+ * Macro used by the Tcl core to check whether a pattern has any characters
+ * special to [string match]. The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE int	TclMatchIsTrivial(const char *pattern);
+ *----------------------------------------------------------------
+ */
+
+#define TclMatchIsTrivial(pattern) \
+    (strpbrk((pattern), "*[?\\") == NULL)
+
+/*
+ *----------------------------------------------------------------
+ * Macros used by the Tcl core to set a Tcl_Obj's numeric representation
+ * avoiding the corresponding function calls in time critical parts of the
+ * core. They should only be called on unshared objects. The ANSI C
+ * "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE void	TclSetIntObj(Tcl_Obj *objPtr, int intValue);
+ * MODULE_SCOPE void	TclSetLongObj(Tcl_Obj *objPtr, long longValue);
+ * MODULE_SCOPE void	TclSetBooleanObj(Tcl_Obj *objPtr, int intValue);
+ * MODULE_SCOPE void	TclSetWideIntObj(Tcl_Obj *objPtr, Tcl_WideInt w);
+ * MODULE_SCOPE void	TclSetDoubleObj(Tcl_Obj *objPtr, double d);
+ *----------------------------------------------------------------
+ */
+
+#define TclSetLongObj(objPtr, i) \
+    do {						\
+	TclInvalidateStringRep(objPtr);			\
+	TclFreeIntRep(objPtr);				\
+	(objPtr)->internalRep.longValue = (long)(i);	\
+	(objPtr)->typePtr = &tclIntType;		\
+    } while (0)
+
+#define TclSetIntObj(objPtr, l) \
+    TclSetLongObj(objPtr, l)
+
+/*
+ * NOTE: There is to be no such thing as a "pure" boolean. Boolean values set
+ * programmatically go straight to being "int" Tcl_Obj's, with value 0 or 1.
+ * The only "boolean" Tcl_Obj's shall be those holding the cached boolean
+ * value of strings like: "yes", "no", "true", "false", "on", "off".
+ */
+
+#define TclSetBooleanObj(objPtr, b) \
+    TclSetLongObj(objPtr, (b)!=0);
+
+#ifndef TCL_WIDE_INT_IS_LONG
+#define TclSetWideIntObj(objPtr, w) \
+    do {							\
+	TclInvalidateStringRep(objPtr);				\
+	TclFreeIntRep(objPtr);					\
+	(objPtr)->internalRep.wideValue = (Tcl_WideInt)(w);	\
+	(objPtr)->typePtr = &tclWideIntType;			\
+    } while (0)
+#endif
+
+#define TclSetDoubleObj(objPtr, d) \
+    do {							\
+	TclInvalidateStringRep(objPtr);				\
+	TclFreeIntRep(objPtr);					\
+	(objPtr)->internalRep.doubleValue = (double)(d);	\
+	(objPtr)->typePtr = &tclDoubleType;			\
+    } while (0)
+
+/*
+ *----------------------------------------------------------------
+ * Macros used by the Tcl core to create and initialise objects of standard
+ * types, avoiding the corresponding function calls in time critical parts of
+ * the core. The ANSI C "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE void	TclNewIntObj(Tcl_Obj *objPtr, int i);
+ * MODULE_SCOPE void	TclNewLongObj(Tcl_Obj *objPtr, long l);
+ * MODULE_SCOPE void	TclNewBooleanObj(Tcl_Obj *objPtr, int b);
+ * MODULE_SCOPE void	TclNewWideObj(Tcl_Obj *objPtr, Tcl_WideInt w);
+ * MODULE_SCOPE void	TclNewDoubleObj(Tcl_Obj *objPtr, double d);
+ * MODULE_SCOPE void	TclNewStringObj(Tcl_Obj *objPtr, char *s, int len);
+ * MODULE_SCOPE void	TclNewLiteralStringObj(Tcl_Obj*objPtr, char*sLiteral);
+ *
+ *----------------------------------------------------------------
+ */
+
+#ifndef TCL_MEM_DEBUG
+#define TclNewLongObj(objPtr, i) \
+    do {						\
+	TclIncrObjsAllocated();				\
+	TclAllocObjStorage(objPtr);			\
+	(objPtr)->refCount = 0;				\
+	(objPtr)->bytes = NULL;				\
+	(objPtr)->internalRep.longValue = (long)(i);	\
+	(objPtr)->typePtr = &tclIntType;		\
+	TCL_DTRACE_OBJ_CREATE(objPtr);			\
+    } while (0)
+
+#define TclNewIntObj(objPtr, l) \
+    TclNewLongObj(objPtr, l)
+
+/*
+ * NOTE: There is to be no such thing as a "pure" boolean.
+ * See comment above TclSetBooleanObj macro above.
+ */
+#define TclNewBooleanObj(objPtr, b) \
+    TclNewLongObj((objPtr), (b)!=0)
+
+#define TclNewDoubleObj(objPtr, d) \
+    do {							\
+	TclIncrObjsAllocated();					\
+	TclAllocObjStorage(objPtr);				\
+	(objPtr)->refCount = 0;					\
+	(objPtr)->bytes = NULL;					\
+	(objPtr)->internalRep.doubleValue = (double)(d);	\
+	(objPtr)->typePtr = &tclDoubleType;			\
+	TCL_DTRACE_OBJ_CREATE(objPtr);				\
+    } while (0)
+
+#define TclNewStringObj(objPtr, s, len) \
+    do {							\
+	TclIncrObjsAllocated();					\
+	TclAllocObjStorage(objPtr);				\
+	(objPtr)->refCount = 0;					\
+	TclInitStringRep((objPtr), (s), (len));			\
+	(objPtr)->typePtr = NULL;				\
+	TCL_DTRACE_OBJ_CREATE(objPtr);				\
+    } while (0)
+
+#else /* TCL_MEM_DEBUG */
+#define TclNewIntObj(objPtr, i) \
+    (objPtr) = Tcl_NewIntObj(i)
+
+#define TclNewLongObj(objPtr, l) \
+    (objPtr) = Tcl_NewLongObj(l)
+
+#define TclNewBooleanObj(objPtr, b) \
+    (objPtr) = Tcl_NewBooleanObj(b)
+
+#define TclNewDoubleObj(objPtr, d) \
+    (objPtr) = Tcl_NewDoubleObj(d)
+
+#define TclNewStringObj(objPtr, s, len) \
+    (objPtr) = Tcl_NewStringObj((s), (len))
+#endif /* TCL_MEM_DEBUG */
+
+/*
+ * The sLiteral argument *must* be a string literal; the incantation with
+ * sizeof(sLiteral "") will fail to compile otherwise.
+ */
+#define TclNewLiteralStringObj(objPtr, sLiteral) \
+    TclNewStringObj((objPtr), (sLiteral), sizeof(sLiteral "") - 1)
+
+/*
+ *----------------------------------------------------------------
+ * Convenience macros for DStrings.
+ * The ANSI C "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE char * TclDStringAppendLiteral(Tcl_DString *dsPtr,
+ *			const char *sLiteral);
+ * MODULE_SCOPE void   TclDStringClear(Tcl_DString *dsPtr);
+ */
+
+#define TclDStringAppendLiteral(dsPtr, sLiteral) \
+    Tcl_DStringAppend((dsPtr), (sLiteral), sizeof(sLiteral "") - 1)
+#define TclDStringClear(dsPtr) \
+    Tcl_DStringSetLength((dsPtr), 0)
+
+/*
+ *----------------------------------------------------------------
+ * Macros used by the Tcl core to test for some special double values.
+ * The ANSI C "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE int	TclIsInfinite(double d);
+ * MODULE_SCOPE int	TclIsNaN(double d);
+ */
+
+#ifdef _MSC_VER
+#    define TclIsInfinite(d)	(!(_finite((d))))
+#    define TclIsNaN(d)		(_isnan((d)))
+#else
+#    define TclIsInfinite(d)	((d) > DBL_MAX || (d) < -DBL_MAX)
+#    ifdef NO_ISNAN
+#	 define TclIsNaN(d)	((d) != (d))
+#    else
+#	 define TclIsNaN(d)	(isnan(d))
+#    endif
+#endif
+
+/*
+ * ----------------------------------------------------------------------
+ * Macro to use to find the offset of a field in a structure. Computes number
+ * of bytes from beginning of structure to a given field.
+ */
+
+#ifdef offsetof
+#define TclOffset(type, field) ((int) offsetof(type, field))
+#else
+#define TclOffset(type, field) ((int) ((char *) &((type *) 0)->field))
+#endif
+
+/*
+ *----------------------------------------------------------------
+ * Inline version of Tcl_GetCurrentNamespace and Tcl_GetGlobalNamespace.
+ */
+
+#define TclGetCurrentNamespace(interp) \
+    (Tcl_Namespace *) ((Interp *)(interp))->varFramePtr->nsPtr
+
+#define TclGetGlobalNamespace(interp) \
+    (Tcl_Namespace *) ((Interp *)(interp))->globalNsPtr
+
+/*
+ *----------------------------------------------------------------
+ * Inline version of TclCleanupCommand; still need the function as it is in
+ * the internal stubs, but the core can use the macro instead.
+ */
+
+#define TclCleanupCommandMacro(cmdPtr)		\
+    do {					\
+	if ((cmdPtr)->refCount-- <= 1) {	\
+	    ckfree(cmdPtr);			\
+	}					\
+    } while (0)
+
+/*
+ *----------------------------------------------------------------
+ * Inline versions of Tcl_LimitReady() and Tcl_LimitExceeded to limit number
+ * of calls out of the critical path. Note that this code isn't particularly
+ * readable; the non-inline version (in tclInterp.c) is much easier to
+ * understand. Note also that these macros takes different args (iPtr->limit)
+ * to the non-inline version.
+ */
+
+#define TclLimitExceeded(limit) ((limit).exceeded != 0)
+
+#define TclLimitReady(limit)						\
+    (((limit).active == 0) ? 0 :					\
+    (++(limit).granularityTicker,					\
+    ((((limit).active & TCL_LIMIT_COMMANDS) &&				\
+	    (((limit).cmdGranularity == 1) ||				\
+	    ((limit).granularityTicker % (limit).cmdGranularity == 0)))	\
+	    ? 1 :							\
+    (((limit).active & TCL_LIMIT_TIME) &&				\
+	    (((limit).timeGranularity == 1) ||				\
+	    ((limit).granularityTicker % (limit).timeGranularity == 0)))\
+	    ? 1 : 0)))
+
+/*
+ * Compile-time assertions: these produce a compile time error if the
+ * expression is not known to be true at compile time. If the assertion is
+ * known to be false, the compiler (or optimizer?) will error out with
+ * "division by zero". If the assertion cannot be evaluated at compile time,
+ * the compiler will error out with "non-static initializer".
+ *
+ * Adapted with permission from
+ * http://www.pixelbeat.org/programming/gcc/static_assert.html
+ */
+
+#define TCL_CT_ASSERT(e) \
+    {enum { ct_assert_value = 1/(!!(e)) };}
+
+/*
+ *----------------------------------------------------------------
+ * Allocator for small structs (<=sizeof(Tcl_Obj)) using the Tcl_Obj pool.
+ * Only checked at compile time.
+ *
+ * ONLY USE FOR CONSTANT nBytes.
+ *
+ * DO NOT LET THEM CROSS THREAD BOUNDARIES
+ *----------------------------------------------------------------
+ */
+
+#define TclSmallAlloc(nbytes, memPtr) \
+    TclSmallAllocEx(NULL, (nbytes), (memPtr))
+
+#define TclSmallFree(memPtr) \
+    TclSmallFreeEx(NULL, (memPtr))
+
+#ifndef TCL_MEM_DEBUG
+#define TclSmallAllocEx(interp, nbytes, memPtr) \
+    do {								\
+	Tcl_Obj *_objPtr;						\
+	TCL_CT_ASSERT((nbytes)<=sizeof(Tcl_Obj));			\
+	TclIncrObjsAllocated();						\
+	TclAllocObjStorageEx((interp), (_objPtr));			\
+	*(void **)&(memPtr) = (void *) (_objPtr);			\
+    } while (0)
+
+#define TclSmallFreeEx(interp, memPtr) \
+    do {								\
+	TclFreeObjStorageEx((interp), (Tcl_Obj *)(memPtr));		\
+	TclIncrObjsFreed();						\
+    } while (0)
+
+#else    /* TCL_MEM_DEBUG */
+#define TclSmallAllocEx(interp, nbytes, memPtr) \
+    do {								\
+	Tcl_Obj *_objPtr;						\
+	TCL_CT_ASSERT((nbytes)<=sizeof(Tcl_Obj));			\
+	TclNewObj(_objPtr);						\
+	*(void **)&(memPtr) = (void *)_objPtr;				\
+    } while (0)
+
+#define TclSmallFreeEx(interp, memPtr) \
+    do {								\
+	Tcl_Obj *_objPtr = (Tcl_Obj *)(memPtr);				\
+	_objPtr->bytes = NULL;						\
+	_objPtr->typePtr = NULL;					\
+	_objPtr->refCount = 1;						\
+	TclDecrRefCount(_objPtr);					\
+    } while (0)
+#endif   /* TCL_MEM_DEBUG */
+
+/*
+ * Support for Clang Static Analyzer <http://clang-analyzer.llvm.org>
+ */
+
+#if defined(PURIFY) && defined(__clang__)
+#if __has_feature(attribute_analyzer_noreturn) && \
+	!defined(Tcl_Panic) && defined(Tcl_Panic_TCL_DECLARED)
+void Tcl_Panic(const char *, ...) __attribute__((analyzer_noreturn));
+#endif
+#if !defined(CLANG_ASSERT)
+#include <assert.h>
+#define CLANG_ASSERT(x) assert(x)
+#endif
+#elif !defined(CLANG_ASSERT)
+#define CLANG_ASSERT(x)
+#endif /* PURIFY && __clang__ */
+
+/*
+ *----------------------------------------------------------------
+ * Parameters, structs and macros for the non-recursive engine (NRE)
+ *----------------------------------------------------------------
+ */
+
+#define NRE_USE_SMALL_ALLOC	1  /* Only turn off for debugging purposes. */
+#ifndef NRE_ENABLE_ASSERTS
+#define NRE_ENABLE_ASSERTS	0
+#endif
+
+/*
+ * This is the main data struct for representing NR commands. It is designed
+ * to fit in sizeof(Tcl_Obj) in order to exploit the fastest memory allocator
+ * available.
+ */
+
+typedef struct NRE_callback {
+    Tcl_NRPostProc *procPtr;
+    ClientData data[4];
+    struct NRE_callback *nextPtr;
+} NRE_callback;
+
+#define TOP_CB(iPtr) (((Interp *)(iPtr))->execEnvPtr->callbackPtr)
+
+/*
+ * Inline version of Tcl_NRAddCallback.
+ */
+
+#define TclNRAddCallback(interp,postProcPtr,data0,data1,data2,data3) \
+    do {								\
+	NRE_callback *_callbackPtr;					\
+	TCLNR_ALLOC((interp), (_callbackPtr));				\
+	_callbackPtr->procPtr = (postProcPtr);				\
+	_callbackPtr->data[0] = (ClientData)(data0);			\
+	_callbackPtr->data[1] = (ClientData)(data1);			\
+	_callbackPtr->data[2] = (ClientData)(data2);			\
+	_callbackPtr->data[3] = (ClientData)(data3);			\
+	_callbackPtr->nextPtr = TOP_CB(interp);				\
+	TOP_CB(interp) = _callbackPtr;					\
+    } while (0)
+
+#if NRE_USE_SMALL_ALLOC
+#define TCLNR_ALLOC(interp, ptr) \
+    TclSmallAllocEx(interp, sizeof(NRE_callback), (ptr))
+#define TCLNR_FREE(interp, ptr)  TclSmallFreeEx((interp), (ptr))
+#else
+#define TCLNR_ALLOC(interp, ptr) \
+    ((ptr) = (void *)ckalloc(sizeof(NRE_callback)))
+#define TCLNR_FREE(interp, ptr)  ckfree((char *) (ptr))
+#endif
+
+#if NRE_ENABLE_ASSERTS
+#define NRE_ASSERT(expr) assert((expr))
+#else
+#define NRE_ASSERT(expr)
+#endif
+
+#include "tclIntDecls.h"
+#include "tclIntPlatDecls.h"
+#include "tclTomMathDecls.h"
+
+#if !defined(USE_TCL_STUBS) && !defined(TCL_MEM_DEBUG)
+#define Tcl_AttemptAlloc        TclpAlloc
+#define Tcl_AttemptRealloc      TclpRealloc
+#define Tcl_Free                TclpFree
+#endif
+
+/*
+ * Special hack for macOS, where the static linker (technically the 'ar'
+ * command) hates empty object files, and accepts no flags to make it shut up.
+ *
+ * These symbols are otherwise completely useless.
+ *
+ * They can't be written to or written through. They can't be seen by any
+ * other code. They use a separate attribute (supported by all macOS
+ * compilers, which are derivatives of clang or gcc) to stop the compilation
+ * from moaning. They will be excluded during the final linking stage.
+ *
+ * Other platforms get nothing at all. That's good.
+ */
+
+#ifdef MAC_OSX_TCL
+#define TCL_MAC_EMPTY_FILE(name) \
+    static __attribute__((used)) const void *const TclUnusedFile_ ## name = NULL;
+#else
+#define TCL_MAC_EMPTY_FILE(name)
+#endif /* MAC_OSX_TCL */
+
+/*
+ * Other externals.
+ */
+
+MODULE_SCOPE size_t TclEnvEpoch;	/* Epoch of the tcl environment
+					 * (if changed with tcl-env). */
+
+#endif /* _TCLINT */
+
+/*
+ * Local Variables:
+ * mode: c
+ * c-basic-offset: 4
+ * fill-column: 78
+ * End:
+ */
diff -Naur itcl/tcl_hdrs/tclIntPlatDecls.h ITCL_BLD/tcl_hdrs/tclIntPlatDecls.h
--- itcl/tcl_hdrs/tclIntPlatDecls.h	1969-12-31 19:00:00.000000000 -0500
+++ ITCL_BLD/tcl_hdrs/tclIntPlatDecls.h	2024-08-06 13:05:31.825682649 -0400
@@ -0,0 +1,600 @@
+/*
+ * tclIntPlatDecls.h --
+ *
+ *	This file contains the declarations for all platform dependent
+ *	unsupported functions that are exported by the Tcl library.  These
+ *	interfaces are not guaranteed to remain the same between
+ *	versions.  Use at your own risk.
+ *
+ * Copyright (c) 1998-1999 by Scriptics Corporation.
+ * All rights reserved.
+ */
+
+#ifndef _TCLINTPLATDECLS
+#define _TCLINTPLATDECLS
+
+#undef TCL_STORAGE_CLASS
+#ifdef BUILD_tcl
+#   define TCL_STORAGE_CLASS DLLEXPORT
+#else
+#   ifdef USE_TCL_STUBS
+#      define TCL_STORAGE_CLASS
+#   else
+#      define TCL_STORAGE_CLASS DLLIMPORT
+#   endif
+#endif
+
+/*
+ * WARNING: This file is automatically generated by the tools/genStubs.tcl
+ * script.  Any modifications to the function declarations below should be made
+ * in the generic/tclInt.decls script.
+ */
+
+/* !BEGIN!: Do not edit below this line. */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Exported function declarations:
+ */
+
+#if !defined(_WIN32) && !defined(__CYGWIN__) && !defined(MAC_OSX_TCL) /* UNIX */
+/* 0 */
+EXTERN void		TclGetAndDetachPids(Tcl_Interp *interp,
+				Tcl_Channel chan);
+/* 1 */
+EXTERN int		TclpCloseFile(TclFile file);
+/* 2 */
+EXTERN Tcl_Channel	TclpCreateCommandChannel(TclFile readFile,
+				TclFile writeFile, TclFile errorFile,
+				int numPids, Tcl_Pid *pidPtr);
+/* 3 */
+EXTERN int		TclpCreatePipe(TclFile *readPipe, TclFile *writePipe);
+/* 4 */
+EXTERN int		TclpCreateProcess(Tcl_Interp *interp, int argc,
+				const char **argv, TclFile inputFile,
+				TclFile outputFile, TclFile errorFile,
+				Tcl_Pid *pidPtr);
+/* 5 */
+EXTERN int		TclUnixWaitForFile_(int fd, int mask, int timeout);
+/* 6 */
+EXTERN TclFile		TclpMakeFile(Tcl_Channel channel, int direction);
+/* 7 */
+EXTERN TclFile		TclpOpenFile(const char *fname, int mode);
+/* 8 */
+EXTERN int		TclUnixWaitForFile(int fd, int mask, int timeout);
+/* 9 */
+EXTERN TclFile		TclpCreateTempFile(const char *contents);
+/* 10 */
+EXTERN Tcl_DirEntry *	TclpReaddir(TclDIR *dir);
+/* 11 */
+EXTERN struct tm *	TclpLocaltime_unix(const time_t *clock);
+/* 12 */
+EXTERN struct tm *	TclpGmtime_unix(const time_t *clock);
+/* 13 */
+EXTERN char *		TclpInetNtoa(struct in_addr addr);
+/* 14 */
+EXTERN int		TclUnixCopyFile(const char *src, const char *dst,
+				const Tcl_StatBuf *statBufPtr,
+				int dontCopyAtts);
+/* 15 */
+EXTERN int		TclMacOSXGetFileAttribute(Tcl_Interp *interp,
+				int objIndex, Tcl_Obj *fileName,
+				Tcl_Obj **attributePtrPtr);
+/* 16 */
+EXTERN int		TclMacOSXSetFileAttribute(Tcl_Interp *interp,
+				int objIndex, Tcl_Obj *fileName,
+				Tcl_Obj *attributePtr);
+/* 17 */
+EXTERN int		TclMacOSXCopyFileAttributes(const char *src,
+				const char *dst,
+				const Tcl_StatBuf *statBufPtr);
+/* 18 */
+EXTERN int		TclMacOSXMatchType(Tcl_Interp *interp,
+				const char *pathName, const char *fileName,
+				Tcl_StatBuf *statBufPtr,
+				Tcl_GlobTypeData *types);
+/* 19 */
+EXTERN void		TclMacOSXNotifierAddRunLoopMode(
+				const void *runLoopMode);
+/* Slot 20 is reserved */
+/* Slot 21 is reserved */
+/* 22 */
+EXTERN TclFile		TclpCreateTempFile_(const char *contents);
+/* Slot 23 is reserved */
+/* Slot 24 is reserved */
+/* Slot 25 is reserved */
+/* Slot 26 is reserved */
+/* Slot 27 is reserved */
+/* Slot 28 is reserved */
+/* 29 */
+EXTERN int		TclWinCPUID(unsigned int index, unsigned int *regs);
+/* 30 */
+EXTERN int		TclUnixOpenTemporaryFile(Tcl_Obj *dirObj,
+				Tcl_Obj *basenameObj, Tcl_Obj *extensionObj,
+				Tcl_Obj *resultingNameObj);
+#endif /* UNIX */
+#if defined(_WIN32) || defined(__CYGWIN__) /* WIN */
+/* 0 */
+EXTERN void		TclWinConvertError(DWORD errCode);
+/* 1 */
+EXTERN void		TclWinConvertWSAError(DWORD errCode);
+/* 2 */
+EXTERN struct servent *	 TclWinGetServByName(const char *nm,
+				const char *proto);
+/* 3 */
+EXTERN int		TclWinGetSockOpt(SOCKET s, int level, int optname,
+				char *optval, int *optlen);
+/* 4 */
+EXTERN HINSTANCE	TclWinGetTclInstance(void);
+/* 5 */
+EXTERN int		TclUnixWaitForFile(int fd, int mask, int timeout);
+/* 6 */
+EXTERN unsigned short	TclWinNToHS(unsigned short ns);
+/* 7 */
+EXTERN int		TclWinSetSockOpt(SOCKET s, int level, int optname,
+				const char *optval, int optlen);
+/* 8 */
+EXTERN int		TclpGetPid(Tcl_Pid pid);
+/* 9 */
+EXTERN int		TclWinGetPlatformId(void);
+/* 10 */
+EXTERN Tcl_DirEntry *	TclpReaddir(TclDIR *dir);
+/* 11 */
+EXTERN void		TclGetAndDetachPids(Tcl_Interp *interp,
+				Tcl_Channel chan);
+/* 12 */
+EXTERN int		TclpCloseFile(TclFile file);
+/* 13 */
+EXTERN Tcl_Channel	TclpCreateCommandChannel(TclFile readFile,
+				TclFile writeFile, TclFile errorFile,
+				int numPids, Tcl_Pid *pidPtr);
+/* 14 */
+EXTERN int		TclpCreatePipe(TclFile *readPipe, TclFile *writePipe);
+/* 15 */
+EXTERN int		TclpCreateProcess(Tcl_Interp *interp, int argc,
+				const char **argv, TclFile inputFile,
+				TclFile outputFile, TclFile errorFile,
+				Tcl_Pid *pidPtr);
+/* 16 */
+EXTERN int		TclpIsAtty(int fd);
+/* 17 */
+EXTERN int		TclUnixCopyFile(const char *src, const char *dst,
+				const Tcl_StatBuf *statBufPtr,
+				int dontCopyAtts);
+/* 18 */
+EXTERN TclFile		TclpMakeFile(Tcl_Channel channel, int direction);
+/* 19 */
+EXTERN TclFile		TclpOpenFile(const char *fname, int mode);
+/* 20 */
+EXTERN void		TclWinAddProcess(HANDLE hProcess, DWORD id);
+/* 21 */
+EXTERN char *		TclpInetNtoa(struct in_addr addr);
+/* 22 */
+EXTERN TclFile		TclpCreateTempFile(const char *contents);
+/* Slot 23 is reserved */
+/* 24 */
+EXTERN char *		TclWinNoBackslash(char *path);
+/* Slot 25 is reserved */
+/* 26 */
+EXTERN void		TclWinSetInterfaces(int wide);
+/* 27 */
+EXTERN void		TclWinFlushDirtyChannels(void);
+/* 28 */
+EXTERN void		TclWinResetInterfaces(void);
+/* 29 */
+EXTERN int		TclWinCPUID(unsigned int index, unsigned int *regs);
+/* 30 */
+EXTERN int		TclUnixOpenTemporaryFile(Tcl_Obj *dirObj,
+				Tcl_Obj *basenameObj, Tcl_Obj *extensionObj,
+				Tcl_Obj *resultingNameObj);
+#endif /* WIN */
+#ifdef MAC_OSX_TCL /* MACOSX */
+/* 0 */
+EXTERN void		TclGetAndDetachPids(Tcl_Interp *interp,
+				Tcl_Channel chan);
+/* 1 */
+EXTERN int		TclpCloseFile(TclFile file);
+/* 2 */
+EXTERN Tcl_Channel	TclpCreateCommandChannel(TclFile readFile,
+				TclFile writeFile, TclFile errorFile,
+				int numPids, Tcl_Pid *pidPtr);
+/* 3 */
+EXTERN int		TclpCreatePipe(TclFile *readPipe, TclFile *writePipe);
+/* 4 */
+EXTERN int		TclpCreateProcess(Tcl_Interp *interp, int argc,
+				const char **argv, TclFile inputFile,
+				TclFile outputFile, TclFile errorFile,
+				Tcl_Pid *pidPtr);
+/* 5 */
+EXTERN int		TclUnixWaitForFile_(int fd, int mask, int timeout);
+/* 6 */
+EXTERN TclFile		TclpMakeFile(Tcl_Channel channel, int direction);
+/* 7 */
+EXTERN TclFile		TclpOpenFile(const char *fname, int mode);
+/* 8 */
+EXTERN int		TclUnixWaitForFile(int fd, int mask, int timeout);
+/* 9 */
+EXTERN TclFile		TclpCreateTempFile(const char *contents);
+/* 10 */
+EXTERN Tcl_DirEntry *	TclpReaddir(TclDIR *dir);
+/* 11 */
+EXTERN struct tm *	TclpLocaltime_unix(const time_t *clock);
+/* 12 */
+EXTERN struct tm *	TclpGmtime_unix(const time_t *clock);
+/* 13 */
+EXTERN char *		TclpInetNtoa(struct in_addr addr);
+/* 14 */
+EXTERN int		TclUnixCopyFile(const char *src, const char *dst,
+				const Tcl_StatBuf *statBufPtr,
+				int dontCopyAtts);
+/* 15 */
+EXTERN int		TclMacOSXGetFileAttribute(Tcl_Interp *interp,
+				int objIndex, Tcl_Obj *fileName,
+				Tcl_Obj **attributePtrPtr);
+/* 16 */
+EXTERN int		TclMacOSXSetFileAttribute(Tcl_Interp *interp,
+				int objIndex, Tcl_Obj *fileName,
+				Tcl_Obj *attributePtr);
+/* 17 */
+EXTERN int		TclMacOSXCopyFileAttributes(const char *src,
+				const char *dst,
+				const Tcl_StatBuf *statBufPtr);
+/* 18 */
+EXTERN int		TclMacOSXMatchType(Tcl_Interp *interp,
+				const char *pathName, const char *fileName,
+				Tcl_StatBuf *statBufPtr,
+				Tcl_GlobTypeData *types);
+/* 19 */
+EXTERN void		TclMacOSXNotifierAddRunLoopMode(
+				const void *runLoopMode);
+/* Slot 20 is reserved */
+/* Slot 21 is reserved */
+/* 22 */
+EXTERN TclFile		TclpCreateTempFile_(const char *contents);
+/* Slot 23 is reserved */
+/* Slot 24 is reserved */
+/* Slot 25 is reserved */
+/* Slot 26 is reserved */
+/* Slot 27 is reserved */
+/* Slot 28 is reserved */
+/* 29 */
+EXTERN int		TclWinCPUID(unsigned int index, unsigned int *regs);
+/* 30 */
+EXTERN int		TclUnixOpenTemporaryFile(Tcl_Obj *dirObj,
+				Tcl_Obj *basenameObj, Tcl_Obj *extensionObj,
+				Tcl_Obj *resultingNameObj);
+#endif /* MACOSX */
+
+typedef struct TclIntPlatStubs {
+    int magic;
+    void *hooks;
+
+#if !defined(_WIN32) && !defined(__CYGWIN__) && !defined(MAC_OSX_TCL) /* UNIX */
+    void (*tclGetAndDetachPids) (Tcl_Interp *interp, Tcl_Channel chan); /* 0 */
+    int (*tclpCloseFile) (TclFile file); /* 1 */
+    Tcl_Channel (*tclpCreateCommandChannel) (TclFile readFile, TclFile writeFile, TclFile errorFile, int numPids, Tcl_Pid *pidPtr); /* 2 */
+    int (*tclpCreatePipe) (TclFile *readPipe, TclFile *writePipe); /* 3 */
+    int (*tclpCreateProcess) (Tcl_Interp *interp, int argc, const char **argv, TclFile inputFile, TclFile outputFile, TclFile errorFile, Tcl_Pid *pidPtr); /* 4 */
+    int (*tclUnixWaitForFile_) (int fd, int mask, int timeout); /* 5 */
+    TclFile (*tclpMakeFile) (Tcl_Channel channel, int direction); /* 6 */
+    TclFile (*tclpOpenFile) (const char *fname, int mode); /* 7 */
+    int (*tclUnixWaitForFile) (int fd, int mask, int timeout); /* 8 */
+    TclFile (*tclpCreateTempFile) (const char *contents); /* 9 */
+    Tcl_DirEntry * (*tclpReaddir) (TclDIR *dir); /* 10 */
+    struct tm * (*tclpLocaltime_unix) (const time_t *clock); /* 11 */
+    struct tm * (*tclpGmtime_unix) (const time_t *clock); /* 12 */
+    char * (*tclpInetNtoa) (struct in_addr addr); /* 13 */
+    int (*tclUnixCopyFile) (const char *src, const char *dst, const Tcl_StatBuf *statBufPtr, int dontCopyAtts); /* 14 */
+    int (*tclMacOSXGetFileAttribute) (Tcl_Interp *interp, int objIndex, Tcl_Obj *fileName, Tcl_Obj **attributePtrPtr); /* 15 */
+    int (*tclMacOSXSetFileAttribute) (Tcl_Interp *interp, int objIndex, Tcl_Obj *fileName, Tcl_Obj *attributePtr); /* 16 */
+    int (*tclMacOSXCopyFileAttributes) (const char *src, const char *dst, const Tcl_StatBuf *statBufPtr); /* 17 */
+    int (*tclMacOSXMatchType) (Tcl_Interp *interp, const char *pathName, const char *fileName, Tcl_StatBuf *statBufPtr, Tcl_GlobTypeData *types); /* 18 */
+    void (*tclMacOSXNotifierAddRunLoopMode) (const void *runLoopMode); /* 19 */
+    void (*reserved20)(void);
+    void (*reserved21)(void);
+    TclFile (*tclpCreateTempFile_) (const char *contents); /* 22 */
+    void (*reserved23)(void);
+    void (*reserved24)(void);
+    void (*reserved25)(void);
+    void (*reserved26)(void);
+    void (*reserved27)(void);
+    void (*reserved28)(void);
+    int (*tclWinCPUID) (unsigned int index, unsigned int *regs); /* 29 */
+    int (*tclUnixOpenTemporaryFile) (Tcl_Obj *dirObj, Tcl_Obj *basenameObj, Tcl_Obj *extensionObj, Tcl_Obj *resultingNameObj); /* 30 */
+#endif /* UNIX */
+#if defined(_WIN32) || defined(__CYGWIN__) /* WIN */
+    void (*tclWinConvertError) (DWORD errCode); /* 0 */
+    void (*tclWinConvertWSAError) (DWORD errCode); /* 1 */
+    struct servent * (*tclWinGetServByName) (const char *nm, const char *proto); /* 2 */
+    int (*tclWinGetSockOpt) (SOCKET s, int level, int optname, char *optval, int *optlen); /* 3 */
+    HINSTANCE (*tclWinGetTclInstance) (void); /* 4 */
+    int (*tclUnixWaitForFile) (int fd, int mask, int timeout); /* 5 */
+    unsigned short (*tclWinNToHS) (unsigned short ns); /* 6 */
+    int (*tclWinSetSockOpt) (SOCKET s, int level, int optname, const char *optval, int optlen); /* 7 */
+    int (*tclpGetPid) (Tcl_Pid pid); /* 8 */
+    int (*tclWinGetPlatformId) (void); /* 9 */
+    Tcl_DirEntry * (*tclpReaddir) (TclDIR *dir); /* 10 */
+    void (*tclGetAndDetachPids) (Tcl_Interp *interp, Tcl_Channel chan); /* 11 */
+    int (*tclpCloseFile) (TclFile file); /* 12 */
+    Tcl_Channel (*tclpCreateCommandChannel) (TclFile readFile, TclFile writeFile, TclFile errorFile, int numPids, Tcl_Pid *pidPtr); /* 13 */
+    int (*tclpCreatePipe) (TclFile *readPipe, TclFile *writePipe); /* 14 */
+    int (*tclpCreateProcess) (Tcl_Interp *interp, int argc, const char **argv, TclFile inputFile, TclFile outputFile, TclFile errorFile, Tcl_Pid *pidPtr); /* 15 */
+    int (*tclpIsAtty) (int fd); /* 16 */
+    int (*tclUnixCopyFile) (const char *src, const char *dst, const Tcl_StatBuf *statBufPtr, int dontCopyAtts); /* 17 */
+    TclFile (*tclpMakeFile) (Tcl_Channel channel, int direction); /* 18 */
+    TclFile (*tclpOpenFile) (const char *fname, int mode); /* 19 */
+    void (*tclWinAddProcess) (HANDLE hProcess, DWORD id); /* 20 */
+    char * (*tclpInetNtoa) (struct in_addr addr); /* 21 */
+    TclFile (*tclpCreateTempFile) (const char *contents); /* 22 */
+    void (*reserved23)(void);
+    char * (*tclWinNoBackslash) (char *path); /* 24 */
+    void (*reserved25)(void);
+    void (*tclWinSetInterfaces) (int wide); /* 26 */
+    void (*tclWinFlushDirtyChannels) (void); /* 27 */
+    void (*tclWinResetInterfaces) (void); /* 28 */
+    int (*tclWinCPUID) (unsigned int index, unsigned int *regs); /* 29 */
+    int (*tclUnixOpenTemporaryFile) (Tcl_Obj *dirObj, Tcl_Obj *basenameObj, Tcl_Obj *extensionObj, Tcl_Obj *resultingNameObj); /* 30 */
+#endif /* WIN */
+#ifdef MAC_OSX_TCL /* MACOSX */
+    void (*tclGetAndDetachPids) (Tcl_Interp *interp, Tcl_Channel chan); /* 0 */
+    int (*tclpCloseFile) (TclFile file); /* 1 */
+    Tcl_Channel (*tclpCreateCommandChannel) (TclFile readFile, TclFile writeFile, TclFile errorFile, int numPids, Tcl_Pid *pidPtr); /* 2 */
+    int (*tclpCreatePipe) (TclFile *readPipe, TclFile *writePipe); /* 3 */
+    int (*tclpCreateProcess) (Tcl_Interp *interp, int argc, const char **argv, TclFile inputFile, TclFile outputFile, TclFile errorFile, Tcl_Pid *pidPtr); /* 4 */
+    int (*tclUnixWaitForFile_) (int fd, int mask, int timeout); /* 5 */
+    TclFile (*tclpMakeFile) (Tcl_Channel channel, int direction); /* 6 */
+    TclFile (*tclpOpenFile) (const char *fname, int mode); /* 7 */
+    int (*tclUnixWaitForFile) (int fd, int mask, int timeout); /* 8 */
+    TclFile (*tclpCreateTempFile) (const char *contents); /* 9 */
+    Tcl_DirEntry * (*tclpReaddir) (TclDIR *dir); /* 10 */
+    struct tm * (*tclpLocaltime_unix) (const time_t *clock); /* 11 */
+    struct tm * (*tclpGmtime_unix) (const time_t *clock); /* 12 */
+    char * (*tclpInetNtoa) (struct in_addr addr); /* 13 */
+    int (*tclUnixCopyFile) (const char *src, const char *dst, const Tcl_StatBuf *statBufPtr, int dontCopyAtts); /* 14 */
+    int (*tclMacOSXGetFileAttribute) (Tcl_Interp *interp, int objIndex, Tcl_Obj *fileName, Tcl_Obj **attributePtrPtr); /* 15 */
+    int (*tclMacOSXSetFileAttribute) (Tcl_Interp *interp, int objIndex, Tcl_Obj *fileName, Tcl_Obj *attributePtr); /* 16 */
+    int (*tclMacOSXCopyFileAttributes) (const char *src, const char *dst, const Tcl_StatBuf *statBufPtr); /* 17 */
+    int (*tclMacOSXMatchType) (Tcl_Interp *interp, const char *pathName, const char *fileName, Tcl_StatBuf *statBufPtr, Tcl_GlobTypeData *types); /* 18 */
+    void (*tclMacOSXNotifierAddRunLoopMode) (const void *runLoopMode); /* 19 */
+    void (*reserved20)(void);
+    void (*reserved21)(void);
+    TclFile (*tclpCreateTempFile_) (const char *contents); /* 22 */
+    void (*reserved23)(void);
+    void (*reserved24)(void);
+    void (*reserved25)(void);
+    void (*reserved26)(void);
+    void (*reserved27)(void);
+    void (*reserved28)(void);
+    int (*tclWinCPUID) (unsigned int index, unsigned int *regs); /* 29 */
+    int (*tclUnixOpenTemporaryFile) (Tcl_Obj *dirObj, Tcl_Obj *basenameObj, Tcl_Obj *extensionObj, Tcl_Obj *resultingNameObj); /* 30 */
+#endif /* MACOSX */
+} TclIntPlatStubs;
+
+extern const TclIntPlatStubs *tclIntPlatStubsPtr;
+
+#ifdef __cplusplus
+}
+#endif
+
+#if defined(USE_TCL_STUBS)
+
+/*
+ * Inline function declarations:
+ */
+
+#if !defined(_WIN32) && !defined(__CYGWIN__) && !defined(MAC_OSX_TCL) /* UNIX */
+#define TclGetAndDetachPids \
+	(tclIntPlatStubsPtr->tclGetAndDetachPids) /* 0 */
+#define TclpCloseFile \
+	(tclIntPlatStubsPtr->tclpCloseFile) /* 1 */
+#define TclpCreateCommandChannel \
+	(tclIntPlatStubsPtr->tclpCreateCommandChannel) /* 2 */
+#define TclpCreatePipe \
+	(tclIntPlatStubsPtr->tclpCreatePipe) /* 3 */
+#define TclpCreateProcess \
+	(tclIntPlatStubsPtr->tclpCreateProcess) /* 4 */
+#define TclUnixWaitForFile_ \
+	(tclIntPlatStubsPtr->tclUnixWaitForFile_) /* 5 */
+#define TclpMakeFile \
+	(tclIntPlatStubsPtr->tclpMakeFile) /* 6 */
+#define TclpOpenFile \
+	(tclIntPlatStubsPtr->tclpOpenFile) /* 7 */
+#define TclUnixWaitForFile \
+	(tclIntPlatStubsPtr->tclUnixWaitForFile) /* 8 */
+#define TclpCreateTempFile \
+	(tclIntPlatStubsPtr->tclpCreateTempFile) /* 9 */
+#define TclpReaddir \
+	(tclIntPlatStubsPtr->tclpReaddir) /* 10 */
+#define TclpLocaltime_unix \
+	(tclIntPlatStubsPtr->tclpLocaltime_unix) /* 11 */
+#define TclpGmtime_unix \
+	(tclIntPlatStubsPtr->tclpGmtime_unix) /* 12 */
+#define TclpInetNtoa \
+	(tclIntPlatStubsPtr->tclpInetNtoa) /* 13 */
+#define TclUnixCopyFile \
+	(tclIntPlatStubsPtr->tclUnixCopyFile) /* 14 */
+#define TclMacOSXGetFileAttribute \
+	(tclIntPlatStubsPtr->tclMacOSXGetFileAttribute) /* 15 */
+#define TclMacOSXSetFileAttribute \
+	(tclIntPlatStubsPtr->tclMacOSXSetFileAttribute) /* 16 */
+#define TclMacOSXCopyFileAttributes \
+	(tclIntPlatStubsPtr->tclMacOSXCopyFileAttributes) /* 17 */
+#define TclMacOSXMatchType \
+	(tclIntPlatStubsPtr->tclMacOSXMatchType) /* 18 */
+#define TclMacOSXNotifierAddRunLoopMode \
+	(tclIntPlatStubsPtr->tclMacOSXNotifierAddRunLoopMode) /* 19 */
+/* Slot 20 is reserved */
+/* Slot 21 is reserved */
+#define TclpCreateTempFile_ \
+	(tclIntPlatStubsPtr->tclpCreateTempFile_) /* 22 */
+/* Slot 23 is reserved */
+/* Slot 24 is reserved */
+/* Slot 25 is reserved */
+/* Slot 26 is reserved */
+/* Slot 27 is reserved */
+/* Slot 28 is reserved */
+#define TclWinCPUID \
+	(tclIntPlatStubsPtr->tclWinCPUID) /* 29 */
+#define TclUnixOpenTemporaryFile \
+	(tclIntPlatStubsPtr->tclUnixOpenTemporaryFile) /* 30 */
+#endif /* UNIX */
+#if defined(_WIN32) || defined(__CYGWIN__) /* WIN */
+#define TclWinConvertError \
+	(tclIntPlatStubsPtr->tclWinConvertError) /* 0 */
+#define TclWinConvertWSAError \
+	(tclIntPlatStubsPtr->tclWinConvertWSAError) /* 1 */
+#define TclWinGetServByName \
+	(tclIntPlatStubsPtr->tclWinGetServByName) /* 2 */
+#define TclWinGetSockOpt \
+	(tclIntPlatStubsPtr->tclWinGetSockOpt) /* 3 */
+#define TclWinGetTclInstance \
+	(tclIntPlatStubsPtr->tclWinGetTclInstance) /* 4 */
+#define TclUnixWaitForFile \
+	(tclIntPlatStubsPtr->tclUnixWaitForFile) /* 5 */
+#define TclWinNToHS \
+	(tclIntPlatStubsPtr->tclWinNToHS) /* 6 */
+#define TclWinSetSockOpt \
+	(tclIntPlatStubsPtr->tclWinSetSockOpt) /* 7 */
+#define TclpGetPid \
+	(tclIntPlatStubsPtr->tclpGetPid) /* 8 */
+#define TclWinGetPlatformId \
+	(tclIntPlatStubsPtr->tclWinGetPlatformId) /* 9 */
+#define TclpReaddir \
+	(tclIntPlatStubsPtr->tclpReaddir) /* 10 */
+#define TclGetAndDetachPids \
+	(tclIntPlatStubsPtr->tclGetAndDetachPids) /* 11 */
+#define TclpCloseFile \
+	(tclIntPlatStubsPtr->tclpCloseFile) /* 12 */
+#define TclpCreateCommandChannel \
+	(tclIntPlatStubsPtr->tclpCreateCommandChannel) /* 13 */
+#define TclpCreatePipe \
+	(tclIntPlatStubsPtr->tclpCreatePipe) /* 14 */
+#define TclpCreateProcess \
+	(tclIntPlatStubsPtr->tclpCreateProcess) /* 15 */
+#define TclpIsAtty \
+	(tclIntPlatStubsPtr->tclpIsAtty) /* 16 */
+#define TclUnixCopyFile \
+	(tclIntPlatStubsPtr->tclUnixCopyFile) /* 17 */
+#define TclpMakeFile \
+	(tclIntPlatStubsPtr->tclpMakeFile) /* 18 */
+#define TclpOpenFile \
+	(tclIntPlatStubsPtr->tclpOpenFile) /* 19 */
+#define TclWinAddProcess \
+	(tclIntPlatStubsPtr->tclWinAddProcess) /* 20 */
+#define TclpInetNtoa \
+	(tclIntPlatStubsPtr->tclpInetNtoa) /* 21 */
+#define TclpCreateTempFile \
+	(tclIntPlatStubsPtr->tclpCreateTempFile) /* 22 */
+/* Slot 23 is reserved */
+#define TclWinNoBackslash \
+	(tclIntPlatStubsPtr->tclWinNoBackslash) /* 24 */
+/* Slot 25 is reserved */
+#define TclWinSetInterfaces \
+	(tclIntPlatStubsPtr->tclWinSetInterfaces) /* 26 */
+#define TclWinFlushDirtyChannels \
+	(tclIntPlatStubsPtr->tclWinFlushDirtyChannels) /* 27 */
+#define TclWinResetInterfaces \
+	(tclIntPlatStubsPtr->tclWinResetInterfaces) /* 28 */
+#define TclWinCPUID \
+	(tclIntPlatStubsPtr->tclWinCPUID) /* 29 */
+#define TclUnixOpenTemporaryFile \
+	(tclIntPlatStubsPtr->tclUnixOpenTemporaryFile) /* 30 */
+#endif /* WIN */
+#ifdef MAC_OSX_TCL /* MACOSX */
+#define TclGetAndDetachPids \
+	(tclIntPlatStubsPtr->tclGetAndDetachPids) /* 0 */
+#define TclpCloseFile \
+	(tclIntPlatStubsPtr->tclpCloseFile) /* 1 */
+#define TclpCreateCommandChannel \
+	(tclIntPlatStubsPtr->tclpCreateCommandChannel) /* 2 */
+#define TclpCreatePipe \
+	(tclIntPlatStubsPtr->tclpCreatePipe) /* 3 */
+#define TclpCreateProcess \
+	(tclIntPlatStubsPtr->tclpCreateProcess) /* 4 */
+#define TclUnixWaitForFile_ \
+	(tclIntPlatStubsPtr->tclUnixWaitForFile_) /* 5 */
+#define TclpMakeFile \
+	(tclIntPlatStubsPtr->tclpMakeFile) /* 6 */
+#define TclpOpenFile \
+	(tclIntPlatStubsPtr->tclpOpenFile) /* 7 */
+#define TclUnixWaitForFile \
+	(tclIntPlatStubsPtr->tclUnixWaitForFile) /* 8 */
+#define TclpCreateTempFile \
+	(tclIntPlatStubsPtr->tclpCreateTempFile) /* 9 */
+#define TclpReaddir \
+	(tclIntPlatStubsPtr->tclpReaddir) /* 10 */
+#define TclpLocaltime_unix \
+	(tclIntPlatStubsPtr->tclpLocaltime_unix) /* 11 */
+#define TclpGmtime_unix \
+	(tclIntPlatStubsPtr->tclpGmtime_unix) /* 12 */
+#define TclpInetNtoa \
+	(tclIntPlatStubsPtr->tclpInetNtoa) /* 13 */
+#define TclUnixCopyFile \
+	(tclIntPlatStubsPtr->tclUnixCopyFile) /* 14 */
+#define TclMacOSXGetFileAttribute \
+	(tclIntPlatStubsPtr->tclMacOSXGetFileAttribute) /* 15 */
+#define TclMacOSXSetFileAttribute \
+	(tclIntPlatStubsPtr->tclMacOSXSetFileAttribute) /* 16 */
+#define TclMacOSXCopyFileAttributes \
+	(tclIntPlatStubsPtr->tclMacOSXCopyFileAttributes) /* 17 */
+#define TclMacOSXMatchType \
+	(tclIntPlatStubsPtr->tclMacOSXMatchType) /* 18 */
+#define TclMacOSXNotifierAddRunLoopMode \
+	(tclIntPlatStubsPtr->tclMacOSXNotifierAddRunLoopMode) /* 19 */
+/* Slot 20 is reserved */
+/* Slot 21 is reserved */
+#define TclpCreateTempFile_ \
+	(tclIntPlatStubsPtr->tclpCreateTempFile_) /* 22 */
+/* Slot 23 is reserved */
+/* Slot 24 is reserved */
+/* Slot 25 is reserved */
+/* Slot 26 is reserved */
+/* Slot 27 is reserved */
+/* Slot 28 is reserved */
+#define TclWinCPUID \
+	(tclIntPlatStubsPtr->tclWinCPUID) /* 29 */
+#define TclUnixOpenTemporaryFile \
+	(tclIntPlatStubsPtr->tclUnixOpenTemporaryFile) /* 30 */
+#endif /* MACOSX */
+
+#endif /* defined(USE_TCL_STUBS) */
+
+/* !END!: Do not edit above this line. */
+
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLIMPORT
+#undef TclpLocaltime_unix
+#undef TclpGmtime_unix
+#undef TclWinConvertWSAError
+#define TclWinConvertWSAError TclWinConvertError
+#undef TclpInetNtoa
+#define TclpInetNtoa inet_ntoa
+
+#undef TclpCreateTempFile_
+#undef TclUnixWaitForFile_
+#ifndef MAC_OSX_TCL /* not accessible on Win32/UNIX */
+#undef TclMacOSXGetFileAttribute /* 15 */
+#undef TclMacOSXSetFileAttribute /* 16 */
+#undef TclMacOSXCopyFileAttributes /* 17 */
+#undef TclMacOSXMatchType /* 18 */
+#undef TclMacOSXNotifierAddRunLoopMode /* 19 */
+#endif
+
+#if defined(_WIN32)
+#   undef TclWinNToHS
+#   undef TclWinGetServByName
+#   undef TclWinGetSockOpt
+#   undef TclWinSetSockOpt
+#   define TclWinNToHS ntohs
+#   define TclWinGetServByName getservbyname
+#   define TclWinGetSockOpt getsockopt
+#   define TclWinSetSockOpt setsockopt
+#else
+#   undef TclpGetPid
+#   define TclpGetPid(pid) ((unsigned long) (pid))
+#endif
+
+#endif /* _TCLINTPLATDECLS */
diff -Naur itcl/tcl_hdrs/tclPort.h ITCL_BLD/tcl_hdrs/tclPort.h
--- itcl/tcl_hdrs/tclPort.h	1969-12-31 19:00:00.000000000 -0500
+++ ITCL_BLD/tcl_hdrs/tclPort.h	2024-08-06 13:03:03.627855547 -0400
@@ -0,0 +1,46 @@
+/*
+ * tclPort.h --
+ *
+ *	This header file handles porting issues that occur because
+ *	of differences between systems.  It reads in platform specific
+ *	portability files.
+ *
+ * Copyright (c) 1994-1995 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TCLPORT
+#define _TCLPORT
+
+#ifdef HAVE_TCL_CONFIG_H
+#include "tclConfig.h"
+#endif
+#if defined(_WIN32)
+#   include "tclWinPort.h"
+#else
+#   include "tclUnixPort.h"
+#endif
+#include "tcl.h"
+
+#if !defined(LLONG_MIN)
+#   ifdef TCL_WIDE_INT_IS_LONG
+#      define LLONG_MIN LONG_MIN
+#   else
+#      ifdef LLONG_BIT
+#         define LLONG_MIN ((Tcl_WideInt)(Tcl_LongAsWide(1)<<(LLONG_BIT-1)))
+#      else
+/* Assume we're on a system with a 64-bit 'long long' type */
+#         define LLONG_MIN ((Tcl_WideInt)(Tcl_LongAsWide(1)<<63))
+#      endif
+#   endif
+/* Assume that if LLONG_MIN is undefined, then so is LLONG_MAX */
+#   define LLONG_MAX (~LLONG_MIN)
+#endif
+
+#define UWIDE_MAX ((Tcl_WideUInt)-1)
+#define WIDE_MAX ((Tcl_WideInt)(UWIDE_MAX >> 1))
+#define WIDE_MIN ((Tcl_WideInt)((Tcl_WideUInt)WIDE_MAX+1))
+
+#endif /* _TCLPORT */
diff -Naur itcl/tcl_hdrs/unix/tclUnixPort.h ITCL_BLD/tcl_hdrs/unix/tclUnixPort.h
--- itcl/tcl_hdrs/unix/tclUnixPort.h	1969-12-31 19:00:00.000000000 -0500
+++ ITCL_BLD/tcl_hdrs/unix/tclUnixPort.h	2024-08-06 13:03:47.690214389 -0400
@@ -0,0 +1,732 @@
+/*
+ * tclUnixPort.h --
+ *
+ *	This header file handles porting issues that occur because of
+ *	differences between systems. It reads in UNIX-related header files and
+ *	sets up UNIX-related macros for Tcl's UNIX core. It should be the only
+ *	file that contains #ifdefs to handle different flavors of UNIX. This
+ *	file sets up the union of all UNIX-related things needed by any of the
+ *	Tcl core files. This file depends on configuration #defines such as
+ *	NO_DIRENT_H that are set up by the "configure" script.
+ *
+ *	Much of the material in this file was originally contributed by Karl
+ *	Lehenbauer, Mark Diekhans and Peter da Silva.
+ *
+ * Copyright (c) 1991-1994 The Regents of the University of California.
+ * Copyright (c) 1994-1997 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TCLUNIXPORT
+#define _TCLUNIXPORT
+
+/*
+ *---------------------------------------------------------------------------
+ * The following sets of #includes and #ifdefs are required to get Tcl to
+ * compile under the various flavors of unix.
+ *---------------------------------------------------------------------------
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#ifdef HAVE_NET_ERRNO_H
+#   include <net/errno.h>
+#endif
+#include <pwd.h>
+#include <signal.h>
+#ifdef HAVE_SYS_PARAM_H
+#   include <sys/param.h>
+#endif
+#include <sys/types.h>
+#ifdef USE_DIRENT2_H
+#   include "../compat/dirent2.h"
+#else
+#ifdef NO_DIRENT_H
+#   include "../compat/dirent.h"
+#else
+#   include <dirent.h>
+#endif
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Parameterize for 64-bit filesystem support.
+ *---------------------------------------------------------------------------
+ */
+
+#ifdef HAVE_STRUCT_DIRENT64
+typedef struct dirent64		Tcl_DirEntry;
+#   define TclOSreaddir		readdir64
+#else
+typedef struct dirent		Tcl_DirEntry;
+#   define TclOSreaddir		readdir
+#endif
+#ifdef HAVE_DIR64
+typedef DIR64			TclDIR;
+#   define TclOSopendir		opendir64
+#   define TclOSrewinddir	rewinddir64
+#   define TclOSclosedir	closedir64
+#else
+typedef DIR			TclDIR;
+#   define TclOSopendir		opendir
+#   define TclOSrewinddir	rewinddir
+#   define TclOSclosedir	closedir
+#endif
+
+#ifdef HAVE_TYPE_OFF64_T
+typedef off64_t		Tcl_SeekOffset;
+#   define TclOSseek		lseek64
+#   define TclOSopen		open64
+#else
+typedef off_t		Tcl_SeekOffset;
+#   define TclOSseek		lseek
+#   define TclOSopen		open
+#endif
+
+#ifdef __CYGWIN__
+#ifdef __cplusplus
+extern "C" {
+#endif
+    /* Make some symbols available without including <windows.h> */
+#   define DWORD unsigned int
+#   define CP_UTF8 65001
+#   define GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS 0x00000004
+#   define HANDLE void *
+#   define HINSTANCE void *
+#   define SOCKET unsigned int
+#   define WSAEWOULDBLOCK 10035
+    typedef unsigned short WCHAR;
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wignored-attributes"
+#endif
+    __declspec(dllimport) extern __stdcall int GetModuleHandleExW(unsigned int, const void *, void *);
+    __declspec(dllimport) extern __stdcall int GetModuleFileNameW(void *, const void *, int);
+    __declspec(dllimport) extern __stdcall int WideCharToMultiByte(int, int, const void *, int,
+	    char *, int, const char *, void *);
+    __declspec(dllimport) extern __stdcall int MultiByteToWideChar(int, int, const char *, int,
+	    WCHAR *, int);
+    __declspec(dllimport) extern __stdcall void OutputDebugStringW(const WCHAR *);
+    __declspec(dllimport) extern __stdcall int IsDebuggerPresent(void);
+    __declspec(dllimport) extern __stdcall int GetLastError(void);
+    __declspec(dllimport) extern __stdcall int GetFileAttributesW(const WCHAR *);
+    __declspec(dllimport) extern __stdcall int SetFileAttributesW(const WCHAR *, int);
+    __declspec(dllimport) extern int cygwin_conv_path(int, const void *, void *, int);
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+#   define timezone _timezone
+    extern int TclOSstat(const char *name, void *statBuf);
+    extern int TclOSlstat(const char *name, void *statBuf);
+#ifdef __cplusplus
+}
+#endif
+#elif defined(HAVE_STRUCT_STAT64) && !defined(__APPLE__)
+#   define TclOSstat(name, buf) stat64(name, (struct stat64 *)buf)
+#   define TclOSlstat(name,buf) lstat64(name, (struct stat64 *)buf)
+#else
+#   define TclOSstat(name, buf) stat(name, (struct stat *)buf)
+#   define TclOSlstat(name, buf) lstat(name, (struct stat *)buf)
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Miscellaneous includes that might be missing.
+ *---------------------------------------------------------------------------
+ */
+
+#include <sys/file.h>
+#ifdef HAVE_SYS_SELECT_H
+#   include <sys/select.h>
+#endif
+#include <sys/stat.h>
+#ifdef TIME_WITH_SYS_TIME
+#   include <sys/time.h>
+#   include <time.h>
+#else
+#ifdef HAVE_SYS_TIME_H
+#   include <sys/time.h>
+#else
+#   include <time.h>
+#endif
+#endif
+#ifndef NO_SYS_WAIT_H
+#   include <sys/wait.h>
+#endif
+#ifdef HAVE_INTTYPES_H
+#   include <inttypes.h>
+#endif
+#include <limits.h>
+#ifdef HAVE_STDINT_H
+#   include <stdint.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#   include <unistd.h>
+#else
+#   include "../compat/unistd.h"
+#endif
+
+extern int TclUnixSetBlockingMode(int fd, int mode);
+
+#include <utime.h>
+
+/*
+ *---------------------------------------------------------------------------
+ * Socket support stuff: This likely needs more work to parameterize for each
+ * system.
+ *---------------------------------------------------------------------------
+ */
+
+#include <sys/socket.h>		/* struct sockaddr, SOCK_STREAM, ... */
+#ifndef NO_UNAME
+#   include <sys/utsname.h>	/* uname system call. */
+#endif
+#include <netinet/in.h>		/* struct in_addr, struct sockaddr_in */
+#include <arpa/inet.h>		/* inet_ntoa() */
+#include <netdb.h>		/* getaddrinfo() */
+#ifdef NEED_FAKE_RFC2553
+# include "../compat/fake-rfc2553.h"
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Some platforms (e.g. SunOS) don't define FLT_MAX and FLT_MIN, so we look
+ * for an alternative definition. If no other alternative is available we use
+ * a reasonable guess.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef NO_FLOAT_H
+#   include <float.h>
+#else
+#ifndef NO_VALUES_H
+#   include <values.h>
+#endif
+#endif
+
+#ifndef FLT_MAX
+#   ifdef MAXFLOAT
+#	define FLT_MAX	MAXFLOAT
+#   else
+#	define FLT_MAX	3.402823466E+38F
+#   endif
+#endif
+#ifndef FLT_MIN
+#   ifdef MINFLOAT
+#	define FLT_MIN	MINFLOAT
+#   else
+#	define FLT_MIN	1.175494351E-38F
+#   endif
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * NeXT doesn't define O_NONBLOCK, so #define it here if necessary.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef O_NONBLOCK
+#   define O_NONBLOCK 0x80
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * The type of the status returned by wait varies from UNIX system to UNIX
+ * system. The macro below defines it:
+ *---------------------------------------------------------------------------
+ */
+
+#ifdef _AIX
+#   define WAIT_STATUS_TYPE	pid_t
+#else
+#ifndef NO_UNION_WAIT
+#   define WAIT_STATUS_TYPE	union wait
+#else
+#   define WAIT_STATUS_TYPE	int
+#endif
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Supply definitions for macros to query wait status, if not already defined
+ * in header files above.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef WIFEXITED
+#   define WIFEXITED(stat)	(((*((int *) &(stat))) & 0xFF) == 0)
+#endif
+
+#ifndef WEXITSTATUS
+#   define WEXITSTATUS(stat)	(((*((int *) &(stat))) >> 8) & 0xFF)
+#endif
+
+#ifndef WIFSIGNALED
+#   define WIFSIGNALED(stat) \
+	(((*((int *) &(stat)))) && ((*((int *) &(stat))) \
+		== ((*((int *) &(stat))) & 0x00FF)))
+#endif
+
+#ifndef WTERMSIG
+#   define WTERMSIG(stat)	((*((int *) &(stat))) & 0x7F)
+#endif
+
+#ifndef WIFSTOPPED
+#   define WIFSTOPPED(stat)	(((*((int *) &(stat))) & 0xFF) == 0177)
+#endif
+
+#ifndef WSTOPSIG
+#   define WSTOPSIG(stat)	(((*((int *) &(stat))) >> 8) & 0xFF)
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Define constants for waitpid() system call if they aren't defined by a
+ * system header file.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef WNOHANG
+#   define WNOHANG 1
+#endif
+#ifndef WUNTRACED
+#   define WUNTRACED 2
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Supply macros for seek offsets, if they're not already provided by an
+ * include file.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef SEEK_SET
+#   define SEEK_SET 0
+#endif
+#ifndef SEEK_CUR
+#   define SEEK_CUR 1
+#endif
+#ifndef SEEK_END
+#   define SEEK_END 2
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * The stuff below is needed by the "time" command. If this system has no
+ * gettimeofday call, then must use times() instead.
+ *---------------------------------------------------------------------------
+ */
+
+#ifdef NO_GETTOD
+#   include <sys/times.h>
+#else
+#   ifdef HAVE_BSDGETTIMEOFDAY
+#	define gettimeofday BSDgettimeofday
+#   endif
+#endif
+
+#ifdef GETTOD_NOT_DECLARED
+extern int	gettimeofday(struct timeval *tp,
+			    struct timezone *tzp);
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Define access mode constants if they aren't already defined.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef F_OK
+#   define F_OK		00
+#endif
+#ifndef X_OK
+#   define X_OK		01
+#endif
+#ifndef W_OK
+#   define W_OK		02
+#endif
+#ifndef R_OK
+#   define R_OK		04
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Define FD_CLOEEXEC (the close-on-exec flag bit) if it isn't already
+ * defined.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef FD_CLOEXEC
+#   define FD_CLOEXEC	1
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * On systems without symbolic links (i.e. S_IFLNK isn't defined) define
+ * "lstat" to use "stat" instead.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef S_IFLNK
+#   undef TclOSlstat
+#   define lstat	stat
+#   define lstat64	stat64
+#   define TclOSlstat	TclOSstat
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Define macros to query file type bits, if they're not already defined.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef S_ISREG
+#   ifdef S_IFREG
+#	define S_ISREG(m)	(((m) & S_IFMT) == S_IFREG)
+#   else
+#	define S_ISREG(m)	0
+#   endif
+#endif /* !S_ISREG */
+#ifndef S_ISDIR
+#   ifdef S_IFDIR
+#	define S_ISDIR(m)	(((m) & S_IFMT) == S_IFDIR)
+#   else
+#	define S_ISDIR(m)	0
+#   endif
+#endif /* !S_ISDIR */
+#ifndef S_ISCHR
+#   ifdef S_IFCHR
+#	define S_ISCHR(m)	(((m) & S_IFMT) == S_IFCHR)
+#   else
+#	define S_ISCHR(m)	0
+#   endif
+#endif /* !S_ISCHR */
+
+#ifndef S_ISBLK
+#   ifdef S_IFBLK
+#	define S_ISBLK(m)	(((m) & S_IFMT) == S_IFBLK)
+#   else
+#	define S_ISBLK(m)	0
+#   endif
+#endif /* !S_ISBLK */
+
+#ifndef S_ISFIFO
+#   ifdef S_IFIFO
+#	define S_ISFIFO(m)	(((m) & S_IFMT) == S_IFIFO)
+#   else
+#	define S_ISFIFO(m)	0
+#   endif
+#endif /* !S_ISFIFO */
+
+#ifndef S_ISLNK
+#   ifdef S_IFLNK
+#	define S_ISLNK(m)	(((m) & S_IFMT) == S_IFLNK)
+#   else
+#	define S_ISLNK(m)	0
+#   endif
+#endif /* !S_ISLNK */
+
+#ifndef S_ISSOCK
+#   ifdef S_IFSOCK
+#	define S_ISSOCK(m)	(((m) & S_IFMT) == S_IFSOCK)
+#   else
+#	define S_ISSOCK(m)	0
+#   endif
+#endif /* !S_ISSOCK */
+
+/*
+ *---------------------------------------------------------------------------
+ * Make sure that MAXPATHLEN and MAXNAMLEN are defined.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef MAXPATHLEN
+#   ifdef PATH_MAX
+#	define MAXPATHLEN	PATH_MAX
+#   else
+#	define MAXPATHLEN	2048
+#   endif
+#endif
+
+#ifndef MAXNAMLEN
+#   ifdef NAME_MAX
+#	define MAXNAMLEN	NAME_MAX
+#   else
+#	define MAXNAMLEN	255
+#   endif
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * The following macro defines the type of the mask arguments to select:
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef NO_FD_SET
+#   define SELECT_MASK	fd_set
+#else /* NO_FD_SET */
+#   ifndef _AIX
+	typedef long	fd_mask;
+#   endif /* !AIX */
+#   if defined(_IBMR2)
+#	define SELECT_MASK	void
+#   else /* !defined(_IBMR2) */
+#	define SELECT_MASK	int
+#   endif /* defined(_IBMR2) */
+#endif /* !NO_FD_SET */
+
+/*
+ *---------------------------------------------------------------------------
+ * Define "NBBY" (number of bits per byte) if it's not already defined.
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef NBBY
+#   define NBBY		8
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * The following macro defines the number of fd_masks in an fd_set:
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef FD_SETSIZE
+#   ifdef OPEN_MAX
+#	define FD_SETSIZE	OPEN_MAX
+#   else
+#	define FD_SETSIZE	256
+#   endif
+#endif /* FD_SETSIZE */
+
+#ifndef howmany
+#   define howmany(x, y)	(((x)+((y)-1))/(y))
+#endif /* !defined(howmany) */
+
+#ifndef NFDBITS
+#   define NFDBITS	NBBY*sizeof(fd_mask)
+#endif /* NFDBITS */
+
+#define MASK_SIZE	howmany(FD_SETSIZE, NFDBITS)
+
+/*
+ *---------------------------------------------------------------------------
+ * Not all systems declare the errno variable in errno.h, so this file does it
+ * explicitly. The list of system error messages also isn't generally declared
+ * in a header file anywhere.
+ *---------------------------------------------------------------------------
+ */
+
+#ifdef NO_ERRNO
+extern int errno;
+#endif /* NO_ERRNO */
+
+/*
+ *---------------------------------------------------------------------------
+ * Not all systems declare all the errors that Tcl uses! Provide some
+ * work-arounds...
+ *---------------------------------------------------------------------------
+ */
+
+#ifndef EOVERFLOW
+#   ifdef EFBIG
+#	define EOVERFLOW	EFBIG
+#   else /* !EFBIG */
+#	define EOVERFLOW	EINVAL
+#   endif /* EFBIG */
+#endif /* EOVERFLOW */
+
+/*
+ *---------------------------------------------------------------------------
+ * Variables provided by the C library:
+ *---------------------------------------------------------------------------
+ */
+
+#if defined(__APPLE__) && defined(__DYNAMIC__)
+#   include <crt_externs.h>
+#   define environ	(*_NSGetEnviron())
+#   define USE_PUTENV	1
+#else
+#   if defined(_sgi) || defined(__sgi)
+#	define environ	_environ
+#   endif
+extern char **		environ;
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Darwin specifc configure overrides.
+ *---------------------------------------------------------------------------
+ */
+
+#ifdef __APPLE__
+
+/*
+ *---------------------------------------------------------------------------
+ * Support for fat compiles: configure runs only once for multiple architectures
+ *---------------------------------------------------------------------------
+ */
+
+#   if defined(__LP64__) && defined (NO_COREFOUNDATION_64)
+#	undef HAVE_COREFOUNDATION
+#   endif /* __LP64__ && NO_COREFOUNDATION_64 */
+#   include <sys/cdefs.h>
+#   ifdef __DARWIN_UNIX03
+#	if __DARWIN_UNIX03
+#	    undef HAVE_PUTENV_THAT_COPIES
+#	else
+#	    define HAVE_PUTENV_THAT_COPIES	1
+#	endif
+#   endif /* __DARWIN_UNIX03 */
+
+/*
+ *---------------------------------------------------------------------------
+ * Include AvailabilityMacros.h here (when available) to ensure any symbolic
+ * MAC_OS_X_VERSION_* constants passed on the command line are translated.
+ *---------------------------------------------------------------------------
+ */
+
+#   ifdef HAVE_AVAILABILITYMACROS_H
+#	include <AvailabilityMacros.h>
+#   endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Support for weak import.
+ *---------------------------------------------------------------------------
+ */
+
+#   ifdef HAVE_WEAK_IMPORT
+#	if !defined(HAVE_AVAILABILITYMACROS_H) || !defined(MAC_OS_X_VERSION_MIN_REQUIRED)
+#	    undef HAVE_WEAK_IMPORT
+#	else
+#	    ifndef WEAK_IMPORT_ATTRIBUTE
+#		define WEAK_IMPORT_ATTRIBUTE	__attribute__((weak_import))
+#	    endif
+#	endif
+#   endif /* HAVE_WEAK_IMPORT */
+
+/*
+ *---------------------------------------------------------------------------
+ * Support for MAC_OS_X_VERSION_MAX_ALLOWED define from AvailabilityMacros.h:
+ * only use API available in the indicated OS version or earlier.
+ *---------------------------------------------------------------------------
+ */
+
+#   ifdef MAC_OS_X_VERSION_MAX_ALLOWED
+#	if MAC_OS_X_VERSION_MAX_ALLOWED < 1050 && defined(__LP64__)
+#	    undef HAVE_COREFOUNDATION
+#	endif
+#	if MAC_OS_X_VERSION_MAX_ALLOWED < 1040
+#	    undef HAVE_OSSPINLOCKLOCK
+#	    undef HAVE_PTHREAD_ATFORK
+#	    undef HAVE_COPYFILE
+#	endif
+#	if MAC_OS_X_VERSION_MAX_ALLOWED < 1030
+#	    ifdef TCL_THREADS
+		/* prior to 10.3, realpath is not threadsafe, c.f. bug 711232 */
+#		define NO_REALPATH 1
+#	    endif
+#	    undef HAVE_LANGINFO
+#	endif
+#   endif /* MAC_OS_X_VERSION_MAX_ALLOWED */
+#   if defined(HAVE_COREFOUNDATION) && defined(__LP64__) && \
+	    defined(HAVE_WEAK_IMPORT) && MAC_OS_X_VERSION_MIN_REQUIRED < 1050
+#	warning "Weak import of 64-bit CoreFoundation is not supported, will not run on Mac OS X < 10.5."
+#   endif
+    /*
+     * For now, test exec-17.1 fails (I/O setup after closing stdout) with
+     * posix_spawnp(), but the classic implementation (based on fork()+execvp())
+     * works well under macOS.
+     */
+#   undef HAVE_POSIX_SPAWNP
+#   undef HAVE_VFORK
+#endif /* __APPLE__ */
+
+/*
+ *---------------------------------------------------------------------------
+ * The following macros and declarations represent the interface between
+ * generic and unix-specific parts of Tcl. Some of the macros may override
+ * functions declared in tclInt.h.
+ *---------------------------------------------------------------------------
+ */
+
+/*
+ * The default platform eol translation on Unix is TCL_TRANSLATE_LF.
+ */
+
+#ifdef DJGPP
+#define	TCL_PLATFORM_TRANSLATION	TCL_TRANSLATE_CRLF
+typedef int socklen_t;
+#else
+#define	TCL_PLATFORM_TRANSLATION	TCL_TRANSLATE_LF
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * The following macros have trivial definitions, allowing generic code to
+ * address platform-specific issues.
+ *---------------------------------------------------------------------------
+ */
+
+#define TclpReleaseFile(file)	/* Nothing. */
+
+/*
+ *---------------------------------------------------------------------------
+ * The following defines wrap the system memory allocation routines.
+ *---------------------------------------------------------------------------
+ */
+
+#define TclpSysAlloc(size, isBin)	malloc((size_t)(size))
+#define TclpSysFree(ptr)		free((char *)(ptr))
+#define TclpSysRealloc(ptr, size)	realloc((char *)(ptr), (size_t)(size))
+
+/*
+ *---------------------------------------------------------------------------
+ * The following macros and declaration wrap the C runtime library functions.
+ *---------------------------------------------------------------------------
+ */
+
+#define TclpExit	exit
+
+#ifdef TCL_THREADS
+#   include <pthread.h>
+#endif /* TCL_THREADS */
+
+/* FIXME - Hyper-enormous platform assumption! */
+#ifndef AF_INET6
+#   define AF_INET6	10
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * Set of MT-safe implementations of some known-to-be-MT-unsafe library calls.
+ * Instead of returning pointers to the static storage, those return pointers
+ * to the TSD data.
+ *---------------------------------------------------------------------------
+ */
+
+#include <pwd.h>
+#include <grp.h>
+
+extern struct passwd *	TclpGetPwNam(const char *name);
+extern struct group *	TclpGetGrNam(const char *name);
+extern struct passwd *	TclpGetPwUid(uid_t uid);
+extern struct group *	TclpGetGrGid(gid_t gid);
+extern struct hostent *	TclpGetHostByName(const char *name);
+extern struct hostent *	TclpGetHostByAddr(const char *addr,
+				    int length, int type);
+extern void *TclpMakeTcpClientChannelMode(
+				    void *tcpSocket, int mode);
+
+#endif /* _TCLUNIXPORT */
+
+/*
+ * Local Variables:
+ * mode: c
+ * c-basic-offset: 4
+ * fill-column: 78
+ * End:
+ */
diff -Naur itcl/tcl_hdrs/win/tclWinPort.h ITCL_BLD/tcl_hdrs/win/tclWinPort.h
--- itcl/tcl_hdrs/win/tclWinPort.h	1969-12-31 19:00:00.000000000 -0500
+++ ITCL_BLD/tcl_hdrs/win/tclWinPort.h	2024-08-06 13:04:40.186444947 -0400
@@ -0,0 +1,582 @@
+/*
+ * tclWinPort.h --
+ *
+ *	This header file handles porting issues that occur because of
+ *	differences between Windows and Unix. It should be the only
+ *	file that contains #ifdefs to handle different flavors of OS.
+ *
+ * Copyright (c) 1994-1997 Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _TCLWINPORT
+#define _TCLWINPORT
+
+#if !defined(_WIN64) && !defined(__MINGW_USE_VC2005_COMPAT)
+/* See [Bug 3354324]: file mtime sets wrong time */
+#   define __MINGW_USE_VC2005_COMPAT
+#endif
+
+/*
+ * We must specify the lower version we intend to support.
+ *
+ * WINVER = 0x0501 means Windows XP and above
+ */
+
+#ifndef WINVER
+#   define WINVER 0x0501
+#endif
+#ifndef _WIN32_WINNT
+#   define _WIN32_WINNT 0x0501
+#endif
+
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#undef WIN32_LEAN_AND_MEAN
+
+/* Compatibility to older visual studio / windows platform SDK */
+#if !defined(MAXULONG_PTR)
+typedef DWORD DWORD_PTR;
+typedef DWORD_PTR * PDWORD_PTR;
+#endif
+
+/*
+ * Ask for the winsock function typedefs, also.
+ */
+#ifndef INCL_WINSOCK_API_TYPEDEFS
+#   define INCL_WINSOCK_API_TYPEDEFS   1
+#endif
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#ifdef HAVE_WSPIAPI_H
+#   include <wspiapi.h>
+#endif
+
+#ifdef CHECK_UNICODE_CALLS
+#   define _UNICODE
+#   define UNICODE
+#   define __TCHAR_DEFINED
+    typedef float *_TCHAR;
+#   define _TCHAR_DEFINED
+    typedef float *TCHAR;
+#endif /* CHECK_UNICODE_CALLS */
+
+/*
+ *  Pull in the typedef of TCHAR for windows.
+ */
+#include <tchar.h>
+#ifndef _TCHAR_DEFINED
+    /* Borland seems to forget to set this. */
+    typedef _TCHAR TCHAR;
+#   define _TCHAR_DEFINED
+#endif
+#if defined(_MSC_VER) && defined(__STDC__)
+    /* VS2005 SP1 misses this. See [Bug #3110161] */
+    typedef _TCHAR TCHAR;
+#endif
+
+/*
+ *---------------------------------------------------------------------------
+ * The following sets of #includes and #ifdefs are required to get Tcl to
+ * compile under the windows compilers.
+ *---------------------------------------------------------------------------
+ */
+
+#include <time.h>
+#include <wchar.h>
+#include <io.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <float.h>
+#include <malloc.h>
+#include <process.h>
+#include <signal.h>
+#ifdef HAVE_INTTYPES_H
+#   include <inttypes.h>
+#endif
+#include <limits.h>
+
+#ifndef __GNUC__
+#    define strncasecmp _strnicmp
+#    define strcasecmp _stricmp
+#endif
+
+/*
+ * Need to block out these includes for building extensions with MetroWerks
+ * compiler for Win32.
+ */
+
+#ifndef __MWERKS__
+#include <sys/stat.h>
+#include <sys/timeb.h>
+#   ifdef __BORLANDC__
+#	include <utime.h>
+#   else
+#	include <sys/utime.h>
+#   endif /* __BORLANDC__ */
+#endif /* __MWERKS__ */
+
+/*
+ * The following defines redefine the Windows Socket errors as
+ * BSD errors so Tcl_PosixError can do the right thing.
+ */
+
+#ifndef ENOTEMPTY
+#   define ENOTEMPTY 	41	/* Directory not empty */
+#endif
+#ifndef EREMOTE
+#   define EREMOTE	66	/* The object is remote */
+#endif
+#ifndef EPFNOSUPPORT
+#   define EPFNOSUPPORT	96	/* Protocol family not supported */
+#endif
+#ifndef EADDRINUSE
+#   define EADDRINUSE	100	/* Address already in use */
+#endif
+#ifndef EADDRNOTAVAIL
+#   define EADDRNOTAVAIL 101	/* Can't assign requested address */
+#endif
+#ifndef EAFNOSUPPORT
+#   define EAFNOSUPPORT	102	/* Address family not supported */
+#endif
+#ifndef EALREADY
+#   define EALREADY	103	/* Operation already in progress */
+#endif
+#ifndef EBADMSG
+#   define EBADMSG	104	/* Not a data message */
+#endif
+#ifndef ECANCELED
+#   define ECANCELED	105	/* Canceled */
+#endif
+#ifndef ECONNABORTED
+#   define ECONNABORTED	106	/* Software caused connection abort */
+#endif
+#ifndef ECONNREFUSED
+#   define ECONNREFUSED	107	/* Connection refused */
+#endif
+#ifndef ECONNRESET
+#   define ECONNRESET	108	/* Connection reset by peer */
+#endif
+#ifndef EDESTADDRREQ
+#   define EDESTADDRREQ	109	/* Destination address required */
+#endif
+#ifndef EHOSTUNREACH
+#   define EHOSTUNREACH	110	/* No route to host */
+#endif
+#ifndef EIDRM
+#   define EIDRM	111	/* Identifier removed */
+#endif
+#ifndef EINPROGRESS
+#   define EINPROGRESS	112	/* Operation now in progress */
+#endif
+#ifndef EISCONN
+#   define EISCONN	113	/* Socket is already connected */
+#endif
+#ifndef ELOOP
+#   define ELOOP	114	/* Symbolic link loop */
+#endif
+#ifndef EMSGSIZE
+#   define EMSGSIZE	115	/* Message too long */
+#endif
+#ifndef ENETDOWN
+#   define ENETDOWN	116	/* Network is down */
+#endif
+#ifndef ENETRESET
+#   define ENETRESET	117	/* Network dropped connection on reset */
+#endif
+#ifndef ENETUNREACH
+#   define ENETUNREACH	118	/* Network is unreachable */
+#endif
+#ifndef ENOBUFS
+#   define ENOBUFS	119	/* No buffer space available */
+#endif
+#ifndef ENODATA
+#   define ENODATA	120	/* No data available */
+#endif
+#ifndef ENOLINK
+#   define ENOLINK	121	/* Link has be severed */
+#endif
+#ifndef ENOMSG
+#   define ENOMSG	122	/* No message of desired type */
+#endif
+#ifndef ENOPROTOOPT
+#   define ENOPROTOOPT	123	/* Protocol not available */
+#endif
+#ifndef ENOSR
+#   define ENOSR	124	/* Out of stream resources */
+#endif
+#ifndef ENOSTR
+#   define ENOSTR	125	/* Not a stream device */
+#endif
+#ifndef ENOTCONN
+#   define ENOTCONN	126	/* Socket is not connected */
+#endif
+#ifndef ENOTRECOVERABLE
+#   define ENOTRECOVERABLE	127	/* Not recoverable */
+#endif
+#ifndef ENOTSOCK
+#   define ENOTSOCK	128	/* Socket operation on non-socket */
+#endif
+#ifndef ENOTSUP
+#   define ENOTSUP	129	/* Operation not supported */
+#endif
+#ifndef EOPNOTSUPP
+#   define EOPNOTSUPP	130	/* Operation not supported on socket */
+#endif
+#ifndef EOTHER
+#   define EOTHER	131	/* Other error */
+#endif
+#ifndef EOVERFLOW
+#   define EOVERFLOW	132	/* File too big */
+#endif
+#ifndef EOWNERDEAD
+#   define EOWNERDEAD	133	/* Owner dead */
+#endif
+#ifndef EPROTO
+#   define EPROTO	134	/* Protocol error */
+#endif
+#ifndef EPROTONOSUPPORT
+#   define EPROTONOSUPPORT 135	/* Protocol not supported */
+#endif
+#ifndef EPROTOTYPE
+#   define EPROTOTYPE	136	/* Protocol wrong type for socket */
+#endif
+#ifndef ETIME
+#   define ETIME	137	/* Timer expired */
+#endif
+#ifndef ETIMEDOUT
+#   define ETIMEDOUT	138	/* Connection timed out */
+#endif
+#ifndef ETXTBSY
+#   define ETXTBSY	139	/* Text file or pseudo-device busy */
+#endif
+#ifndef EWOULDBLOCK
+#   define EWOULDBLOCK	140	/* Operation would block */
+#endif
+
+
+/* Visual Studio doesn't have these, so just choose some high numbers */
+#ifndef ESOCKTNOSUPPORT
+#   define ESOCKTNOSUPPORT 240	/* Socket type not supported */
+#endif
+#ifndef ESHUTDOWN
+#   define ESHUTDOWN	241	/* Can't send after socket shutdown */
+#endif
+#ifndef ETOOMANYREFS
+#   define ETOOMANYREFS	242	/* Too many references: can't splice */
+#endif
+#ifndef EHOSTDOWN
+#   define EHOSTDOWN	243	/* Host is down */
+#endif
+#ifndef EUSERS
+#   define EUSERS	244	/* Too many users (for UFS) */
+#endif
+#ifndef EDQUOT
+#   define EDQUOT	245	/* Disc quota exceeded */
+#endif
+#ifndef ESTALE
+#   define ESTALE	246	/* Stale NFS file handle */
+#endif
+
+/*
+ * Signals not known to the standard ANSI signal.h.  These are used
+ * by Tcl_WaitPid() and generic/tclPosixStr.c
+ */
+
+#ifndef SIGTRAP
+#   define SIGTRAP  5
+#endif
+#ifndef SIGBUS
+#   define SIGBUS   10
+#endif
+
+/*
+ * Supply definitions for macros to query wait status, if not already
+ * defined in header files above.
+ */
+
+#ifdef TCL_UNION_WAIT
+#   define WAIT_STATUS_TYPE union wait
+#else
+#   define WAIT_STATUS_TYPE int
+#endif /* TCL_UNION_WAIT */
+
+#ifndef WIFEXITED
+#   define WIFEXITED(stat)  (((*((int *) &(stat))) & 0xC0000000) == 0)
+#endif
+
+#ifndef WEXITSTATUS
+#   define WEXITSTATUS(stat) (*((int *) &(stat)))
+#endif
+
+#ifndef WIFSIGNALED
+#   define WIFSIGNALED(stat) ((*((int *) &(stat))) & 0xC0000000)
+#endif
+
+#ifndef WTERMSIG
+#   define WTERMSIG(stat)    ((*((int *) &(stat))) & 0x7F)
+#endif
+
+#ifndef WIFSTOPPED
+#   define WIFSTOPPED(stat)  0
+#endif
+
+#ifndef WSTOPSIG
+#   define WSTOPSIG(stat)    (((*((int *) &(stat))) >> 8) & 0xFF)
+#endif
+
+/*
+ * Define constants for waitpid() system call if they aren't defined
+ * by a system header file.
+ */
+
+#ifndef WNOHANG
+#   define WNOHANG 1
+#endif
+#ifndef WUNTRACED
+#   define WUNTRACED 2
+#endif
+
+/*
+ * Define access mode constants if they aren't already defined.
+ */
+
+#ifndef F_OK
+#    define F_OK 00
+#endif
+#ifndef X_OK
+#    define X_OK 01
+#endif
+#ifndef W_OK
+#    define W_OK 02
+#endif
+#ifndef R_OK
+#    define R_OK 04
+#endif
+
+/*
+ * Define macros to query file type bits, if they're not already
+ * defined.
+ */
+
+#ifndef S_IFLNK
+#   define S_IFLNK        0120000  /* Symbolic Link */
+#endif
+
+/*
+ * Windows compilers do not define S_IFBLK. However, Tcl uses it in
+ * GetTypeFromMode to identify blockSpecial devices based on the
+ * value in the statsbuf st_mode field. We have no other way to pass this
+ * from NativeStat on Windows so are forced to define it here.
+ * The definition here is essentially what is seen on Linux and MingW.
+ * XXX - the root problem is Tcl using Unix definitions instead of
+ * abstracting the structure into a platform independent one. Sigh - perhaps
+ * Tcl 9
+ */
+#ifndef S_IFBLK
+#   define S_IFBLK (S_IFDIR | S_IFCHR)
+#endif
+
+#ifndef S_ISREG
+#   ifdef S_IFREG
+#       define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
+#   else
+#       define S_ISREG(m) 0
+#   endif
+#endif /* !S_ISREG */
+#ifndef S_ISDIR
+#   ifdef S_IFDIR
+#       define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
+#   else
+#       define S_ISDIR(m) 0
+#   endif
+#endif /* !S_ISDIR */
+#ifndef S_ISCHR
+#   ifdef S_IFCHR
+#       define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
+#   else
+#       define S_ISCHR(m) 0
+#   endif
+#endif /* !S_ISCHR */
+#ifndef S_ISBLK
+#   ifdef S_IFBLK
+#       define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
+#   else
+#       define S_ISBLK(m) 0
+#   endif
+#endif /* !S_ISBLK */
+#ifndef S_ISFIFO
+#   ifdef S_IFIFO
+#       define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
+#   else
+#       define S_ISFIFO(m) 0
+#   endif
+#endif /* !S_ISFIFO */
+#ifndef S_ISLNK
+#   ifdef S_IFLNK
+#       define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
+#   else
+#       define S_ISLNK(m) 0
+#   endif
+#endif /* !S_ISLNK */
+
+
+/*
+ * Define MAXPATHLEN in terms of MAXPATH if available
+ */
+
+#ifndef MAXPATH
+#   define MAXPATH MAX_PATH
+#endif /* MAXPATH */
+
+#ifndef MAXPATHLEN
+#   define MAXPATHLEN MAXPATH
+#endif /* MAXPATHLEN */
+
+/*
+ * Define pid_t and uid_t if they're not already defined.
+ */
+
+#if !defined(TCL_PID_T)
+#   define pid_t int
+#endif /* !TCL_PID_T */
+#if !defined(TCL_UID_T)
+#   define uid_t int
+#endif /* !TCL_UID_T */
+
+/*
+ * Visual C++ has some odd names for common functions, so we need to
+ * define a few macros to handle them.  Also, it defines EDEADLOCK and
+ * EDEADLK as the same value, which confuses Tcl_ErrnoId().
+ */
+
+#if defined(_MSC_VER) || defined(__MSVCRT__)
+#   define environ _environ
+#   if defined(_MSC_VER) && (_MSC_VER < 1600)
+#	define hypot _hypot
+#   endif
+#   define exception _exception
+#   undef EDEADLOCK
+#   if defined(_MSC_VER) && (_MSC_VER >= 1700)
+#	define timezone _timezone
+#   endif
+#endif /* _MSC_VER || __MSVCRT__ */
+
+/*
+ * Borland's timezone and environ functions.
+ */
+
+#ifdef  __BORLANDC__
+#   define timezone _timezone
+#   define environ  _environ
+#endif /* __BORLANDC__ */
+
+#ifdef __WATCOMC__
+#   if !defined(__CHAR_SIGNED__)
+#	error "You must use the -j switch to ensure char is signed."
+#   endif
+#endif
+
+
+/*
+ * MSVC 8.0 started to mark many standard C library functions depreciated
+ * including the *printf family and others. Tell it to shut up.
+ * (_MSC_VER is 1200 for VC6, 1300 or 1310 for vc7.net, 1400 for 8.0)
+ */
+#if defined(_MSC_VER)
+#   pragma warning(disable:4090) /* see: https://developercommunity.visualstudio.com/t/c-compiler-incorrect-propagation-of-const-qualifie/390711 */
+#   pragma warning(disable:4146)
+#   pragma warning(disable:4244)
+#   if _MSC_VER >= 1400
+#	pragma warning(disable:4267)
+#	pragma warning(disable:4996)
+#   endif
+#endif
+/*
+ *---------------------------------------------------------------------------
+ * The following macros and declarations represent the interface between
+ * generic and windows-specific parts of Tcl.  Some of the macros may
+ * override functions declared in tclInt.h.
+ *---------------------------------------------------------------------------
+ */
+
+/*
+ * The default platform eol translation on Windows is TCL_TRANSLATE_CRLF:
+ */
+
+#define	TCL_PLATFORM_TRANSLATION	TCL_TRANSLATE_CRLF
+
+/*
+ * Declare dynamic loading extension macro.
+ */
+
+#define TCL_SHLIB_EXT ".dll"
+
+/*
+ * The following define ensures that we use the native putenv
+ * implementation to modify the environment array.  This keeps
+ * the C level environment in synch with the system level environment.
+ */
+
+#define USE_PUTENV		1
+#define USE_PUTENV_FOR_UNSET	1
+
+/*
+ * Msvcrt's putenv() copies the string rather than takes ownership of it.
+ */
+
+#if defined(_MSC_VER) || defined(__MSVCRT__)
+#   define HAVE_PUTENV_THAT_COPIES 1
+#endif
+
+/*
+ * Older version of Mingw are known to lack a MWMO_ALERTABLE define.
+ */
+#if !defined(MWMO_ALERTABLE)
+#   define MWMO_ALERTABLE 2
+#endif
+
+/*
+ * The following defines wrap the system memory allocation routines for
+ * use by tclAlloc.c.
+ */
+
+#define TclpSysAlloc(size, isBin)	((void*)HeapAlloc(GetProcessHeap(), \
+					    (DWORD)0, (DWORD)size))
+#define TclpSysFree(ptr)		(HeapFree(GetProcessHeap(), \
+					    (DWORD)0, (HGLOBAL)ptr))
+#define TclpSysRealloc(ptr, size)	((void*)HeapReAlloc(GetProcessHeap(), \
+					    (DWORD)0, (LPVOID)ptr, (DWORD)size))
+
+/* This type is not defined in the Windows headers */
+#define socklen_t       int
+
+
+/*
+ * The following macros have trivial definitions, allowing generic code to
+ * address platform-specific issues.
+ */
+
+#define TclpReleaseFile(file)	ckfree((char *) file)
+
+/*
+ * The following macros and declarations wrap the C runtime library
+ * functions.
+ */
+
+#define TclpExit		exit
+
+#ifndef INVALID_SET_FILE_POINTER
+#define INVALID_SET_FILE_POINTER 0xFFFFFFFF
+#endif /* INVALID_SET_FILE_POINTER */
+
+#ifndef LABEL_SECURITY_INFORMATION
+#   define LABEL_SECURITY_INFORMATION (0x00000010L)
+#endif
+
+#define Tcl_DirEntry void
+#define TclDIR void
+
+#endif /* _TCLWINPORT */
