diff -Naur itk/CMake/FindTCL.cmake ITK_BLD/CMake/FindTCL.cmake
--- itk/CMake/FindTCL.cmake	1969-12-31 19:00:00.000000000 -0500
+++ ITK_BLD/CMake/FindTCL.cmake	2024-08-06 13:12:35.229286326 -0400
@@ -0,0 +1,496 @@
+# Distributed under the OSI-approved BSD 3-Clause License.  See accompanying
+# file Copyright.txt or https://cmake.org/licensing for details.
+
+#[=======================================================================[.rst:
+FindTCL
+-------
+
+This module finds if Tcl is installed and determines where the include
+files and libraries are.  It also determines what the name of the
+library is.  This code sets the following variables:
+
+::
+
+TCL_FOUND              = Tcl was found
+TCLSH_FOUND            = TRUE if tclsh has been found
+TCL_LIBRARY            = path to Tcl library (tcl tcl80)
+TCL_INCLUDE_PATH       = path to where tcl.h can be found
+TCL_TCLSH              = path to tclsh binary (tcl tcl80)
+
+
+
+If TCL_ENABLE_TK is set, the following are also set:
+
+::
+
+TK_FOUND               = Tk was found
+TCLTK_FOUND            = Tcl and Tk were found
+TK_LIBRARY             = path to Tk library (tk tk80 etc)
+TK_INCLUDE_PATH        = path to where tk.h can be found
+TK_WISH                = full path to the wish executable
+TCL_STUB_LIBRARY       = path to Tcl stub library
+TK_STUB_LIBRARY        = path to Tk stub library
+TTK_STUB_LIBRARY       = path to ttk stub library
+
+#]=======================================================================]
+
+include(CMakeFindFrameworks)
+
+set(_TCL_SEARCHES)
+
+# Search TCL_ROOT first if it is set.
+if(TCL_ROOT)
+  set(_TCL_SEARCH_ROOT PATHS ${TCL_ROOT} NO_DEFAULT_PATH)
+  list(APPEND _TCL_SEARCHES _TCL_SEARCH_ROOT)
+endif()
+
+if(WIN32)
+  get_filename_component(
+    ActiveTcl_CurrentVersion
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\ActiveState\\ActiveTcl;CurrentVersion]"
+    NAME)
+  set(TCLTK_POSSIBLE_BIN_PATHS ${TCLTK_POSSIBLE_BIN_PATHS}
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\ActiveState\\ActiveTcl\\${ActiveTcl_CurrentVersion}]/bin"
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\Scriptics\\Tcl\\8.6;Root]/bin"
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\Scriptics\\Tcl\\8.5;Root]/bin"
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\Scriptics\\Tcl\\8.4;Root]/bin"
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\Scriptics\\Tcl\\8.3;Root]/bin"
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\Scriptics\\Tcl\\8.2;Root]/bin"
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\Scriptics\\Tcl\\8.0;Root]/bin"
+    )
+
+  get_filename_component(
+    ActiveTcl_CurrentVersion
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\ActiveState\\ActiveTcl;CurrentVersion]"
+    NAME)
+  set(TCLTK_POSSIBLE_LIB_PATHS ${TCLTK_POSSIBLE_LIB_PATHS}
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\ActiveState\\ActiveTcl\\${ActiveTcl_CurrentVersion}]/lib"
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\Scriptics\\Tcl\\8.6;Root]/lib"
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\Scriptics\\Tcl\\8.5;Root]/lib"
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\Scriptics\\Tcl\\8.4;Root]/lib"
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\Scriptics\\Tcl\\8.3;Root]/lib"
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\Scriptics\\Tcl\\8.2;Root]/lib"
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\Scriptics\\Tcl\\8.0;Root]/lib"
+    "$ENV{ProgramFiles}/Tcl/Lib"
+    "C:/Program Files/Tcl/lib"
+    "C:/Tcl/lib"
+    )
+
+  set(TCLTK_POSSIBLE_INCLUDE_PATHS ${TCLTK_POSSIBLE_INCLUDE_PATHS}
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\ActiveState\\ActiveTcl\\${ActiveTcl_CurrentVersion}]/include"
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\Scriptics\\Tcl\\8.6;Root]/include"
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\Scriptics\\Tcl\\8.5;Root]/include"
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\Scriptics\\Tcl\\8.4;Root]/include"
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\Scriptics\\Tcl\\8.3;Root]/include"
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\Scriptics\\Tcl\\8.2;Root]/include"
+    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\Scriptics\\Tcl\\8.0;Root]/include"
+    "$ENV{ProgramFiles}/Tcl/include"
+    "C:/Program Files/Tcl/include"
+    "C:/Tcl/include"
+    )
+endif()
+
+set(TCL_TCLSH_NAMES
+  tclsh
+  tclsh${TCL_LIBRARY_VERSION} tclsh${TK_LIBRARY_VERSION} tclsh${TK_WISH_VERSION}
+  tclsh87 tclsh8.7
+  tclsh86 tclsh8.6
+  tclsh85 tclsh8.5
+  tclsh84 tclsh8.4
+  tclsh83 tclsh8.3
+  tclsh82 tclsh8.2
+  tclsh80 tclsh8.0
+  )
+if(CYGWIN)
+  set(TCL_TCLSH_NAMES ${TCL_TCLSH_NAMES} cygtclsh83 cygtclsh80)
+endif(CYGWIN)
+
+foreach(search ${_TCL_SEARCHES})
+  find_program(TCL_TCLSH NAMES ${TCL_TCLSH_NAMES} ${${search}} PATH_SUFFIXES bin)
+endforeach()
+if (NOT TCL_TCLSH)
+  find_program(TCL_TCLSH NAMES ${TCL_TCLSH_NAMES} HINTS ${TCLTK_POSSIBLE_BIN_PATHS})
+endif (NOT TCL_TCLSH)
+
+if (TCL_ENABLE_TK)
+  set(TK_WISH_NAMES
+    wish
+    wish${TCL_LIBRARY_VERSION} wish${TK_LIBRARY_VERSION} wish${TCL_TCLSH_VERSION}
+    wish86 wish8.6
+    wish85 wish8.5
+    wish84 wish8.4
+    wish83 wish8.3
+    wish82 wish8.2
+    wish80 wish8.0
+    )
+
+  if(CYGWIN)
+    set(TK_WISH_NAMES ${TK_WISH_NAMES} cygwish80 )
+  endif()
+
+  foreach(search ${_TCL_SEARCHES})
+    find_program(TK_WISH NAMES ${TK_WISH_NAMES} ${${search}} PATH_SUFFIXES bin)
+  endforeach()
+  if (NOT TK_WISH)
+    find_program(TK_WISH	NAMES ${TK_WISH_NAMES} HINTS ${TCLTK_POSSIBLE_BIN_PATHS})
+  endif (NOT TK_WISH)
+endif (TCL_ENABLE_TK)
+
+if(TCLSH_VERSION_STRING)
+  set(TCL_TCLSH_VERSION "${TCLSH_VERSION_STRING}")
+else()
+  get_filename_component(TCL_TCLSH_PATH "${TCL_TCLSH}" PATH)
+  get_filename_component(TCL_TCLSH_PATH_PARENT "${TCL_TCLSH_PATH}" PATH)
+  string(REGEX REPLACE
+    "^.*tclsh([0-9]\\.*[0-9]).*$" "\\1" TCL_TCLSH_VERSION "${TCL_TCLSH}")
+endif()
+
+set(TCLTK_POSSIBLE_LIB_PATHS
+  "${TCL_INCLUDE_PATH_PARENT}/lib"
+  "${TCL_LIBRARY_PATH}"
+  "${TCL_TCLSH_PATH_PARENT}/lib"
+  )
+if (TCL_ENABLE_TK)
+  set(TCLTK_POSSIBLE_LIB_PATHS
+    ${TCLTK_POSSIBLE_LIB_PATHS}
+    "${TK_INCLUDE_PATH_PARENT}/lib"
+    "${TK_LIBRARY_PATH}"
+    "${TK_WISH_PATH_PARENT}/lib"
+    )
+endif (TCL_ENABLE_TK)
+
+set(TCLTK_POSSIBLE_LIB_PATH_SUFFIXES
+  lib
+  lib/tcl
+  lib/tcl/tcl8.7
+  lib/tcl/tcl8.6
+  lib/tcl/tcl8.5
+  lib/tcl/tcl8.4
+  )
+if (TCL_ENABLE_TK)
+  set(TCLTK_POSSIBLE_LIB_PATH_SUFFIXES
+    ${TCLTK_POSSIBLE_LIB_PATH_SUFFIXES}
+    lib/tcl/tk8.7
+    lib/tcl/tk8.6
+    lib/tcl/tk8.5
+    lib/tcl/tk8.4
+    )
+endif (TCL_ENABLE_TK)
+
+set(TCL_POSSIBLE_LIB_NAMES
+  tcl
+  tcl${TCL_LIBRARY_VERSION} tcl${TCL_TCLSH_VERSION} tcl${TK_WISH_VERSION}
+  tcl87 tcl8.7 tcl87t tcl8.7t
+  tcl86 tcl8.6 tcl86t tcl8.6t
+  tcl85 tcl8.5
+  tcl84 tcl8.4
+  tcl83 tcl8.3
+  tcl82 tcl8.2
+  tcl80 tcl8.0
+  )
+
+if(NOT TCL_LIBRARY)
+  foreach(search ${_TCL_SEARCHES})
+    find_library(TCL_LIBRARY
+      NAMES ${TCL_POSSIBLE_LIB_NAMES}
+      NAMES_PER_DIR ${${search}}
+      PATH_SUFFIXES ${TCLTK_POSSIBLE_LIB_PATH_SUFFIXES})
+  endforeach()
+endif()
+if(NOT TCL_LIBRARY)
+  find_library(TCL_LIBRARY
+    NAMES ${TCL_POSSIBLE_LIB_NAMES}
+    PATHS ${TCLTK_POSSIBLE_LIB_PATHS}
+    PATH_SUFFIXES ${TCLTK_POSSIBLE_LIB_PATH_SUFFIXES}
+    )
+endif(NOT TCL_LIBRARY)
+
+set(TCLSTUB_POSSIBLE_LIB_NAMES
+  tclstub
+  tclstub${TK_LIBRARY_VERSION} tclstub${TCL_TCLSH_VERSION} tclstub${TK_WISH_VERSION}
+  tclstub87 tclstub8.7
+  tclstub86 tclstub8.6
+  tclstub85 tclstub8.5
+  tclstub84 tclstub8.4
+  tclstub83 tclstub8.3
+  tclstub82 tclstub8.2
+  tclstub80 tclstub8.0
+  )
+if(NOT TCL_STUB_LIBRARY)
+  foreach(search ${_TCL_SEARCHES})
+    find_library(TCL_STUB_LIBRARY
+      NAMES ${TCLSTUB_POSSIBLE_LIB_NAMES}
+      NAMES_PER_DIR ${${search}}
+      PATH_SUFFIXES ${TCLTK_POSSIBLE_LIB_PATH_SUFFIXES}
+      )
+  endforeach()
+endif()
+if(NOT TCL_STUB_LIBRARY)
+  find_library(TCL_STUB_LIBRARY
+    NAMES ${TCLSTUB_POSSIBLE_LIB_NAMES}
+    PATHS ${TCLTK_POSSIBLE_LIB_PATHS}
+    )
+endif()
+
+if (TCL_ENABLE_TK)
+  set(TK_POSSIBLE_LIB_NAMES
+    tk
+    tk${TK_LIBRARY_VERSION} tk${TCL_TCLSH_VERSION} tk${TK_WISH_VERSION}
+    tk87 tk8.7 tk87t tk8.7t
+    tk86 tk8.6 tk86t tk8.6t
+    tk85 tk8.5
+    tk84 tk8.4
+    tk83 tk8.3
+    tk82 tk8.2
+    tk80 tk8.0
+    )
+
+  if(NOT TK_LIBRARY)
+    foreach(search ${_TCL_SEARCHES})
+      find_library(TK_LIBRARY
+	NAMES ${TK_POSSIBLE_LIB_NAMES}
+	NAMES_PER_DIR ${${search}}
+	PATH_SUFFIXES ${TCLTK_POSSIBLE_LIB_PATH_SUFFIXES}
+	)
+    endforeach()
+  endif()
+  if(NOT TK_LIBRARY)
+    find_library(TK_LIBRARY
+      NAMES ${TK_POSSIBLE_LIB_NAMES}
+      PATHS ${TCLTK_POSSIBLE_LIB_PATHS}
+      PATH_SUFFIXES ${TCLTK_POSSIBLE_LIB_PATH_SUFFIXES}
+      )
+  endif(NOT TK_LIBRARY)
+
+  set(TK_STUB_POSSIBLE_LIB_NAMES
+    tkstub
+    tkstub${TCL_LIBRARY_VERSION} tkstub${TCL_TCLSH_VERSION} tkstub${TK_WISH_VERSION}
+    tkstub87 tkstub8.7
+    tkstub86 tkstub8.6
+    tkstub85 tkstub8.5
+    tkstub84 tkstub8.4
+    tkstub83 tkstub8.3
+    tkstub82 tkstub8.2
+    tkstub80 tkstub8.0
+    )
+
+  if(NOT TK_STUB_LIBRARY)
+    foreach(search ${_TCL_SEARCHES})
+      find_library(TK_STUB_LIBRARY
+	NAMES ${TK_STUB_POSSIBLE_LIB_NAMES}
+	NAMES_PER_DIR ${${search}}
+	PATH_SUFFIXES ${TCLTK_POSSIBLE_LIB_PATH_SUFFIXES}
+	)
+    endforeach()
+  endif()
+  if(NOT TK_STUB_LIBRARY)
+    find_library(TK_STUB_LIBRARY
+      NAMES ${TK_STUB_POSSIBLE_LIB_NAMES}
+      PATHS ${TCLTK_POSSIBLE_LIB_PATHS}
+      )
+  endif()
+
+  set(TTK_STUB_POSSIBLE_LIB_NAMES
+    ttkstub
+    ttkstub${TCL_LIBRARY_VERSION} ttkstub${TCL_TCLSH_VERSION} ttkstub${TK_WISH_VERSION}
+    ttkstub88 ttkstub8.8
+    ttkstub87 ttkstub8.7
+    ttkstub86 ttkstub8.6
+    ttkstub85 ttkstub8.5
+    )
+
+  if(NOT TTK_STUB_LIBRARY)
+    foreach(search ${_TCL_SEARCHES})
+      find_library(TTK_STUB_LIBRARY
+	NAMES ${TTK_STUB_POSSIBLE_LIB_NAMES}
+	NAMES_PER_DIR ${${search}}
+	PATH_SUFFIXES ${TCLTK_POSSIBLE_LIB_PATH_SUFFIXES}
+	)
+    endforeach()
+  endif()
+  if(NOT TTK_STUB_LIBRARY)
+    find_library(TTK_STUB_LIBRARY
+      NAMES ${TTK_STUB_POSSIBLE_LIB_NAMES}
+      PATHS ${TCLTK_POSSIBLE_LIB_PATHS}
+      )
+  endif()
+endif (TCL_ENABLE_TK)
+
+CMAKE_FIND_FRAMEWORKS(Tcl)
+if (TCL_ENABLE_TK)
+  CMAKE_FIND_FRAMEWORKS(Tk)
+endif (TCL_ENABLE_TK)
+
+set(TCL_FRAMEWORK_INCLUDES)
+if(Tcl_FRAMEWORKS)
+  if(NOT TCL_INCLUDE_PATH)
+    foreach(dir ${Tcl_FRAMEWORKS})
+      set(TCL_FRAMEWORK_INCLUDES ${TCL_FRAMEWORK_INCLUDES} ${dir}/Headers)
+    endforeach()
+  endif()
+endif()
+
+if (TCL_ENABLE_TK)
+  set(TK_FRAMEWORK_INCLUDES)
+  if(Tk_FRAMEWORKS)
+    if(NOT TK_INCLUDE_PATH)
+      foreach(dir ${Tk_FRAMEWORKS})
+	set(TK_FRAMEWORK_INCLUDES ${TK_FRAMEWORK_INCLUDES}
+	  ${dir}/Headers ${dir}/PrivateHeaders)
+      endforeach()
+    endif()
+  endif()
+endif (TCL_ENABLE_TK)
+
+set(TCLTK_POSSIBLE_INCLUDE_PATHS
+  "${TCL_LIBRARY_PATH_PARENT}/include"
+  "${TCL_INCLUDE_PATH}"
+  ${TCL_FRAMEWORK_INCLUDES}
+  "${TCL_TCLSH_PATH_PARENT}/include"
+  )
+if (TCL_ENABLE_TK)
+  set(TCLTK_POSSIBLE_INCLUDE_PATHS
+    ${TCLTK_POSSIBLE_INCLUDE_PATHS}
+    "${TCL_LIBRARY_PATH_PARENT}/include"
+    "${TCL_INCLUDE_PATH}"
+    ${TCL_FRAMEWORK_INCLUDES}
+    "${TCL_TCLSH_PATH_PARENT}/include"
+    )
+endif (TCL_ENABLE_TK)
+
+set(TCLTK_POSSIBLE_INCLUDE_PATH_SUFFIXES
+  include
+  include/tcl${TCL_LIBRARY_VERSION}
+  include/tcl8.7
+  include/tcl8.6
+  include/tcl8.5
+  include/tcl8.4
+  include/tcl8.3
+  include/tcl8.2
+  include/tcl8.0
+  )
+
+if (TCL_ENABLE_TK)
+  set(TCLTK_POSSIBLE_INCLUDE_PATH_SUFFIXES
+    ${TCLTK_POSSIBLE_INCLUDE_PATH_SUFFIXES}
+    include/tcl${TK_LIBRARY_VERSION}
+    include/tk8.7
+    include/tk8.6
+    include/tk8.5
+    include/tk8.4
+    )
+endif (TCL_ENABLE_TK)
+
+
+foreach(search ${_TCL_SEARCHES})
+  find_path(TCL_INCLUDE_PATH
+    NAMES tcl.h ${${search}}
+    PATH_SUFFIXES ${TCLTK_POSSIBLE_INCLUDE_PATH_SUFFIXES}
+    )
+endforeach()
+if (NOT TCL_INCLUDE_PATH)
+  find_path(TCL_INCLUDE_PATH
+    NAMES tcl.h
+    HINTS ${TCLTK_POSSIBLE_INCLUDE_PATHS}
+    PATH_SUFFIXES ${TCLTK_POSSIBLE_INCLUDE_PATH_SUFFIXES}
+    )
+endif()
+
+if (TCL_ENABLE_TK)
+
+  foreach(search ${_TCL_SEARCHES})
+    find_path(TK_INCLUDE_PATH
+      NAMES tk.h ${${search}}
+      PATH_SUFFIXES ${TCLTK_POSSIBLE_INCLUDE_PATH_SUFFIXES}
+      )
+  endforeach()
+  if (NOT TK_INCLUDE_PATH)
+    find_path(TK_INCLUDE_PATH
+      NAMES tk.h
+      HINTS ${TCLTK_POSSIBLE_INCLUDE_PATHS}
+      PATH_SUFFIXES ${TCLTK_POSSIBLE_INCLUDE_PATH_SUFFIXES}
+      )
+  endif()
+
+  # IFF we have TCL_TK_SYSTEM_GRAPHICS set and have a system TK_WISH, check that the
+  # windowing system matches the specified type
+  if (NOT "${TCL_TK_SYSTEM_GRAPHICS}" STREQUAL "" AND TK_WISH AND NOT TARGET "${TK_WISH}")
+    set(tkwin_script "
+    set filename \"${CMAKE_BINARY_DIR}/CMakeTmp/TK_WINDOWINGSYSTEM\"
+    set fileId [open $filename \"w\"]
+    set windowingsystem [tk windowingsystem]
+    puts $fileId $windowingsystem
+    close $fileId
+    exit
+    ")
+    set(tkwin_scriptfile "${CMAKE_BINARY_DIR}/CMakeTmp/tk_windowingsystem.tcl")
+    set(WSYS "wm-NOTFOUND")
+    file(WRITE ${tkwin_scriptfile} ${tkwin_script})
+    execute_process(COMMAND ${TK_WISH} ${tkwin_scriptfile} OUTPUT_VARIABLE EXECOUTPUT)
+    if (EXISTS "${CMAKE_BINARY_DIR}/CMakeTmp/TK_WINDOWINGSYSTEM")
+      file(READ "${CMAKE_BINARY_DIR}/CMakeTmp/TK_WINDOWINGSYSTEM" readresultvar)
+      string(REGEX REPLACE "\n" "" WSYS "${readresultvar}")
+    endif (EXISTS "${CMAKE_BINARY_DIR}/CMakeTmp/TK_WINDOWINGSYSTEM")
+
+    # If we have no information about the windowing system or it does not match
+    # a specified system, the find_package detection has failed
+    if (NOT "${WSYS}" STREQUAL "${TCL_TK_SYSTEM_GRAPHICS}")
+      unset(TCL_LIBRARY CACHE)
+      unset(TCL_STUB_LIBRARY CACHE)
+      unset(TK_LIBRARY CACHE)
+      unset(TK_STUB_LIBRARY CACHE)
+      unset(TCL_FOUND CACHE)
+      unset(TK_FOUND CACHE)
+      unset(TCLTK_FOUND CACHE)
+      unset(TCLSH_FOUND CACHE)
+      unset(TCL_LIBRARY CACHE)
+      unset(TCL_INCLUDE_PATH CACHE)
+      unset(TCL_TCLSH CACHE)
+      unset(TK_LIBRARY CACHE)
+      unset(TK_INCLUDE_PATH CACHE)
+      unset(TK_WISH CACHE)
+      unset(TCL_STUB_LIBRARY CACHE)
+      unset(TK_STUB_LIBRARY CACHE)
+      unset(TTK_STUB_LIBRARY CACHE)
+    endif (NOT "${WSYS}" STREQUAL "${TCL_TK_SYSTEM_GRAPHICS}")
+  endif (NOT "${TCL_TK_SYSTEM_GRAPHICS}" STREQUAL "" AND TK_WISH AND NOT TARGET "${TK_WISH}")
+endif (TCL_ENABLE_TK)
+
+include(FindPackageHandleStandardArgs)
+
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(TCL
+  REQUIRED_VARS TCL_LIBRARY TCL_STUB_LIBRARY TCL_INCLUDE_PATH TCL_TCLSH
+  VERSION_VAR TCLSH_VERSION_STRING)
+
+if (TCL_ENABLE_TK)
+  set(FPHSA_NAME_MISMATCHED 1)
+  set(TCLTK_FIND_REQUIRED ${TCL_FIND_REQUIRED})
+  set(TCLTK_FIND_QUIETLY  ${TCL_FIND_QUIETLY})
+  FIND_PACKAGE_HANDLE_STANDARD_ARGS(TCLTK
+    REQUIRED_VARS TCL_LIBRARY TCL_STUB_LIBRARY TCL_INCLUDE_PATH TK_LIBRARY TK_STUB_LIBRARY TK_INCLUDE_PATH)
+  set(TK_FIND_REQUIRED ${TCL_FIND_REQUIRED})
+  set(TK_FIND_QUIETLY  ${TCL_FIND_QUIETLY})
+  FIND_PACKAGE_HANDLE_STANDARD_ARGS(TK
+    REQUIRED_VARS TK_LIBRARY TK_STUB_LIBRARY TK_INCLUDE_PATH TK_WISH)
+  unset(FPHSA_NAME_MISMATCHED)
+endif (TCL_ENABLE_TK)
+
+mark_as_advanced(
+  TCL_INCLUDE_PATH
+  TCL_LIBRARY
+  TCL_STUB_LIBRARY
+  TCL_TCLSH
+  TK_INCLUDE_PATH
+  TK_LIBRARY
+  TK_STUB_LIBRARY
+  TK_WISH
+  TTK_STUB_LIBRARY
+  )
+
+
+# Local Variables:
+# tab-width: 8
+# mode: cmake
+# indent-tabs-mode: t
+# End:
+# ex: shiftwidth=2 tabstop=8
diff -Naur itk/CMake/FindITCL.cmake ITK_BLD/CMake/FindITCL.cmake
--- itk/CMake/FindITCL.cmake	2025-03-04 03:14:25
+++ ITK_BLD/CMake/FindITCL.cmake	2025-03-04 02:33:42
@@ -0,0 +1,118 @@
+# Distributed under the OSI-approved BSD 3-Clause License.  See accompanying
+# file Copyright.txt or https://cmake.org/licensing for details.
+
+#[=======================================================================[.rst:
+FindTCL
+-------
+
+This module finds if Tcl is installed and determines where the include
+files and libraries are.  It also determines what the name of the
+library is.  This code sets the following variables:
+
+::
+
+ITCL_FOUND              = Tcl was found
+ITCL_LIBRARY            = path to Tcl library (tcl tcl80)
+ITCL_INCLUDE_PATH       = path to where tcl.h can be found
+ITCL_STUB_LIBRARY       = path to Tcl stub library
+
+#]=======================================================================]
+
+
+set(_ITCL_SEARCHES)
+
+# Search ITCL_ROOT first if it is set.
+if(ITCL_ROOT)
+  set(_ITCL_SEARCH_ROOT PATHS ${ITCL_ROOT} NO_DEFAULT_PATH)
+  list(APPEND _ITCL_SEARCHES _ITCL_SEARCH_ROOT)
+endif()
+
+set(ITCL_POSSIBLE_LIB_PATH_SUFFIXES
+  lib
+  lib/itcl
+  lib/itcl3.4
+  itcl
+  itcl3.4
+  )
+
+set(ITCL_POSSIBLE_LIB_NAMES
+  itcl
+  itcl3
+  itcl3.4
+  )
+
+if(NOT ITCL_LIBRARY)
+  foreach(search ${_ITCL_SEARCHES})
+    find_library(ITCL_LIBRARY
+      NAMES ${ITCL_POSSIBLE_LIB_NAMES}
+      NAMES_PER_DIR ${${search}}
+      PATH_SUFFIXES ${ITCL_POSSIBLE_LIB_PATH_SUFFIXES})
+  endforeach()
+endif()
+if(NOT ITCL_LIBRARY)
+  find_library(ITCL_LIBRARY
+    NAMES ${ITCL_POSSIBLE_LIB_NAMES}
+    PATH_SUFFIXES ${ITCL_POSSIBLE_LIB_PATH_SUFFIXES}
+    )
+endif(NOT ITCL_LIBRARY)
+
+set(ITCLSTUB_POSSIBLE_LIB_NAMES
+  itclstub
+  itclstub3
+  itclstub3.4
+  )
+if(NOT ITCL_STUB_LIBRARY)
+  foreach(search ${_ITCL_SEARCHES})
+    find_library(ITCL_STUB_LIBRARY
+      NAMES ${ITCLSTUB_POSSIBLE_LIB_NAMES}
+      NAMES_PER_DIR ${${search}}
+      PATH_SUFFIXES ${ITCL_POSSIBLE_LIB_PATH_SUFFIXES}
+      )
+  endforeach()
+endif()
+if(NOT ITCL_STUB_LIBRARY)
+  find_library(ITCL_STUB_LIBRARY
+    NAMES ${ITCLSTUB_POSSIBLE_LIB_NAMES}
+    PATH_SUFFIXES ${ITCL_POSSIBLE_LIB_PATH_SUFFIXES}
+    )
+endif()
+
+set(ITCL_POSSIBLE_INCLUDE_PATH_SUFFIXES
+  include
+  include/itcl
+  include/itcl3
+  include/itcl3.4
+  )
+
+foreach(search ${_ITCL_SEARCHES})
+  find_path(ITCL_INCLUDE_PATH
+    NAMES itcl.h ${${search}}
+    PATH_SUFFIXES ${ITCL_POSSIBLE_INCLUDE_PATH_SUFFIXES}
+    )
+endforeach()
+if (NOT ITCL_INCLUDE_PATH)
+  find_path(ITCL_INCLUDE_PATH
+    NAMES itcl.h
+    HINTS ${ITCL_POSSIBLE_INCLUDE_PATHS}
+    )
+endif()
+
+include(FindPackageHandleStandardArgs)
+
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(ITCL
+  REQUIRED_VARS ITCL_LIBRARY ITCL_STUB_LIBRARY ITCL_INCLUDE_PATH
+  )
+
+mark_as_advanced(
+  ITCL_INCLUDE_PATH
+  ITCL_LIBRARY
+  ITCL_STUB_LIBRARY
+  )
+
+# Local Variables:
+# tab-width: 8
+# mode: cmake
+# indent-tabs-mode: t
+# End:
+# ex: shiftwidth=2 tabstop=8
+
diff -Naur itk/CMakeLists.txt ITK_BLD/CMakeLists.txt
--- itk/CMakeLists.txt	1969-12-31 19:00:00.000000000 -0500
+++ ITK_BLD/CMakeLists.txt	2024-07-10 11:14:36.054324121 -0400
@@ -0,0 +1,280 @@
+#                     C M A K E L I S T S . T X T
+# ITK
+#
+# Copyright (c) 2010 United States Government as represented by
+# the U.S. Army Research Laboratory.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above
+# copyright notice, this list of conditions and the following
+# disclaimer in the documentation and/or other materials provided
+# with the distribution.
+#
+# 3. The name of the author may not be used to endorse or promote
+# products derived from this software without specific prior written
+# permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+# *******************************************************************
+# ***                    Itk CMakeLists.txt                       ***
+# *******************************************************************
+
+# Minimum required version of CMake
+cmake_minimum_required(VERSION 3.12)
+
+# set CMake project name
+project(ITK)
+
+# install(CODE) uses generator expressions - requires 3.14 or newer.
+# We want it to be on, but until we can bump our minimum requirement
+# set it to OLD to make sure we don't break anything.
+if (POLICY CMP0087)
+  cmake_policy(SET CMP0087 OLD)
+endif (POLICY CMP0087)
+
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/CMake")
+
+set(CMAKE_FIND_FRAMEWORK NEVER)
+find_package(TCL REQUIRED)
+find_package(ITCL REQUIRED)
+
+# version numbers
+set(ITK_VERSION_MAJOR 3)
+set(ITK_VERSION_MINOR 4)
+set(ITK_PATCH_LEVEL 2)
+set(ITK_VERSION "${ITK_VERSION_MAJOR}.${ITK_VERSION_MINOR}")
+
+#---------------------------------------------------------------------
+# Initialize some relative variable names
+if(NOT BIN_DIR)
+  if (WIN32)
+    set(BIN_DIR lib)
+  else (WIN32)
+    set(BIN_DIR bin)
+  endif (WIN32)
+endif(NOT BIN_DIR)
+if(NOT SHARED_DIR)
+  set(SHARED_DIR lib)
+endif(NOT SHARED_DIR)
+if(NOT LIB_DIR)
+  set(LIB_DIR lib)
+endif(NOT LIB_DIR)
+if(NOT INCLUDE_DIR)
+  set(INCLUDE_DIR include)
+endif(NOT INCLUDE_DIR)
+
+#----------------------------------------------------------------------------
+# First, get some standard options out of the way
+add_definitions(-DSTDC_HEADERS=1)
+
+# We're building Itk
+add_definitions(-DBUILD_itk)
+
+# We want to check /usr/local by default, so add it if it exists.  (We need
+# this to find X11 headers on FreeBSD, for example...)
+if (IS_DIRECTORY /usr/local)
+  set(CMAKE_PREFIX_PATH ${CMAKE_PREFIX_PATH} /usr/local)
+  if (IS_DIRECTORY /usr/local/include)
+    set(CMAKE_REQUIRED_INCLUDES ${CMAKE_REQUIRED_INCLUDES} /usr/local/include)
+  endif (IS_DIRECTORY /usr/local/include)
+endif (IS_DIRECTORY /usr/local)
+
+#--------------------------------------------------------------------
+# We need to enable the threading macros found in tcl.h and tclInt.h.
+# The use of the threading features is determined by the core the
+# extension is loaded into, but we need to compile with these macros
+# turned on.
+#--------------------------------------------------------------------
+add_definitions(-DTCL_THREADS=1)
+
+include(CMakeParseArguments)
+include(CheckIncludeFiles)
+include(CheckCSourceCompiles)
+function(Tcl_Check_Include_File filename)
+  cmake_parse_arguments(OPT "USE" "" "" ${ARGN})
+  string(REPLACE "." "_" var "${filename}")
+  string(REPLACE "/" "_" var "${var}")
+  string(TOUPPER "${var}" var)
+  check_include_files(${filename} HAVE_${var})
+  if(HAVE_${var})
+    set(CVAR HAVE_${var})
+    if(OPT_USE)
+      # Usability test requested - we're not done yet.
+      check_c_source_compiles("#include <${filename}>\nint main() {return 0;}" ${var}_USABLE)
+      if(${var}_USABLE)
+	set(HAVE_${var} 1 PARENT_SCOPE)
+	set(${CVAR} 1 PARENT_SCOPE)
+	add_definitions(-D${CVAR}=1)
+      endif(${var}_USABLE)
+    else(OPT_USE)
+      set(HAVE_${var} 1 PARENT_SCOPE)
+      set(${CVAR} 1 PARENT_SCOPE)
+      add_definitions(-D${CVAR}=1)
+    endif(OPT_USE)
+  endif(HAVE_${var})
+endfunction(Tcl_Check_Include_File)
+
+Tcl_Check_Include_File(dlfcn.h USE)
+Tcl_Check_Include_File(errno.h USE)
+Tcl_Check_Include_File(float.h USE)
+Tcl_Check_Include_File(inttypes.h)
+Tcl_Check_Include_File(limits.h USE)
+Tcl_Check_Include_File(memory.h)
+Tcl_Check_Include_File(net/errno.h USE)
+Tcl_Check_Include_File(stdint.h)
+Tcl_Check_Include_File(stdlib.h)
+Tcl_Check_Include_File(string.h)
+Tcl_Check_Include_File(strings.h)
+Tcl_Check_Include_File(sys/param.h USE)
+Tcl_Check_Include_File(sys/stat.h)
+Tcl_Check_Include_File(sys/types.h)
+Tcl_Check_Include_File(sys/wait.h USE)
+Tcl_Check_Include_File(unistd.h)
+Tcl_Check_Include_File(values.h USE)
+
+# TODO - for now, we need X11 on both *nix and Mac platforms.
+# Eventually we'll need to re-enable support for Aqua on Mac...
+if(NOT WIN32)
+  find_package(X11)
+endif()
+
+set(ITK_SRCS
+  generic/itkStubInit.c
+  generic/itkStubLib.c
+  generic/itk_archetype.c
+  generic/itk_cmds.c
+  generic/itk_option.c
+  generic/itk_util.c
+  )
+
+if(WIN32)
+  set(ITK_SRCS ${ITK_SRCS} win/dllEntryPoint.c)
+endif(WIN32)
+
+set(ITK_STUB_SRCS generic/itkStubLib.c)
+
+set(ITK_INCLUDE_DIRS ${ITK_SOURCE_DIR}/generic ${ITK_BINARY_DIR}/include)
+mark_as_advanced(ITK_INCLUDE_DIRS)
+
+
+# Like ITcl, Itk requires private Tcl headers
+# At least one Linux distro puts what we need here
+set(HDRS_CANDIDATE_DIR ${TCL_INCLUDE_PATH}8.6/tcl-private)
+if (EXISTS ${HDRS_CANDIDATE_DIR})
+  set(TCL_PRIVATE_HDRS ${HDRS_CANDIDATE_DIR}/generic)
+  if(NOT WIN32)
+    set(TCL_PRIVATE_HDRS ${TCL_PRIVATE_HDRS} ${HDRS_CANDIDATE_DIR}/unix)
+  else(NOT WIN32)
+    set(TCL_PRIVATE_HDRS ${TCL_PRIVATE_HDRS} ${HDRS_CANDIDATE_DIR}/win)
+  endif(NOT WIN32)
+endif ()
+# Itk also requires private Tk headers
+set(HDRS_CANDIDATE_DIR ${TCL_INCLUDE_PATH}8.6/tk-private)
+if (EXISTS ${HDRS_CANDIDATE_DIR})
+  set(TCL_PRIVATE_HDRS ${TCL_PRIVATE_HDRS} ${HDRS_CANDIDATE_DIR}/generic)
+  if(NOT WIN32)
+    set(TCL_PRIVATE_HDRS ${TCL_PRIVATE_HDRS} ${HDRS_CANDIDATE_DIR}/unix)
+  else(NOT WIN32)
+    set(TCL_PRIVATE_HDRS ${TCL_PRIVATE_HDRS} ${HDRS_CANDIDATE_DIR}/win)
+  endif(NOT WIN32)
+endif ()
+
+# If we don't have what we need, see if we know where to find
+# a source directory
+if (NOT TCL_PRIVATE_HDRS)
+  if (NOT DEFINED TCL_SOURCE_DIR)
+    message(FATAL_ERROR "Itk3 needs to know where to find the Tcl source directory")
+  endif (NOT DEFINED TCL_SOURCE_DIR)
+  set(TCL_PRIVATE_HDRS ${TCL_SOURCE_DIR}/generic)
+  if(NOT WIN32)
+    set(TCL_PRIVATE_HDRS ${TCL_PRIVATE_HDRS} ${TCL_SOURCE_DIR}/unix)
+  else(NOT WIN32)
+    set(TCL_PRIVATE_HDRS ${TCL_PRIVATE_HDRS} ${TCL_SOURCE_DIR}/win)
+  endif(NOT WIN32)
+  if (NOT DEFINED TK_SOURCE_DIR)
+    message(FATAL_ERROR "Itk3 needs to know where to find the Tk source directory")
+  endif (NOT DEFINED TK_SOURCE_DIR)
+  if(WIN32)
+    set(TCL_PRIVATE_HDRS ${TCL_PRIVATE_HDRS} ${TK_SOURCE_DIR}/xlib)
+  endif(WIN32)
+endif (NOT TCL_PRIVATE_HDRS)
+
+include_directories(
+  # Itcl3 is iffy as a system install - just reference the local copy
+  ${CMAKE_SOURCE_DIR}/generic/itcl3
+  ${TCL_INCLUDE_PATH}
+  ${TK_INCLUDE_PATH}
+  ${ITCL_INCLUDE_PATH}
+  ${ITK_INCLUDE_DIRS}
+  ${X11_INCLUDE_DIR}
+  ${TCL_PRIVATE_HDRS}
+  )
+
+add_library(itk${ITK_VERSION} SHARED ${ITK_SRCS})
+target_link_libraries(itk${ITK_VERSION} ${M_LIBRARY} ${TCL_STUB_LIBRARY} ${TK_STUB_LIBRARY} ${ITCL_STUB_LIBRARY})
+set_property(TARGET itk${ITK_VERSION} APPEND PROPERTY COMPILE_DEFINITIONS USE_TCL_STUBS)
+set_property(TARGET itk${ITK_VERSION} APPEND PROPERTY COMPILE_DEFINITIONS USE_ITCL_STUBS)
+set_property(TARGET itk${ITK_VERSION} APPEND PROPERTY COMPILE_DEFINITIONS USE_TK_STUBS)
+install(TARGETS itk${ITK_VERSION}
+  RUNTIME DESTINATION ${BIN_DIR}/itk${ITK_VERSION}
+  LIBRARY DESTINATION ${SHARED_DIR}/itk${ITK_VERSION}
+  ARCHIVE DESTINATION ${LIB_DIR}/itk${ITK_VERSION})
+
+add_library(itkstub STATIC ${ITK_STUB_SRCS})
+target_link_libraries(itkstub ${ITCL_STUB_LIBRARY} ${TCL_STUB_LIBRARY} ${TK_STUB_LIBRARY})
+set_property(TARGET itkstub APPEND PROPERTY COMPILE_DEFINITIONS USE_TCL_STUBS)
+set_property(TARGET itkstub APPEND PROPERTY COMPILE_DEFINITIONS USE_ITCL_STUBS)
+set_property(TARGET itkstub APPEND PROPERTY COMPILE_DEFINITIONS USE_TK_STUBS)
+install(TARGETS itkstub
+  RUNTIME DESTINATION ${BIN_DIR}/itk${ITK_VERSION}
+  LIBRARY DESTINATION ${LIB_DIR}/itk${ITK_VERSION}
+  ARCHIVE DESTINATION ${LIB_DIR}/itk${ITK_VERSION})
+
+# Create pkgIndex.tcl files
+file(GENERATE
+  OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/pkgIndex.tcl"
+  CONTENT "
+if {![package vsatisfies [package provide Tcl] 8.5]} {return}
+package ifneeded Itk ${ITK_VERSION} [list load [file join $dir ../../${SHARED_DIR}/itk${ITK_VERSION} $<TARGET_FILE_NAME:itk${ITK_VERSION}>] Itk]
+")
+install(FILES ${CMAKE_CURRENT_BINARY_DIR}/pkgIndex.tcl DESTINATION ${LIB_DIR}/itk${ITK_VERSION})
+
+set(ITK_LIBRARY_FILES
+  library/Archetype.itk
+  library/Toplevel.itk
+  library/Widget.itk
+  library/itk.tcl
+  library/tclIndex
+  )
+install(FILES ${ITK_LIBRARY_FILES} DESTINATION lib/itk${ITK_VERSION})
+
+set(ITK_HDRS
+  generic/itk.h
+  generic/itkDecls.h
+  )
+install(FILES ${ITK_HDRS} DESTINATION ${INCLUDE_DIR})
+
+# Local Variables:
+# tab-width: 8
+# mode: cmake
+# indent-tabs-mode: t
+# End:
+# ex: shiftwidth=2 tabstop=8
+
diff -Naur itk/generic/itcl3/itclDecls.h ITK_BLD/generic/itcl3/itclDecls.h
--- itk/generic/itcl3/itclDecls.h	1969-12-31 19:00:00.000000000 -0500
+++ ITK_BLD/generic/itcl3/itclDecls.h	2024-07-10 10:40:21.279659891 -0400
@@ -0,0 +1,332 @@
+/*
+ * itclDecls.h --
+ *
+ *	Declarations of functions in the platform independent public Itcl API.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _ITCLDECLS
+#define _ITCLDECLS
+
+/*
+ * WARNING: This file is automatically generated by the tools/genStubs.tcl
+ * script.  Any modifications to the function declarations below should be made
+ * in the itcl/generic/tcl.decls script.
+ */
+
+/* !BEGIN!: Do not edit below this line. */
+
+/*
+ * Exported function declarations:
+ */
+
+#ifndef Itcl_Init_TCL_DECLARED
+#define Itcl_Init_TCL_DECLARED
+/* 0 */
+TCL_EXTERN(int)		Itcl_Init _ANSI_ARGS_((Tcl_Interp * interp));
+#endif
+#ifndef Itcl_SafeInit_TCL_DECLARED
+#define Itcl_SafeInit_TCL_DECLARED
+/* 1 */
+TCL_EXTERN(int)		Itcl_SafeInit _ANSI_ARGS_((Tcl_Interp * interp));
+#endif
+#ifndef Itcl_RegisterC_TCL_DECLARED
+#define Itcl_RegisterC_TCL_DECLARED
+/* 2 */
+TCL_EXTERN(int)		Itcl_RegisterC _ANSI_ARGS_((Tcl_Interp * interp, 
+				CONST char * name, Tcl_CmdProc * proc, 
+				ClientData clientData, 
+				Tcl_CmdDeleteProc * deleteProc));
+#endif
+#ifndef Itcl_RegisterObjC_TCL_DECLARED
+#define Itcl_RegisterObjC_TCL_DECLARED
+/* 3 */
+TCL_EXTERN(int)		Itcl_RegisterObjC _ANSI_ARGS_((Tcl_Interp * interp, 
+				CONST char * name, Tcl_ObjCmdProc * proc, 
+				ClientData clientData, 
+				Tcl_CmdDeleteProc * deleteProc));
+#endif
+#ifndef Itcl_FindC_TCL_DECLARED
+#define Itcl_FindC_TCL_DECLARED
+/* 4 */
+TCL_EXTERN(int)		Itcl_FindC _ANSI_ARGS_((Tcl_Interp * interp, 
+				CONST char * name, Tcl_CmdProc ** argProcPtr, 
+				Tcl_ObjCmdProc ** objProcPtr, 
+				ClientData * cDataPtr));
+#endif
+#ifndef Itcl_InitStack_TCL_DECLARED
+#define Itcl_InitStack_TCL_DECLARED
+/* 5 */
+TCL_EXTERN(void)	Itcl_InitStack _ANSI_ARGS_((Itcl_Stack * stack));
+#endif
+#ifndef Itcl_DeleteStack_TCL_DECLARED
+#define Itcl_DeleteStack_TCL_DECLARED
+/* 6 */
+TCL_EXTERN(void)	Itcl_DeleteStack _ANSI_ARGS_((Itcl_Stack * stack));
+#endif
+#ifndef Itcl_PushStack_TCL_DECLARED
+#define Itcl_PushStack_TCL_DECLARED
+/* 7 */
+TCL_EXTERN(void)	Itcl_PushStack _ANSI_ARGS_((ClientData cdata, 
+				Itcl_Stack * stack));
+#endif
+#ifndef Itcl_PopStack_TCL_DECLARED
+#define Itcl_PopStack_TCL_DECLARED
+/* 8 */
+TCL_EXTERN(ClientData)	Itcl_PopStack _ANSI_ARGS_((Itcl_Stack * stack));
+#endif
+#ifndef Itcl_PeekStack_TCL_DECLARED
+#define Itcl_PeekStack_TCL_DECLARED
+/* 9 */
+TCL_EXTERN(ClientData)	Itcl_PeekStack _ANSI_ARGS_((Itcl_Stack * stack));
+#endif
+#ifndef Itcl_GetStackValue_TCL_DECLARED
+#define Itcl_GetStackValue_TCL_DECLARED
+/* 10 */
+TCL_EXTERN(ClientData)	Itcl_GetStackValue _ANSI_ARGS_((Itcl_Stack * stack, 
+				int pos));
+#endif
+#ifndef Itcl_InitList_TCL_DECLARED
+#define Itcl_InitList_TCL_DECLARED
+/* 11 */
+TCL_EXTERN(void)	Itcl_InitList _ANSI_ARGS_((Itcl_List * listPtr));
+#endif
+#ifndef Itcl_DeleteList_TCL_DECLARED
+#define Itcl_DeleteList_TCL_DECLARED
+/* 12 */
+TCL_EXTERN(void)	Itcl_DeleteList _ANSI_ARGS_((Itcl_List * listPtr));
+#endif
+#ifndef Itcl_CreateListElem_TCL_DECLARED
+#define Itcl_CreateListElem_TCL_DECLARED
+/* 13 */
+TCL_EXTERN(Itcl_ListElem*) Itcl_CreateListElem _ANSI_ARGS_((
+				Itcl_List * listPtr));
+#endif
+#ifndef Itcl_DeleteListElem_TCL_DECLARED
+#define Itcl_DeleteListElem_TCL_DECLARED
+/* 14 */
+TCL_EXTERN(Itcl_ListElem*) Itcl_DeleteListElem _ANSI_ARGS_((
+				Itcl_ListElem * elemPtr));
+#endif
+#ifndef Itcl_InsertList_TCL_DECLARED
+#define Itcl_InsertList_TCL_DECLARED
+/* 15 */
+TCL_EXTERN(Itcl_ListElem*) Itcl_InsertList _ANSI_ARGS_((Itcl_List * listPtr, 
+				ClientData val));
+#endif
+#ifndef Itcl_InsertListElem_TCL_DECLARED
+#define Itcl_InsertListElem_TCL_DECLARED
+/* 16 */
+TCL_EXTERN(Itcl_ListElem*) Itcl_InsertListElem _ANSI_ARGS_((
+				Itcl_ListElem * pos, ClientData val));
+#endif
+#ifndef Itcl_AppendList_TCL_DECLARED
+#define Itcl_AppendList_TCL_DECLARED
+/* 17 */
+TCL_EXTERN(Itcl_ListElem*) Itcl_AppendList _ANSI_ARGS_((Itcl_List * listPtr, 
+				ClientData val));
+#endif
+#ifndef Itcl_AppendListElem_TCL_DECLARED
+#define Itcl_AppendListElem_TCL_DECLARED
+/* 18 */
+TCL_EXTERN(Itcl_ListElem*) Itcl_AppendListElem _ANSI_ARGS_((
+				Itcl_ListElem * pos, ClientData val));
+#endif
+#ifndef Itcl_SetListValue_TCL_DECLARED
+#define Itcl_SetListValue_TCL_DECLARED
+/* 19 */
+TCL_EXTERN(void)	Itcl_SetListValue _ANSI_ARGS_((
+				Itcl_ListElem * elemPtr, ClientData val));
+#endif
+#ifndef Itcl_EventuallyFree_TCL_DECLARED
+#define Itcl_EventuallyFree_TCL_DECLARED
+/* 20 */
+TCL_EXTERN(void)	Itcl_EventuallyFree _ANSI_ARGS_((ClientData cdata, 
+				Tcl_FreeProc * fproc));
+#endif
+#ifndef Itcl_PreserveData_TCL_DECLARED
+#define Itcl_PreserveData_TCL_DECLARED
+/* 21 */
+TCL_EXTERN(void)	Itcl_PreserveData _ANSI_ARGS_((ClientData cdata));
+#endif
+#ifndef Itcl_ReleaseData_TCL_DECLARED
+#define Itcl_ReleaseData_TCL_DECLARED
+/* 22 */
+TCL_EXTERN(void)	Itcl_ReleaseData _ANSI_ARGS_((ClientData cdata));
+#endif
+#ifndef Itcl_SaveInterpState_TCL_DECLARED
+#define Itcl_SaveInterpState_TCL_DECLARED
+/* 23 */
+TCL_EXTERN(Itcl_InterpState) Itcl_SaveInterpState _ANSI_ARGS_((
+				Tcl_Interp* interp, int status));
+#endif
+#ifndef Itcl_RestoreInterpState_TCL_DECLARED
+#define Itcl_RestoreInterpState_TCL_DECLARED
+/* 24 */
+TCL_EXTERN(int)		Itcl_RestoreInterpState _ANSI_ARGS_((
+				Tcl_Interp* interp, Itcl_InterpState state));
+#endif
+#ifndef Itcl_DiscardInterpState_TCL_DECLARED
+#define Itcl_DiscardInterpState_TCL_DECLARED
+/* 25 */
+TCL_EXTERN(void)	Itcl_DiscardInterpState _ANSI_ARGS_((
+				Itcl_InterpState state));
+#endif
+
+typedef struct ItclStubHooks {
+    struct ItclIntStubs *itclIntStubs;
+} ItclStubHooks;
+
+typedef struct ItclStubs {
+    int magic;
+    struct ItclStubHooks *hooks;
+
+    int (*itcl_Init) _ANSI_ARGS_((Tcl_Interp * interp)); /* 0 */
+    int (*itcl_SafeInit) _ANSI_ARGS_((Tcl_Interp * interp)); /* 1 */
+    int (*itcl_RegisterC) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, Tcl_CmdProc * proc, ClientData clientData, Tcl_CmdDeleteProc * deleteProc)); /* 2 */
+    int (*itcl_RegisterObjC) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, Tcl_ObjCmdProc * proc, ClientData clientData, Tcl_CmdDeleteProc * deleteProc)); /* 3 */
+    int (*itcl_FindC) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, Tcl_CmdProc ** argProcPtr, Tcl_ObjCmdProc ** objProcPtr, ClientData * cDataPtr)); /* 4 */
+    void (*itcl_InitStack) _ANSI_ARGS_((Itcl_Stack * stack)); /* 5 */
+    void (*itcl_DeleteStack) _ANSI_ARGS_((Itcl_Stack * stack)); /* 6 */
+    void (*itcl_PushStack) _ANSI_ARGS_((ClientData cdata, Itcl_Stack * stack)); /* 7 */
+    ClientData (*itcl_PopStack) _ANSI_ARGS_((Itcl_Stack * stack)); /* 8 */
+    ClientData (*itcl_PeekStack) _ANSI_ARGS_((Itcl_Stack * stack)); /* 9 */
+    ClientData (*itcl_GetStackValue) _ANSI_ARGS_((Itcl_Stack * stack, int pos)); /* 10 */
+    void (*itcl_InitList) _ANSI_ARGS_((Itcl_List * listPtr)); /* 11 */
+    void (*itcl_DeleteList) _ANSI_ARGS_((Itcl_List * listPtr)); /* 12 */
+    Itcl_ListElem* (*itcl_CreateListElem) _ANSI_ARGS_((Itcl_List * listPtr)); /* 13 */
+    Itcl_ListElem* (*itcl_DeleteListElem) _ANSI_ARGS_((Itcl_ListElem * elemPtr)); /* 14 */
+    Itcl_ListElem* (*itcl_InsertList) _ANSI_ARGS_((Itcl_List * listPtr, ClientData val)); /* 15 */
+    Itcl_ListElem* (*itcl_InsertListElem) _ANSI_ARGS_((Itcl_ListElem * pos, ClientData val)); /* 16 */
+    Itcl_ListElem* (*itcl_AppendList) _ANSI_ARGS_((Itcl_List * listPtr, ClientData val)); /* 17 */
+    Itcl_ListElem* (*itcl_AppendListElem) _ANSI_ARGS_((Itcl_ListElem * pos, ClientData val)); /* 18 */
+    void (*itcl_SetListValue) _ANSI_ARGS_((Itcl_ListElem * elemPtr, ClientData val)); /* 19 */
+    void (*itcl_EventuallyFree) _ANSI_ARGS_((ClientData cdata, Tcl_FreeProc * fproc)); /* 20 */
+    void (*itcl_PreserveData) _ANSI_ARGS_((ClientData cdata)); /* 21 */
+    void (*itcl_ReleaseData) _ANSI_ARGS_((ClientData cdata)); /* 22 */
+    Itcl_InterpState (*itcl_SaveInterpState) _ANSI_ARGS_((Tcl_Interp* interp, int status)); /* 23 */
+    int (*itcl_RestoreInterpState) _ANSI_ARGS_((Tcl_Interp* interp, Itcl_InterpState state)); /* 24 */
+    void (*itcl_DiscardInterpState) _ANSI_ARGS_((Itcl_InterpState state)); /* 25 */
+} ItclStubs;
+
+TCL_EXTERNC ItclStubs *itclStubsPtr;
+
+#if defined(USE_ITCL_STUBS) && !defined(USE_ITCL_STUB_PROCS)
+
+/*
+ * Inline function declarations:
+ */
+
+#ifndef Itcl_Init
+#define Itcl_Init \
+	(itclStubsPtr->itcl_Init) /* 0 */
+#endif
+#ifndef Itcl_SafeInit
+#define Itcl_SafeInit \
+	(itclStubsPtr->itcl_SafeInit) /* 1 */
+#endif
+#ifndef Itcl_RegisterC
+#define Itcl_RegisterC \
+	(itclStubsPtr->itcl_RegisterC) /* 2 */
+#endif
+#ifndef Itcl_RegisterObjC
+#define Itcl_RegisterObjC \
+	(itclStubsPtr->itcl_RegisterObjC) /* 3 */
+#endif
+#ifndef Itcl_FindC
+#define Itcl_FindC \
+	(itclStubsPtr->itcl_FindC) /* 4 */
+#endif
+#ifndef Itcl_InitStack
+#define Itcl_InitStack \
+	(itclStubsPtr->itcl_InitStack) /* 5 */
+#endif
+#ifndef Itcl_DeleteStack
+#define Itcl_DeleteStack \
+	(itclStubsPtr->itcl_DeleteStack) /* 6 */
+#endif
+#ifndef Itcl_PushStack
+#define Itcl_PushStack \
+	(itclStubsPtr->itcl_PushStack) /* 7 */
+#endif
+#ifndef Itcl_PopStack
+#define Itcl_PopStack \
+	(itclStubsPtr->itcl_PopStack) /* 8 */
+#endif
+#ifndef Itcl_PeekStack
+#define Itcl_PeekStack \
+	(itclStubsPtr->itcl_PeekStack) /* 9 */
+#endif
+#ifndef Itcl_GetStackValue
+#define Itcl_GetStackValue \
+	(itclStubsPtr->itcl_GetStackValue) /* 10 */
+#endif
+#ifndef Itcl_InitList
+#define Itcl_InitList \
+	(itclStubsPtr->itcl_InitList) /* 11 */
+#endif
+#ifndef Itcl_DeleteList
+#define Itcl_DeleteList \
+	(itclStubsPtr->itcl_DeleteList) /* 12 */
+#endif
+#ifndef Itcl_CreateListElem
+#define Itcl_CreateListElem \
+	(itclStubsPtr->itcl_CreateListElem) /* 13 */
+#endif
+#ifndef Itcl_DeleteListElem
+#define Itcl_DeleteListElem \
+	(itclStubsPtr->itcl_DeleteListElem) /* 14 */
+#endif
+#ifndef Itcl_InsertList
+#define Itcl_InsertList \
+	(itclStubsPtr->itcl_InsertList) /* 15 */
+#endif
+#ifndef Itcl_InsertListElem
+#define Itcl_InsertListElem \
+	(itclStubsPtr->itcl_InsertListElem) /* 16 */
+#endif
+#ifndef Itcl_AppendList
+#define Itcl_AppendList \
+	(itclStubsPtr->itcl_AppendList) /* 17 */
+#endif
+#ifndef Itcl_AppendListElem
+#define Itcl_AppendListElem \
+	(itclStubsPtr->itcl_AppendListElem) /* 18 */
+#endif
+#ifndef Itcl_SetListValue
+#define Itcl_SetListValue \
+	(itclStubsPtr->itcl_SetListValue) /* 19 */
+#endif
+#ifndef Itcl_EventuallyFree
+#define Itcl_EventuallyFree \
+	(itclStubsPtr->itcl_EventuallyFree) /* 20 */
+#endif
+#ifndef Itcl_PreserveData
+#define Itcl_PreserveData \
+	(itclStubsPtr->itcl_PreserveData) /* 21 */
+#endif
+#ifndef Itcl_ReleaseData
+#define Itcl_ReleaseData \
+	(itclStubsPtr->itcl_ReleaseData) /* 22 */
+#endif
+#ifndef Itcl_SaveInterpState
+#define Itcl_SaveInterpState \
+	(itclStubsPtr->itcl_SaveInterpState) /* 23 */
+#endif
+#ifndef Itcl_RestoreInterpState
+#define Itcl_RestoreInterpState \
+	(itclStubsPtr->itcl_RestoreInterpState) /* 24 */
+#endif
+#ifndef Itcl_DiscardInterpState
+#define Itcl_DiscardInterpState \
+	(itclStubsPtr->itcl_DiscardInterpState) /* 25 */
+#endif
+
+#endif /* defined(USE_ITCL_STUBS) && !defined(USE_ITCL_STUB_PROCS) */
+
+/* !END!: Do not edit above this line. */
+
+#endif /* _ITCLDECLS */
+
diff -Naur itk/generic/itcl3/itcl.h ITK_BLD/generic/itcl3/itcl.h
--- itk/generic/itcl3/itcl.h	1969-12-31 19:00:00.000000000 -0500
+++ ITK_BLD/generic/itcl3/itcl.h	2024-07-10 10:40:21.279659891 -0400
@@ -0,0 +1,217 @@
+/*
+ * ------------------------------------------------------------------------
+ *      PACKAGE:  [incr Tcl]
+ *  DESCRIPTION:  Object-Oriented Extensions to Tcl
+ *
+ *  [incr Tcl] provides object-oriented extensions to Tcl, much as
+ *  C++ provides object-oriented extensions to C.  It provides a means
+ *  of encapsulating related procedures together with their shared data
+ *  in a local namespace that is hidden from the outside world.  It
+ *  promotes code re-use through inheritance.  More than anything else,
+ *  it encourages better organization of Tcl applications through the
+ *  object-oriented paradigm, leading to code that is easier to
+ *  understand and maintain.
+ *  
+ *  ADDING [incr Tcl] TO A Tcl-BASED APPLICATION:
+ *
+ *    To add [incr Tcl] facilities to a Tcl application, modify the
+ *    Tcl_AppInit() routine as follows:
+ *
+ *    1) Include this header file near the top of the file containing
+ *       Tcl_AppInit():
+ *
+ *         #include "itcl.h"
+ *
+ *    2) Within the body of Tcl_AppInit(), add the following lines:
+ *
+ *         if (Itcl_Init(interp) == TCL_ERROR) {
+ *             return TCL_ERROR;
+ *         }
+ * 
+ *    3) Link your application with libitcl.a
+ *
+ *    NOTE:  An example file "tclAppInit.c" containing the changes shown
+ *           above is included in this distribution.
+ *  
+ * ========================================================================
+ *  AUTHOR:  Michael J. McLennan
+ *           Bell Labs Innovations for Lucent Technologies
+ *           mmclennan@lucent.com
+ *           http://www.tcltk.com/itcl
+ * ========================================================================
+ *           Copyright (c) 1993-1998  Lucent Technologies, Inc.
+ * ------------------------------------------------------------------------
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+#ifndef ITCL_H
+#define ITCL_H
+
+#include "tcl.h"
+
+#ifndef TCL_ALPHA_RELEASE
+#   define TCL_ALPHA_RELEASE	0
+#endif
+#ifndef TCL_BETA_RELEASE
+#   define TCL_BETA_RELEASE	1
+#endif
+#ifndef TCL_FINAL_RELEASE
+#   define TCL_FINAL_RELEASE	2
+#endif
+
+
+#define ITCL_MAJOR_VERSION	3
+#define ITCL_MINOR_VERSION	4
+#define ITCL_RELEASE_LEVEL	TCL_FINAL_RELEASE
+#define ITCL_RELEASE_SERIAL	3
+
+#define ITCL_VERSION		"3.4"
+#define ITCL_PATCH_LEVEL	"3.4.3"
+
+/* 
+ * A special definition used to allow this header file to be included 
+ * in resource files so that they can get obtain version information from
+ * this file.  Resource compilers don't like all the C stuff, like typedefs
+ * and procedure declarations, that occur below.
+ */
+
+#ifndef RC_INVOKED
+
+#undef TCL_STORAGE_CLASS
+#ifdef BUILD_itcl
+#   define TCL_STORAGE_CLASS DLLEXPORT
+#else
+#   ifdef USE_ITCL_STUBS
+#	define TCL_STORAGE_CLASS
+#   else
+#	define TCL_STORAGE_CLASS DLLIMPORT
+#   endif
+#endif
+
+/*
+ * Fix the Borland bug that's in the EXTERN macro from tcl.h.
+ */
+#ifndef TCL_EXTERN
+#   undef DLLIMPORT
+#   undef DLLEXPORT
+#   ifdef __cplusplus
+#	define TCL_EXTERNC extern "C"
+#   else
+#	define TCL_EXTERNC extern
+#   endif
+#   if defined(STATIC_BUILD)
+#	define DLLIMPORT
+#	define DLLEXPORT
+#	define TCL_EXTERN(RTYPE) TCL_EXTERNC RTYPE
+#   elif (defined(__WIN32__) && ( \
+	    defined(_MSC_VER) || (__BORLANDC__ >= 0x0550) || \
+	    defined(__LCC__) || defined(__WATCOMC__) || \
+	    (defined(__GNUC__) && defined(__declspec)) \
+	)) || (defined(MAC_TCL) && FUNCTION_DECLSPEC)
+#	define DLLIMPORT __declspec(dllimport)
+#	define DLLEXPORT __declspec(dllexport)
+#	define TCL_EXTERN(RTYPE) TCL_EXTERNC TCL_STORAGE_CLASS RTYPE
+#   elif defined(__BORLANDC__)
+#	define DLLIMPORT __import
+#	define DLLEXPORT __export
+	/* Pre-5.5 Borland requires the attributes be placed after the */
+	/* return type instead. */
+#	define TCL_EXTERN(RTYPE) TCL_EXTERNC RTYPE TCL_STORAGE_CLASS
+#   else
+#	define DLLIMPORT
+#	define DLLEXPORT
+#	define TCL_EXTERN(RTYPE) TCL_EXTERNC TCL_STORAGE_CLASS RTYPE
+#   endif
+#endif
+
+/*
+ * Protection levels:
+ *
+ * ITCL_PUBLIC    - accessible from any namespace
+ * ITCL_PROTECTED - accessible from namespace that imports in "protected" mode
+ * ITCL_PRIVATE   - accessible only within the namespace that contains it
+ */
+#define ITCL_PUBLIC           1
+#define ITCL_PROTECTED        2
+#define ITCL_PRIVATE          3
+#define ITCL_DEFAULT_PROTECT  4
+
+
+/*
+ *  Generic stack.
+ */
+typedef struct Itcl_Stack {
+    ClientData *values;          /* values on stack */
+    int len;                     /* number of values on stack */
+    int max;                     /* maximum size of stack */
+    ClientData space[5];         /* initial space for stack data */
+} Itcl_Stack;
+
+#define Itcl_GetStackSize(stackPtr) ((stackPtr)->len)
+
+/*
+ *  Generic linked list.
+ */
+struct Itcl_List;
+typedef struct Itcl_ListElem {
+    struct Itcl_List* owner;     /* list containing this element */
+    ClientData value;            /* value associated with this element */
+    struct Itcl_ListElem *prev;  /* previous element in linked list */
+    struct Itcl_ListElem *next;  /* next element in linked list */
+} Itcl_ListElem;
+
+typedef struct Itcl_List {
+    int validate;                /* validation stamp */
+    int num;                     /* number of elements */
+    struct Itcl_ListElem *head;  /* previous element in linked list */
+    struct Itcl_ListElem *tail;  /* next element in linked list */
+} Itcl_List;
+
+#define Itcl_FirstListElem(listPtr) ((listPtr)->head)
+#define Itcl_LastListElem(listPtr)  ((listPtr)->tail)
+#define Itcl_NextListElem(elemPtr)  ((elemPtr)->next)
+#define Itcl_PrevListElem(elemPtr)  ((elemPtr)->prev)
+#define Itcl_GetListLength(listPtr) ((listPtr)->num)
+#define Itcl_GetListValue(elemPtr)  ((elemPtr)->value)
+
+/*
+ *  Token representing the state of an interpreter.
+ */
+typedef struct Itcl_InterpState_ *Itcl_InterpState;
+
+
+/*
+ * Include the public function declarations that are accessible via
+ * the stubs table.
+ */
+
+#include "itclDecls.h"
+
+
+/*
+ * Itcl_InitStubs is used by extensions like Itk that can be linked
+ * against the itcl stubs library.  If we are not using stubs
+ * then this reduces to package require.
+ */
+
+#ifdef USE_ITCL_STUBS
+
+TCL_EXTERNC CONST char *
+	Itcl_InitStubs _ANSI_ARGS_((Tcl_Interp *interp,
+			    CONST char *version, int exact));
+#else
+#define Itcl_InitStubs(interp, version, exact) \
+      Tcl_PkgRequire(interp, "Itcl", version, exact)
+#endif
+
+/*
+ * Public functions that are not accessible via the stubs table.
+ */
+
+
+#endif /* RC_INVOKED */
+
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLIMPORT
+
+#endif /* ITCL_H */
diff -Naur itk/generic/itcl3/itclIntDecls.h ITK_BLD/generic/itcl3/itclIntDecls.h
--- itk/generic/itcl3/itclIntDecls.h	1969-12-31 19:00:00.000000000 -0500
+++ ITK_BLD/generic/itcl3/itclIntDecls.h	2024-07-10 10:40:21.279659891 -0400
@@ -0,0 +1,1391 @@
+/*
+ * itclIntDecls.h --
+ *
+ *	This file contains the declarations for all unsupported
+ *	functions that are exported by the Tcl library.  These
+ *	interfaces are not guaranteed to remain the same between
+ *	versions.  Use at your own risk.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+
+#ifndef _ITCLINTDECLS
+#define _ITCLINTDECLS
+
+/*
+ * WARNING: This file is automatically generated by the tools/genStubs.tcl
+ * script.  Any modifications to the function declarations below should be made
+ * in the itcl/generic/tclInt.decls script.
+ */
+
+/* !BEGIN!: Do not edit below this line. */
+
+/*
+ * Exported function declarations:
+ */
+
+#ifndef Itcl_IsClassNamespace_TCL_DECLARED
+#define Itcl_IsClassNamespace_TCL_DECLARED
+/* 0 */
+TCL_EXTERN(int)		Itcl_IsClassNamespace _ANSI_ARGS_((
+				Tcl_Namespace * namesp));
+#endif
+#ifndef Itcl_IsClass_TCL_DECLARED
+#define Itcl_IsClass_TCL_DECLARED
+/* 1 */
+TCL_EXTERN(int)		Itcl_IsClass _ANSI_ARGS_((Tcl_Command cmd));
+#endif
+#ifndef Itcl_FindClass_TCL_DECLARED
+#define Itcl_FindClass_TCL_DECLARED
+/* 2 */
+TCL_EXTERN(ItclClass*)	Itcl_FindClass _ANSI_ARGS_((Tcl_Interp* interp, 
+				CONST char* path, int autoload));
+#endif
+#ifndef Itcl_FindObject_TCL_DECLARED
+#define Itcl_FindObject_TCL_DECLARED
+/* 3 */
+TCL_EXTERN(int)		Itcl_FindObject _ANSI_ARGS_((Tcl_Interp * interp, 
+				CONST char * name, ItclObject ** roPtr));
+#endif
+#ifndef Itcl_IsObject_TCL_DECLARED
+#define Itcl_IsObject_TCL_DECLARED
+/* 4 */
+TCL_EXTERN(int)		Itcl_IsObject _ANSI_ARGS_((Tcl_Command cmd));
+#endif
+#ifndef Itcl_ObjectIsa_TCL_DECLARED
+#define Itcl_ObjectIsa_TCL_DECLARED
+/* 5 */
+TCL_EXTERN(int)		Itcl_ObjectIsa _ANSI_ARGS_((ItclObject * contextObj, 
+				ItclClass * cdefn));
+#endif
+#ifndef Itcl_Protection_TCL_DECLARED
+#define Itcl_Protection_TCL_DECLARED
+/* 6 */
+TCL_EXTERN(int)		Itcl_Protection _ANSI_ARGS_((Tcl_Interp * interp, 
+				int newLevel));
+#endif
+#ifndef Itcl_ProtectionStr_TCL_DECLARED
+#define Itcl_ProtectionStr_TCL_DECLARED
+/* 7 */
+TCL_EXTERN(char*)	Itcl_ProtectionStr _ANSI_ARGS_((int pLevel));
+#endif
+#ifndef Itcl_CanAccess_TCL_DECLARED
+#define Itcl_CanAccess_TCL_DECLARED
+/* 8 */
+TCL_EXTERN(int)		Itcl_CanAccess _ANSI_ARGS_((ItclMember* memberPtr, 
+				Tcl_Namespace* fromNsPtr));
+#endif
+#ifndef Itcl_CanAccessFunc_TCL_DECLARED
+#define Itcl_CanAccessFunc_TCL_DECLARED
+/* 9 */
+TCL_EXTERN(int)		Itcl_CanAccessFunc _ANSI_ARGS_((
+				ItclMemberFunc* mfunc, 
+				Tcl_Namespace* fromNsPtr));
+#endif
+#ifndef Itcl_GetTrueNamespace_TCL_DECLARED
+#define Itcl_GetTrueNamespace_TCL_DECLARED
+/* 10 */
+TCL_EXTERN(Tcl_Namespace*) Itcl_GetTrueNamespace _ANSI_ARGS_((
+				Tcl_Interp * interp, ItclObjectInfo * info));
+#endif
+#ifndef Itcl_ParseNamespPath_TCL_DECLARED
+#define Itcl_ParseNamespPath_TCL_DECLARED
+/* 11 */
+TCL_EXTERN(void)	Itcl_ParseNamespPath _ANSI_ARGS_((CONST char * name, 
+				Tcl_DString * buffer, char ** head, 
+				char ** tail));
+#endif
+#ifndef Itcl_DecodeScopedCommand_TCL_DECLARED
+#define Itcl_DecodeScopedCommand_TCL_DECLARED
+/* 12 */
+TCL_EXTERN(int)		Itcl_DecodeScopedCommand _ANSI_ARGS_((
+				Tcl_Interp * interp, CONST char * name, 
+				Tcl_Namespace ** rNsPtr, char ** rCmdPtr));
+#endif
+#ifndef Itcl_EvalArgs_TCL_DECLARED
+#define Itcl_EvalArgs_TCL_DECLARED
+/* 13 */
+TCL_EXTERN(int)		Itcl_EvalArgs _ANSI_ARGS_((Tcl_Interp * interp, 
+				int objc, Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_CreateArgs_TCL_DECLARED
+#define Itcl_CreateArgs_TCL_DECLARED
+/* 14 */
+TCL_EXTERN(Tcl_Obj*)	Itcl_CreateArgs _ANSI_ARGS_((Tcl_Interp * interp, 
+				CONST char * string, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_PushContext_TCL_DECLARED
+#define Itcl_PushContext_TCL_DECLARED
+/* 15 */
+TCL_EXTERN(int)		Itcl_PushContext _ANSI_ARGS_((Tcl_Interp * interp, 
+				ItclMember * member, 
+				ItclClass * contextClass, 
+				ItclObject * contextObj, 
+				ItclContext * contextPtr));
+#endif
+#ifndef Itcl_PopContext_TCL_DECLARED
+#define Itcl_PopContext_TCL_DECLARED
+/* 16 */
+TCL_EXTERN(void)	Itcl_PopContext _ANSI_ARGS_((Tcl_Interp * interp, 
+				ItclContext * contextPtr));
+#endif
+#ifndef Itcl_GetContext_TCL_DECLARED
+#define Itcl_GetContext_TCL_DECLARED
+/* 17 */
+TCL_EXTERN(int)		Itcl_GetContext _ANSI_ARGS_((Tcl_Interp * interp, 
+				ItclClass ** cdefnPtr, 
+				ItclObject ** odefnPtr));
+#endif
+#ifndef Itcl_InitHierIter_TCL_DECLARED
+#define Itcl_InitHierIter_TCL_DECLARED
+/* 18 */
+TCL_EXTERN(void)	Itcl_InitHierIter _ANSI_ARGS_((ItclHierIter * iter, 
+				ItclClass * cdefn));
+#endif
+#ifndef Itcl_DeleteHierIter_TCL_DECLARED
+#define Itcl_DeleteHierIter_TCL_DECLARED
+/* 19 */
+TCL_EXTERN(void)	Itcl_DeleteHierIter _ANSI_ARGS_((ItclHierIter * iter));
+#endif
+#ifndef Itcl_AdvanceHierIter_TCL_DECLARED
+#define Itcl_AdvanceHierIter_TCL_DECLARED
+/* 20 */
+TCL_EXTERN(ItclClass*)	Itcl_AdvanceHierIter _ANSI_ARGS_((
+				ItclHierIter * iter));
+#endif
+#ifndef Itcl_FindClassesCmd_TCL_DECLARED
+#define Itcl_FindClassesCmd_TCL_DECLARED
+/* 21 */
+TCL_EXTERN(int)		Itcl_FindClassesCmd _ANSI_ARGS_((
+				ClientData clientData, Tcl_Interp * interp, 
+				int objc, Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_FindObjectsCmd_TCL_DECLARED
+#define Itcl_FindObjectsCmd_TCL_DECLARED
+/* 22 */
+TCL_EXTERN(int)		Itcl_FindObjectsCmd _ANSI_ARGS_((
+				ClientData clientData, Tcl_Interp * interp, 
+				int objc, Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_ProtectionCmd_TCL_DECLARED
+#define Itcl_ProtectionCmd_TCL_DECLARED
+/* 23 */
+TCL_EXTERN(int)		Itcl_ProtectionCmd _ANSI_ARGS_((
+				ClientData clientData, Tcl_Interp * interp, 
+				int objc, Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_DelClassCmd_TCL_DECLARED
+#define Itcl_DelClassCmd_TCL_DECLARED
+/* 24 */
+TCL_EXTERN(int)		Itcl_DelClassCmd _ANSI_ARGS_((ClientData clientData, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_DelObjectCmd_TCL_DECLARED
+#define Itcl_DelObjectCmd_TCL_DECLARED
+/* 25 */
+TCL_EXTERN(int)		Itcl_DelObjectCmd _ANSI_ARGS_((ClientData clientData, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_ScopeCmd_TCL_DECLARED
+#define Itcl_ScopeCmd_TCL_DECLARED
+/* 26 */
+TCL_EXTERN(int)		Itcl_ScopeCmd _ANSI_ARGS_((ClientData clientData, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_CodeCmd_TCL_DECLARED
+#define Itcl_CodeCmd_TCL_DECLARED
+/* 27 */
+TCL_EXTERN(int)		Itcl_CodeCmd _ANSI_ARGS_((ClientData clientData, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_StubCreateCmd_TCL_DECLARED
+#define Itcl_StubCreateCmd_TCL_DECLARED
+/* 28 */
+TCL_EXTERN(int)		Itcl_StubCreateCmd _ANSI_ARGS_((
+				ClientData clientData, Tcl_Interp * interp, 
+				int objc, Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_StubExistsCmd_TCL_DECLARED
+#define Itcl_StubExistsCmd_TCL_DECLARED
+/* 29 */
+TCL_EXTERN(int)		Itcl_StubExistsCmd _ANSI_ARGS_((
+				ClientData clientData, Tcl_Interp * interp, 
+				int objc, Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_IsStub_TCL_DECLARED
+#define Itcl_IsStub_TCL_DECLARED
+/* 30 */
+TCL_EXTERN(int)		Itcl_IsStub _ANSI_ARGS_((Tcl_Command cmd));
+#endif
+#ifndef Itcl_CreateClass_TCL_DECLARED
+#define Itcl_CreateClass_TCL_DECLARED
+/* 31 */
+TCL_EXTERN(int)		Itcl_CreateClass _ANSI_ARGS_((Tcl_Interp* interp, 
+				CONST char* path, ItclObjectInfo * info, 
+				ItclClass ** rPtr));
+#endif
+#ifndef Itcl_DeleteClass_TCL_DECLARED
+#define Itcl_DeleteClass_TCL_DECLARED
+/* 32 */
+TCL_EXTERN(int)		Itcl_DeleteClass _ANSI_ARGS_((Tcl_Interp * interp, 
+				ItclClass * cdefnPtr));
+#endif
+#ifndef Itcl_FindClassNamespace_TCL_DECLARED
+#define Itcl_FindClassNamespace_TCL_DECLARED
+/* 33 */
+TCL_EXTERN(Tcl_Namespace*) Itcl_FindClassNamespace _ANSI_ARGS_((
+				Tcl_Interp* interp, CONST char* path));
+#endif
+#ifndef Itcl_HandleClass_TCL_DECLARED
+#define Itcl_HandleClass_TCL_DECLARED
+/* 34 */
+TCL_EXTERN(int)		Itcl_HandleClass _ANSI_ARGS_((ClientData clientData, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_ClassCmdResolver_TCL_DECLARED
+#define Itcl_ClassCmdResolver_TCL_DECLARED
+/* 35 */
+TCL_EXTERN(int)		Itcl_ClassCmdResolver _ANSI_ARGS_((
+				Tcl_Interp * interp, CONST char* name, 
+				Tcl_Namespace * context, int flags, 
+				Tcl_Command * rPtr));
+#endif
+#ifndef Itcl_ClassVarResolver_TCL_DECLARED
+#define Itcl_ClassVarResolver_TCL_DECLARED
+/* 36 */
+TCL_EXTERN(int)		Itcl_ClassVarResolver _ANSI_ARGS_((
+				Tcl_Interp * interp, CONST char* name, 
+				Tcl_Namespace * context, int flags, 
+				Tcl_Var * rPtr));
+#endif
+#ifndef Itcl_ClassCompiledVarResolver_TCL_DECLARED
+#define Itcl_ClassCompiledVarResolver_TCL_DECLARED
+/* 37 */
+TCL_EXTERN(int)		Itcl_ClassCompiledVarResolver _ANSI_ARGS_((
+				Tcl_Interp * interp, CONST char* name, 
+				int length, Tcl_Namespace * context, 
+				Tcl_ResolvedVarInfo ** rPtr));
+#endif
+#ifndef Itcl_BuildVirtualTables_TCL_DECLARED
+#define Itcl_BuildVirtualTables_TCL_DECLARED
+/* 38 */
+TCL_EXTERN(void)	Itcl_BuildVirtualTables _ANSI_ARGS_((
+				ItclClass* cdefnPtr));
+#endif
+#ifndef Itcl_CreateVarDefn_TCL_DECLARED
+#define Itcl_CreateVarDefn_TCL_DECLARED
+/* 39 */
+TCL_EXTERN(int)		Itcl_CreateVarDefn _ANSI_ARGS_((Tcl_Interp * interp, 
+				ItclClass* cdefn, char* name, char* init, 
+				char* config, ItclVarDefn** vdefnPtr));
+#endif
+#ifndef Itcl_DeleteVarDefn_TCL_DECLARED
+#define Itcl_DeleteVarDefn_TCL_DECLARED
+/* 40 */
+TCL_EXTERN(void)	Itcl_DeleteVarDefn _ANSI_ARGS_((ItclVarDefn * vdefn));
+#endif
+#ifndef Itcl_GetCommonVar_TCL_DECLARED
+#define Itcl_GetCommonVar_TCL_DECLARED
+/* 41 */
+TCL_EXTERN(CONST char*)	 Itcl_GetCommonVar _ANSI_ARGS_((Tcl_Interp * interp, 
+				CONST char * name, ItclClass * contextClass));
+#endif
+#ifndef Itcl_CreateMember_TCL_DECLARED
+#define Itcl_CreateMember_TCL_DECLARED
+/* 42 */
+TCL_EXTERN(ItclMember*)	 Itcl_CreateMember _ANSI_ARGS_((Tcl_Interp* interp, 
+				ItclClass * cdefn, CONST char* name));
+#endif
+#ifndef Itcl_DeleteMember_TCL_DECLARED
+#define Itcl_DeleteMember_TCL_DECLARED
+/* 43 */
+TCL_EXTERN(void)	Itcl_DeleteMember _ANSI_ARGS_((ItclMember * memPtr));
+#endif
+#ifndef Itcl_CreateObject_TCL_DECLARED
+#define Itcl_CreateObject_TCL_DECLARED
+/* 44 */
+TCL_EXTERN(int)		Itcl_CreateObject _ANSI_ARGS_((Tcl_Interp * interp, 
+				CONST char* name, ItclClass * cdefn, 
+				int objc, Tcl_Obj *CONST objv[], 
+				ItclObject ** roPtr));
+#endif
+#ifndef Itcl_DeleteObject_TCL_DECLARED
+#define Itcl_DeleteObject_TCL_DECLARED
+/* 45 */
+TCL_EXTERN(int)		Itcl_DeleteObject _ANSI_ARGS_((Tcl_Interp * interp, 
+				ItclObject * contextObj));
+#endif
+#ifndef Itcl_DestructObject_TCL_DECLARED
+#define Itcl_DestructObject_TCL_DECLARED
+/* 46 */
+TCL_EXTERN(int)		Itcl_DestructObject _ANSI_ARGS_((Tcl_Interp * interp, 
+				ItclObject * contextObj, int flags));
+#endif
+#ifndef Itcl_HandleInstance_TCL_DECLARED
+#define Itcl_HandleInstance_TCL_DECLARED
+/* 47 */
+TCL_EXTERN(int)		Itcl_HandleInstance _ANSI_ARGS_((
+				ClientData clientData, Tcl_Interp * interp, 
+				int objc, Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_GetInstanceVar_TCL_DECLARED
+#define Itcl_GetInstanceVar_TCL_DECLARED
+/* 48 */
+TCL_EXTERN(CONST char*)	 Itcl_GetInstanceVar _ANSI_ARGS_((
+				Tcl_Interp * interp, CONST char * name, 
+				ItclObject * contextObj, 
+				ItclClass * contextClass));
+#endif
+#ifndef Itcl_ScopedVarResolver_TCL_DECLARED
+#define Itcl_ScopedVarResolver_TCL_DECLARED
+/* 49 */
+TCL_EXTERN(int)		Itcl_ScopedVarResolver _ANSI_ARGS_((
+				Tcl_Interp * interp, CONST char * name, 
+				Tcl_Namespace * contextNs, int flags, 
+				Tcl_Var * rPtr));
+#endif
+#ifndef Itcl_BodyCmd_TCL_DECLARED
+#define Itcl_BodyCmd_TCL_DECLARED
+/* 50 */
+TCL_EXTERN(int)		Itcl_BodyCmd _ANSI_ARGS_((ClientData dummy, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_ConfigBodyCmd_TCL_DECLARED
+#define Itcl_ConfigBodyCmd_TCL_DECLARED
+/* 51 */
+TCL_EXTERN(int)		Itcl_ConfigBodyCmd _ANSI_ARGS_((ClientData dummy, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_CreateMethod_TCL_DECLARED
+#define Itcl_CreateMethod_TCL_DECLARED
+/* 52 */
+TCL_EXTERN(int)		Itcl_CreateMethod _ANSI_ARGS_((Tcl_Interp* interp, 
+				ItclClass * cdefn, CONST char* name, 
+				CONST char* arglist, CONST char* body));
+#endif
+#ifndef Itcl_CreateProc_TCL_DECLARED
+#define Itcl_CreateProc_TCL_DECLARED
+/* 53 */
+TCL_EXTERN(int)		Itcl_CreateProc _ANSI_ARGS_((Tcl_Interp* interp, 
+				ItclClass * cdefn, CONST char* name, 
+				CONST char* arglist, CONST char* body));
+#endif
+#ifndef Itcl_CreateMemberFunc_TCL_DECLARED
+#define Itcl_CreateMemberFunc_TCL_DECLARED
+/* 54 */
+TCL_EXTERN(int)		Itcl_CreateMemberFunc _ANSI_ARGS_((
+				Tcl_Interp* interp, ItclClass * cdefn, 
+				CONST char* name, CONST char* arglist, 
+				CONST char* body, ItclMemberFunc** mfuncPtr));
+#endif
+#ifndef Itcl_ChangeMemberFunc_TCL_DECLARED
+#define Itcl_ChangeMemberFunc_TCL_DECLARED
+/* 55 */
+TCL_EXTERN(int)		Itcl_ChangeMemberFunc _ANSI_ARGS_((
+				Tcl_Interp* interp, ItclMemberFunc* mfunc, 
+				CONST char* arglist, CONST char* body));
+#endif
+#ifndef Itcl_DeleteMemberFunc_TCL_DECLARED
+#define Itcl_DeleteMemberFunc_TCL_DECLARED
+/* 56 */
+TCL_EXTERN(void)	Itcl_DeleteMemberFunc _ANSI_ARGS_((CONST char* cdata));
+#endif
+#ifndef Itcl_CreateMemberCode_TCL_DECLARED
+#define Itcl_CreateMemberCode_TCL_DECLARED
+/* 57 */
+TCL_EXTERN(int)		Itcl_CreateMemberCode _ANSI_ARGS_((
+				Tcl_Interp* interp, ItclClass * cdefn, 
+				CONST char* arglist, CONST char* body, 
+				ItclMemberCode** mcodePtr));
+#endif
+#ifndef Itcl_DeleteMemberCode_TCL_DECLARED
+#define Itcl_DeleteMemberCode_TCL_DECLARED
+/* 58 */
+TCL_EXTERN(void)	Itcl_DeleteMemberCode _ANSI_ARGS_((char* cdata));
+#endif
+#ifndef Itcl_GetMemberCode_TCL_DECLARED
+#define Itcl_GetMemberCode_TCL_DECLARED
+/* 59 */
+TCL_EXTERN(int)		Itcl_GetMemberCode _ANSI_ARGS_((Tcl_Interp* interp, 
+				ItclMember* member));
+#endif
+/* Slot 60 is reserved */
+#ifndef Itcl_EvalMemberCode_TCL_DECLARED
+#define Itcl_EvalMemberCode_TCL_DECLARED
+/* 61 */
+TCL_EXTERN(int)		Itcl_EvalMemberCode _ANSI_ARGS_((Tcl_Interp * interp, 
+				ItclMemberFunc * mfunc, ItclMember * member, 
+				ItclObject * contextObj, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_CreateArgList_TCL_DECLARED
+#define Itcl_CreateArgList_TCL_DECLARED
+/* 62 */
+TCL_EXTERN(int)		Itcl_CreateArgList _ANSI_ARGS_((Tcl_Interp* interp, 
+				CONST char* decl, int* argcPtr, 
+				CompiledLocal** argPtr));
+#endif
+#ifndef Itcl_CreateArg_TCL_DECLARED
+#define Itcl_CreateArg_TCL_DECLARED
+/* 63 */
+TCL_EXTERN(CompiledLocal*) Itcl_CreateArg _ANSI_ARGS_((CONST char* name, 
+				CONST char* init));
+#endif
+#ifndef Itcl_DeleteArgList_TCL_DECLARED
+#define Itcl_DeleteArgList_TCL_DECLARED
+/* 64 */
+TCL_EXTERN(void)	Itcl_DeleteArgList _ANSI_ARGS_((
+				CompiledLocal * arglist));
+#endif
+#ifndef Itcl_ArgList_TCL_DECLARED
+#define Itcl_ArgList_TCL_DECLARED
+/* 65 */
+TCL_EXTERN(Tcl_Obj*)	Itcl_ArgList _ANSI_ARGS_((int argc, 
+				CompiledLocal* arglist));
+#endif
+#ifndef Itcl_EquivArgLists_TCL_DECLARED
+#define Itcl_EquivArgLists_TCL_DECLARED
+/* 66 */
+TCL_EXTERN(int)		Itcl_EquivArgLists _ANSI_ARGS_((CompiledLocal* arg1, 
+				int arg1c, CompiledLocal* arg2, int arg2c));
+#endif
+#ifndef Itcl_GetMemberFuncUsage_TCL_DECLARED
+#define Itcl_GetMemberFuncUsage_TCL_DECLARED
+/* 67 */
+TCL_EXTERN(void)	Itcl_GetMemberFuncUsage _ANSI_ARGS_((
+				ItclMemberFunc * mfunc, 
+				ItclObject * contextObj, Tcl_Obj * objPtr));
+#endif
+#ifndef Itcl_ExecMethod_TCL_DECLARED
+#define Itcl_ExecMethod_TCL_DECLARED
+/* 68 */
+TCL_EXTERN(int)		Itcl_ExecMethod _ANSI_ARGS_((ClientData clientData, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_ExecProc_TCL_DECLARED
+#define Itcl_ExecProc_TCL_DECLARED
+/* 69 */
+TCL_EXTERN(int)		Itcl_ExecProc _ANSI_ARGS_((ClientData clientData, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_AssignArgs_TCL_DECLARED
+#define Itcl_AssignArgs_TCL_DECLARED
+/* 70 */
+TCL_EXTERN(int)		Itcl_AssignArgs _ANSI_ARGS_((Tcl_Interp * interp, 
+				int objc, Tcl_Obj *CONST objv[], 
+				ItclMemberFunc * mfunc));
+#endif
+#ifndef Itcl_ConstructBase_TCL_DECLARED
+#define Itcl_ConstructBase_TCL_DECLARED
+/* 71 */
+TCL_EXTERN(int)		Itcl_ConstructBase _ANSI_ARGS_((Tcl_Interp * interp, 
+				ItclObject * contextObj, 
+				ItclClass * contextClass));
+#endif
+#ifndef Itcl_InvokeMethodIfExists_TCL_DECLARED
+#define Itcl_InvokeMethodIfExists_TCL_DECLARED
+/* 72 */
+TCL_EXTERN(int)		Itcl_InvokeMethodIfExists _ANSI_ARGS_((
+				Tcl_Interp * interp, CONST char * name, 
+				ItclClass * contextClass, 
+				ItclObject * contextObj, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+/* Slot 73 is reserved */
+#ifndef Itcl_ReportFuncErrors_TCL_DECLARED
+#define Itcl_ReportFuncErrors_TCL_DECLARED
+/* 74 */
+TCL_EXTERN(int)		Itcl_ReportFuncErrors _ANSI_ARGS_((
+				Tcl_Interp* interp, ItclMemberFunc * mfunc, 
+				ItclObject * contextObj, int result));
+#endif
+#ifndef Itcl_ParseInit_TCL_DECLARED
+#define Itcl_ParseInit_TCL_DECLARED
+/* 75 */
+TCL_EXTERN(int)		Itcl_ParseInit _ANSI_ARGS_((Tcl_Interp * interp, 
+				ItclObjectInfo * info));
+#endif
+#ifndef Itcl_ClassCmd_TCL_DECLARED
+#define Itcl_ClassCmd_TCL_DECLARED
+/* 76 */
+TCL_EXTERN(int)		Itcl_ClassCmd _ANSI_ARGS_((ClientData clientData, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_ClassInheritCmd_TCL_DECLARED
+#define Itcl_ClassInheritCmd_TCL_DECLARED
+/* 77 */
+TCL_EXTERN(int)		Itcl_ClassInheritCmd _ANSI_ARGS_((
+				ClientData clientData, Tcl_Interp * interp, 
+				int objc, Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_ClassProtectionCmd_TCL_DECLARED
+#define Itcl_ClassProtectionCmd_TCL_DECLARED
+/* 78 */
+TCL_EXTERN(int)		Itcl_ClassProtectionCmd _ANSI_ARGS_((
+				ClientData clientData, Tcl_Interp * interp, 
+				int objc, Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_ClassConstructorCmd_TCL_DECLARED
+#define Itcl_ClassConstructorCmd_TCL_DECLARED
+/* 79 */
+TCL_EXTERN(int)		Itcl_ClassConstructorCmd _ANSI_ARGS_((
+				ClientData clientData, Tcl_Interp * interp, 
+				int objc, Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_ClassDestructorCmd_TCL_DECLARED
+#define Itcl_ClassDestructorCmd_TCL_DECLARED
+/* 80 */
+TCL_EXTERN(int)		Itcl_ClassDestructorCmd _ANSI_ARGS_((
+				ClientData clientData, Tcl_Interp * interp, 
+				int objc, Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_ClassMethodCmd_TCL_DECLARED
+#define Itcl_ClassMethodCmd_TCL_DECLARED
+/* 81 */
+TCL_EXTERN(int)		Itcl_ClassMethodCmd _ANSI_ARGS_((
+				ClientData clientData, Tcl_Interp * interp, 
+				int objc, Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_ClassProcCmd_TCL_DECLARED
+#define Itcl_ClassProcCmd_TCL_DECLARED
+/* 82 */
+TCL_EXTERN(int)		Itcl_ClassProcCmd _ANSI_ARGS_((ClientData clientData, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_ClassVariableCmd_TCL_DECLARED
+#define Itcl_ClassVariableCmd_TCL_DECLARED
+/* 83 */
+TCL_EXTERN(int)		Itcl_ClassVariableCmd _ANSI_ARGS_((
+				ClientData clientData, Tcl_Interp * interp, 
+				int objc, Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_ClassCommonCmd_TCL_DECLARED
+#define Itcl_ClassCommonCmd_TCL_DECLARED
+/* 84 */
+TCL_EXTERN(int)		Itcl_ClassCommonCmd _ANSI_ARGS_((
+				ClientData clientData, Tcl_Interp * interp, 
+				int objc, Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_ParseVarResolver_TCL_DECLARED
+#define Itcl_ParseVarResolver_TCL_DECLARED
+/* 85 */
+TCL_EXTERN(int)		Itcl_ParseVarResolver _ANSI_ARGS_((
+				Tcl_Interp * interp, CONST char* name, 
+				Tcl_Namespace * contextNs, int flags, 
+				Tcl_Var* rPtr));
+#endif
+#ifndef Itcl_BiInit_TCL_DECLARED
+#define Itcl_BiInit_TCL_DECLARED
+/* 86 */
+TCL_EXTERN(int)		Itcl_BiInit _ANSI_ARGS_((Tcl_Interp * interp));
+#endif
+#ifndef Itcl_InstallBiMethods_TCL_DECLARED
+#define Itcl_InstallBiMethods_TCL_DECLARED
+/* 87 */
+TCL_EXTERN(int)		Itcl_InstallBiMethods _ANSI_ARGS_((
+				Tcl_Interp * interp, ItclClass * cdefn));
+#endif
+#ifndef Itcl_BiIsaCmd_TCL_DECLARED
+#define Itcl_BiIsaCmd_TCL_DECLARED
+/* 88 */
+TCL_EXTERN(int)		Itcl_BiIsaCmd _ANSI_ARGS_((ClientData clientData, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_BiConfigureCmd_TCL_DECLARED
+#define Itcl_BiConfigureCmd_TCL_DECLARED
+/* 89 */
+TCL_EXTERN(int)		Itcl_BiConfigureCmd _ANSI_ARGS_((
+				ClientData clientData, Tcl_Interp * interp, 
+				int objc, Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_BiCgetCmd_TCL_DECLARED
+#define Itcl_BiCgetCmd_TCL_DECLARED
+/* 90 */
+TCL_EXTERN(int)		Itcl_BiCgetCmd _ANSI_ARGS_((ClientData clientData, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_BiChainCmd_TCL_DECLARED
+#define Itcl_BiChainCmd_TCL_DECLARED
+/* 91 */
+TCL_EXTERN(int)		Itcl_BiChainCmd _ANSI_ARGS_((ClientData dummy, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_BiInfoClassCmd_TCL_DECLARED
+#define Itcl_BiInfoClassCmd_TCL_DECLARED
+/* 92 */
+TCL_EXTERN(int)		Itcl_BiInfoClassCmd _ANSI_ARGS_((ClientData dummy, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_BiInfoInheritCmd_TCL_DECLARED
+#define Itcl_BiInfoInheritCmd_TCL_DECLARED
+/* 93 */
+TCL_EXTERN(int)		Itcl_BiInfoInheritCmd _ANSI_ARGS_((ClientData dummy, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_BiInfoHeritageCmd_TCL_DECLARED
+#define Itcl_BiInfoHeritageCmd_TCL_DECLARED
+/* 94 */
+TCL_EXTERN(int)		Itcl_BiInfoHeritageCmd _ANSI_ARGS_((ClientData dummy, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_BiInfoFunctionCmd_TCL_DECLARED
+#define Itcl_BiInfoFunctionCmd_TCL_DECLARED
+/* 95 */
+TCL_EXTERN(int)		Itcl_BiInfoFunctionCmd _ANSI_ARGS_((ClientData dummy, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_BiInfoVariableCmd_TCL_DECLARED
+#define Itcl_BiInfoVariableCmd_TCL_DECLARED
+/* 96 */
+TCL_EXTERN(int)		Itcl_BiInfoVariableCmd _ANSI_ARGS_((ClientData dummy, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_BiInfoBodyCmd_TCL_DECLARED
+#define Itcl_BiInfoBodyCmd_TCL_DECLARED
+/* 97 */
+TCL_EXTERN(int)		Itcl_BiInfoBodyCmd _ANSI_ARGS_((ClientData dummy, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_BiInfoArgsCmd_TCL_DECLARED
+#define Itcl_BiInfoArgsCmd_TCL_DECLARED
+/* 98 */
+TCL_EXTERN(int)		Itcl_BiInfoArgsCmd _ANSI_ARGS_((ClientData dummy, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_DefaultInfoCmd_TCL_DECLARED
+#define Itcl_DefaultInfoCmd_TCL_DECLARED
+/* 99 */
+TCL_EXTERN(int)		Itcl_DefaultInfoCmd _ANSI_ARGS_((ClientData dummy, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_EnsembleInit_TCL_DECLARED
+#define Itcl_EnsembleInit_TCL_DECLARED
+/* 100 */
+TCL_EXTERN(int)		Itcl_EnsembleInit _ANSI_ARGS_((Tcl_Interp * interp));
+#endif
+#ifndef Itcl_CreateEnsemble_TCL_DECLARED
+#define Itcl_CreateEnsemble_TCL_DECLARED
+/* 101 */
+TCL_EXTERN(int)		Itcl_CreateEnsemble _ANSI_ARGS_((Tcl_Interp * interp, 
+				CONST char* ensName));
+#endif
+#ifndef Itcl_AddEnsemblePart_TCL_DECLARED
+#define Itcl_AddEnsemblePart_TCL_DECLARED
+/* 102 */
+TCL_EXTERN(int)		Itcl_AddEnsemblePart _ANSI_ARGS_((
+				Tcl_Interp * interp, CONST char* ensName, 
+				CONST char* partName, CONST char* usageInfo, 
+				Tcl_ObjCmdProc * objProc, 
+				ClientData clientData, 
+				Tcl_CmdDeleteProc * deleteProc));
+#endif
+#ifndef Itcl_GetEnsemblePart_TCL_DECLARED
+#define Itcl_GetEnsemblePart_TCL_DECLARED
+/* 103 */
+TCL_EXTERN(int)		Itcl_GetEnsemblePart _ANSI_ARGS_((
+				Tcl_Interp * interp, CONST char * ensName, 
+				CONST char * partName, Tcl_CmdInfo * infoPtr));
+#endif
+#ifndef Itcl_IsEnsemble_TCL_DECLARED
+#define Itcl_IsEnsemble_TCL_DECLARED
+/* 104 */
+TCL_EXTERN(int)		Itcl_IsEnsemble _ANSI_ARGS_((Tcl_CmdInfo* infoPtr));
+#endif
+#ifndef Itcl_GetEnsembleUsage_TCL_DECLARED
+#define Itcl_GetEnsembleUsage_TCL_DECLARED
+/* 105 */
+TCL_EXTERN(int)		Itcl_GetEnsembleUsage _ANSI_ARGS_((
+				Tcl_Interp * interp, CONST char * ensName, 
+				Tcl_Obj * objPtr));
+#endif
+#ifndef Itcl_GetEnsembleUsageForObj_TCL_DECLARED
+#define Itcl_GetEnsembleUsageForObj_TCL_DECLARED
+/* 106 */
+TCL_EXTERN(int)		Itcl_GetEnsembleUsageForObj _ANSI_ARGS_((
+				Tcl_Interp * interp, Tcl_Obj * ensObjPtr, 
+				Tcl_Obj * objPtr));
+#endif
+#ifndef Itcl_EnsembleCmd_TCL_DECLARED
+#define Itcl_EnsembleCmd_TCL_DECLARED
+/* 107 */
+TCL_EXTERN(int)		Itcl_EnsembleCmd _ANSI_ARGS_((ClientData clientData, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_EnsPartCmd_TCL_DECLARED
+#define Itcl_EnsPartCmd_TCL_DECLARED
+/* 108 */
+TCL_EXTERN(int)		Itcl_EnsPartCmd _ANSI_ARGS_((ClientData clientData, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_EnsembleErrorCmd_TCL_DECLARED
+#define Itcl_EnsembleErrorCmd_TCL_DECLARED
+/* 109 */
+TCL_EXTERN(int)		Itcl_EnsembleErrorCmd _ANSI_ARGS_((
+				ClientData clientData, Tcl_Interp * interp, 
+				int objc, Tcl_Obj *CONST objv[]));
+#endif
+/* Slot 110 is reserved */
+/* Slot 111 is reserved */
+#ifndef _Tcl_GetCallFrame_TCL_DECLARED
+#define _Tcl_GetCallFrame_TCL_DECLARED
+/* 112 */
+TCL_EXTERN(Itcl_CallFrame*) _Tcl_GetCallFrame _ANSI_ARGS_((
+				Tcl_Interp * interp, int level));
+#endif
+#ifndef _Tcl_ActivateCallFrame_TCL_DECLARED
+#define _Tcl_ActivateCallFrame_TCL_DECLARED
+/* 113 */
+TCL_EXTERN(Itcl_CallFrame*) _Tcl_ActivateCallFrame _ANSI_ARGS_((
+				Tcl_Interp * interp, 
+				Itcl_CallFrame * framePtr));
+#endif
+#ifndef _TclNewVar_TCL_DECLARED
+#define _TclNewVar_TCL_DECLARED
+/* 114 */
+TCL_EXTERN(Var*)	_TclNewVar _ANSI_ARGS_((void));
+#endif
+#ifndef Itcl_Assert_TCL_DECLARED
+#define Itcl_Assert_TCL_DECLARED
+/* 115 */
+TCL_EXTERN(void)	Itcl_Assert _ANSI_ARGS_((CONST char * testExpr, 
+				CONST char * fileName, int lineNum));
+#endif
+#ifndef Itcl_IsObjectCmd_TCL_DECLARED
+#define Itcl_IsObjectCmd_TCL_DECLARED
+/* 116 */
+TCL_EXTERN(int)		Itcl_IsObjectCmd _ANSI_ARGS_((ClientData clientData, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+#ifndef Itcl_IsClassCmd_TCL_DECLARED
+#define Itcl_IsClassCmd_TCL_DECLARED
+/* 117 */
+TCL_EXTERN(int)		Itcl_IsClassCmd _ANSI_ARGS_((ClientData clientData, 
+				Tcl_Interp * interp, int objc, 
+				Tcl_Obj *CONST objv[]));
+#endif
+
+typedef struct ItclIntStubs {
+    int magic;
+    struct ItclIntStubHooks *hooks;
+
+    int (*itcl_IsClassNamespace) _ANSI_ARGS_((Tcl_Namespace * namesp)); /* 0 */
+    int (*itcl_IsClass) _ANSI_ARGS_((Tcl_Command cmd)); /* 1 */
+    ItclClass* (*itcl_FindClass) _ANSI_ARGS_((Tcl_Interp* interp, CONST char* path, int autoload)); /* 2 */
+    int (*itcl_FindObject) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, ItclObject ** roPtr)); /* 3 */
+    int (*itcl_IsObject) _ANSI_ARGS_((Tcl_Command cmd)); /* 4 */
+    int (*itcl_ObjectIsa) _ANSI_ARGS_((ItclObject * contextObj, ItclClass * cdefn)); /* 5 */
+    int (*itcl_Protection) _ANSI_ARGS_((Tcl_Interp * interp, int newLevel)); /* 6 */
+    char* (*itcl_ProtectionStr) _ANSI_ARGS_((int pLevel)); /* 7 */
+    int (*itcl_CanAccess) _ANSI_ARGS_((ItclMember* memberPtr, Tcl_Namespace* fromNsPtr)); /* 8 */
+    int (*itcl_CanAccessFunc) _ANSI_ARGS_((ItclMemberFunc* mfunc, Tcl_Namespace* fromNsPtr)); /* 9 */
+    Tcl_Namespace* (*itcl_GetTrueNamespace) _ANSI_ARGS_((Tcl_Interp * interp, ItclObjectInfo * info)); /* 10 */
+    void (*itcl_ParseNamespPath) _ANSI_ARGS_((CONST char * name, Tcl_DString * buffer, char ** head, char ** tail)); /* 11 */
+    int (*itcl_DecodeScopedCommand) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, Tcl_Namespace ** rNsPtr, char ** rCmdPtr)); /* 12 */
+    int (*itcl_EvalArgs) _ANSI_ARGS_((Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 13 */
+    Tcl_Obj* (*itcl_CreateArgs) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * string, int objc, Tcl_Obj *CONST objv[])); /* 14 */
+    int (*itcl_PushContext) _ANSI_ARGS_((Tcl_Interp * interp, ItclMember * member, ItclClass * contextClass, ItclObject * contextObj, ItclContext * contextPtr)); /* 15 */
+    void (*itcl_PopContext) _ANSI_ARGS_((Tcl_Interp * interp, ItclContext * contextPtr)); /* 16 */
+    int (*itcl_GetContext) _ANSI_ARGS_((Tcl_Interp * interp, ItclClass ** cdefnPtr, ItclObject ** odefnPtr)); /* 17 */
+    void (*itcl_InitHierIter) _ANSI_ARGS_((ItclHierIter * iter, ItclClass * cdefn)); /* 18 */
+    void (*itcl_DeleteHierIter) _ANSI_ARGS_((ItclHierIter * iter)); /* 19 */
+    ItclClass* (*itcl_AdvanceHierIter) _ANSI_ARGS_((ItclHierIter * iter)); /* 20 */
+    int (*itcl_FindClassesCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 21 */
+    int (*itcl_FindObjectsCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 22 */
+    int (*itcl_ProtectionCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 23 */
+    int (*itcl_DelClassCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 24 */
+    int (*itcl_DelObjectCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 25 */
+    int (*itcl_ScopeCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 26 */
+    int (*itcl_CodeCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 27 */
+    int (*itcl_StubCreateCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 28 */
+    int (*itcl_StubExistsCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 29 */
+    int (*itcl_IsStub) _ANSI_ARGS_((Tcl_Command cmd)); /* 30 */
+    int (*itcl_CreateClass) _ANSI_ARGS_((Tcl_Interp* interp, CONST char* path, ItclObjectInfo * info, ItclClass ** rPtr)); /* 31 */
+    int (*itcl_DeleteClass) _ANSI_ARGS_((Tcl_Interp * interp, ItclClass * cdefnPtr)); /* 32 */
+    Tcl_Namespace* (*itcl_FindClassNamespace) _ANSI_ARGS_((Tcl_Interp* interp, CONST char* path)); /* 33 */
+    int (*itcl_HandleClass) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 34 */
+    int (*itcl_ClassCmdResolver) _ANSI_ARGS_((Tcl_Interp * interp, CONST char* name, Tcl_Namespace * context, int flags, Tcl_Command * rPtr)); /* 35 */
+    int (*itcl_ClassVarResolver) _ANSI_ARGS_((Tcl_Interp * interp, CONST char* name, Tcl_Namespace * context, int flags, Tcl_Var * rPtr)); /* 36 */
+    int (*itcl_ClassCompiledVarResolver) _ANSI_ARGS_((Tcl_Interp * interp, CONST char* name, int length, Tcl_Namespace * context, Tcl_ResolvedVarInfo ** rPtr)); /* 37 */
+    void (*itcl_BuildVirtualTables) _ANSI_ARGS_((ItclClass* cdefnPtr)); /* 38 */
+    int (*itcl_CreateVarDefn) _ANSI_ARGS_((Tcl_Interp * interp, ItclClass* cdefn, char* name, char* init, char* config, ItclVarDefn** vdefnPtr)); /* 39 */
+    void (*itcl_DeleteVarDefn) _ANSI_ARGS_((ItclVarDefn * vdefn)); /* 40 */
+    CONST char* (*itcl_GetCommonVar) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, ItclClass * contextClass)); /* 41 */
+    ItclMember* (*itcl_CreateMember) _ANSI_ARGS_((Tcl_Interp* interp, ItclClass * cdefn, CONST char* name)); /* 42 */
+    void (*itcl_DeleteMember) _ANSI_ARGS_((ItclMember * memPtr)); /* 43 */
+    int (*itcl_CreateObject) _ANSI_ARGS_((Tcl_Interp * interp, CONST char* name, ItclClass * cdefn, int objc, Tcl_Obj *CONST objv[], ItclObject ** roPtr)); /* 44 */
+    int (*itcl_DeleteObject) _ANSI_ARGS_((Tcl_Interp * interp, ItclObject * contextObj)); /* 45 */
+    int (*itcl_DestructObject) _ANSI_ARGS_((Tcl_Interp * interp, ItclObject * contextObj, int flags)); /* 46 */
+    int (*itcl_HandleInstance) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 47 */
+    CONST char* (*itcl_GetInstanceVar) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, ItclObject * contextObj, ItclClass * contextClass)); /* 48 */
+    int (*itcl_ScopedVarResolver) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, Tcl_Namespace * contextNs, int flags, Tcl_Var * rPtr)); /* 49 */
+    int (*itcl_BodyCmd) _ANSI_ARGS_((ClientData dummy, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 50 */
+    int (*itcl_ConfigBodyCmd) _ANSI_ARGS_((ClientData dummy, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 51 */
+    int (*itcl_CreateMethod) _ANSI_ARGS_((Tcl_Interp* interp, ItclClass * cdefn, CONST char* name, CONST char* arglist, CONST char* body)); /* 52 */
+    int (*itcl_CreateProc) _ANSI_ARGS_((Tcl_Interp* interp, ItclClass * cdefn, CONST char* name, CONST char* arglist, CONST char* body)); /* 53 */
+    int (*itcl_CreateMemberFunc) _ANSI_ARGS_((Tcl_Interp* interp, ItclClass * cdefn, CONST char* name, CONST char* arglist, CONST char* body, ItclMemberFunc** mfuncPtr)); /* 54 */
+    int (*itcl_ChangeMemberFunc) _ANSI_ARGS_((Tcl_Interp* interp, ItclMemberFunc* mfunc, CONST char* arglist, CONST char* body)); /* 55 */
+    void (*itcl_DeleteMemberFunc) _ANSI_ARGS_((CONST char* cdata)); /* 56 */
+    int (*itcl_CreateMemberCode) _ANSI_ARGS_((Tcl_Interp* interp, ItclClass * cdefn, CONST char* arglist, CONST char* body, ItclMemberCode** mcodePtr)); /* 57 */
+    void (*itcl_DeleteMemberCode) _ANSI_ARGS_((char* cdata)); /* 58 */
+    int (*itcl_GetMemberCode) _ANSI_ARGS_((Tcl_Interp* interp, ItclMember* member)); /* 59 */
+    void *reserved60;
+    int (*itcl_EvalMemberCode) _ANSI_ARGS_((Tcl_Interp * interp, ItclMemberFunc * mfunc, ItclMember * member, ItclObject * contextObj, int objc, Tcl_Obj *CONST objv[])); /* 61 */
+    int (*itcl_CreateArgList) _ANSI_ARGS_((Tcl_Interp* interp, CONST char* decl, int* argcPtr, CompiledLocal** argPtr)); /* 62 */
+    CompiledLocal* (*itcl_CreateArg) _ANSI_ARGS_((CONST char* name, CONST char* init)); /* 63 */
+    void (*itcl_DeleteArgList) _ANSI_ARGS_((CompiledLocal * arglist)); /* 64 */
+    Tcl_Obj* (*itcl_ArgList) _ANSI_ARGS_((int argc, CompiledLocal* arglist)); /* 65 */
+    int (*itcl_EquivArgLists) _ANSI_ARGS_((CompiledLocal* arg1, int arg1c, CompiledLocal* arg2, int arg2c)); /* 66 */
+    void (*itcl_GetMemberFuncUsage) _ANSI_ARGS_((ItclMemberFunc * mfunc, ItclObject * contextObj, Tcl_Obj * objPtr)); /* 67 */
+    int (*itcl_ExecMethod) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 68 */
+    int (*itcl_ExecProc) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 69 */
+    int (*itcl_AssignArgs) _ANSI_ARGS_((Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[], ItclMemberFunc * mfunc)); /* 70 */
+    int (*itcl_ConstructBase) _ANSI_ARGS_((Tcl_Interp * interp, ItclObject * contextObj, ItclClass * contextClass)); /* 71 */
+    int (*itcl_InvokeMethodIfExists) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, ItclClass * contextClass, ItclObject * contextObj, int objc, Tcl_Obj *CONST objv[])); /* 72 */
+    void *reserved73;
+    int (*itcl_ReportFuncErrors) _ANSI_ARGS_((Tcl_Interp* interp, ItclMemberFunc * mfunc, ItclObject * contextObj, int result)); /* 74 */
+    int (*itcl_ParseInit) _ANSI_ARGS_((Tcl_Interp * interp, ItclObjectInfo * info)); /* 75 */
+    int (*itcl_ClassCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 76 */
+    int (*itcl_ClassInheritCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 77 */
+    int (*itcl_ClassProtectionCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 78 */
+    int (*itcl_ClassConstructorCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 79 */
+    int (*itcl_ClassDestructorCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 80 */
+    int (*itcl_ClassMethodCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 81 */
+    int (*itcl_ClassProcCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 82 */
+    int (*itcl_ClassVariableCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 83 */
+    int (*itcl_ClassCommonCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 84 */
+    int (*itcl_ParseVarResolver) _ANSI_ARGS_((Tcl_Interp * interp, CONST char* name, Tcl_Namespace * contextNs, int flags, Tcl_Var* rPtr)); /* 85 */
+    int (*itcl_BiInit) _ANSI_ARGS_((Tcl_Interp * interp)); /* 86 */
+    int (*itcl_InstallBiMethods) _ANSI_ARGS_((Tcl_Interp * interp, ItclClass * cdefn)); /* 87 */
+    int (*itcl_BiIsaCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 88 */
+    int (*itcl_BiConfigureCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 89 */
+    int (*itcl_BiCgetCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 90 */
+    int (*itcl_BiChainCmd) _ANSI_ARGS_((ClientData dummy, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 91 */
+    int (*itcl_BiInfoClassCmd) _ANSI_ARGS_((ClientData dummy, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 92 */
+    int (*itcl_BiInfoInheritCmd) _ANSI_ARGS_((ClientData dummy, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 93 */
+    int (*itcl_BiInfoHeritageCmd) _ANSI_ARGS_((ClientData dummy, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 94 */
+    int (*itcl_BiInfoFunctionCmd) _ANSI_ARGS_((ClientData dummy, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 95 */
+    int (*itcl_BiInfoVariableCmd) _ANSI_ARGS_((ClientData dummy, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 96 */
+    int (*itcl_BiInfoBodyCmd) _ANSI_ARGS_((ClientData dummy, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 97 */
+    int (*itcl_BiInfoArgsCmd) _ANSI_ARGS_((ClientData dummy, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 98 */
+    int (*itcl_DefaultInfoCmd) _ANSI_ARGS_((ClientData dummy, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 99 */
+    int (*itcl_EnsembleInit) _ANSI_ARGS_((Tcl_Interp * interp)); /* 100 */
+    int (*itcl_CreateEnsemble) _ANSI_ARGS_((Tcl_Interp * interp, CONST char* ensName)); /* 101 */
+    int (*itcl_AddEnsemblePart) _ANSI_ARGS_((Tcl_Interp * interp, CONST char* ensName, CONST char* partName, CONST char* usageInfo, Tcl_ObjCmdProc * objProc, ClientData clientData, Tcl_CmdDeleteProc * deleteProc)); /* 102 */
+    int (*itcl_GetEnsemblePart) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * ensName, CONST char * partName, Tcl_CmdInfo * infoPtr)); /* 103 */
+    int (*itcl_IsEnsemble) _ANSI_ARGS_((Tcl_CmdInfo* infoPtr)); /* 104 */
+    int (*itcl_GetEnsembleUsage) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * ensName, Tcl_Obj * objPtr)); /* 105 */
+    int (*itcl_GetEnsembleUsageForObj) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * ensObjPtr, Tcl_Obj * objPtr)); /* 106 */
+    int (*itcl_EnsembleCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 107 */
+    int (*itcl_EnsPartCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 108 */
+    int (*itcl_EnsembleErrorCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 109 */
+    void *reserved110;
+    void *reserved111;
+    Itcl_CallFrame* (*_Tcl_GetCallFrame) _ANSI_ARGS_((Tcl_Interp * interp, int level)); /* 112 */
+    Itcl_CallFrame* (*_Tcl_ActivateCallFrame) _ANSI_ARGS_((Tcl_Interp * interp, Itcl_CallFrame * framePtr)); /* 113 */
+    Var* (*_TclNewVar) _ANSI_ARGS_((void)); /* 114 */
+    void (*itcl_Assert) _ANSI_ARGS_((CONST char * testExpr, CONST char * fileName, int lineNum)); /* 115 */
+    int (*itcl_IsObjectCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 116 */
+    int (*itcl_IsClassCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 117 */
+} ItclIntStubs;
+
+TCL_EXTERNC ItclIntStubs *itclIntStubsPtr;
+
+#if defined(USE_ITCL_STUBS) && !defined(USE_ITCL_STUB_PROCS)
+
+/*
+ * Inline function declarations:
+ */
+
+#ifndef Itcl_IsClassNamespace
+#define Itcl_IsClassNamespace \
+	(itclIntStubsPtr->itcl_IsClassNamespace) /* 0 */
+#endif
+#ifndef Itcl_IsClass
+#define Itcl_IsClass \
+	(itclIntStubsPtr->itcl_IsClass) /* 1 */
+#endif
+#ifndef Itcl_FindClass
+#define Itcl_FindClass \
+	(itclIntStubsPtr->itcl_FindClass) /* 2 */
+#endif
+#ifndef Itcl_FindObject
+#define Itcl_FindObject \
+	(itclIntStubsPtr->itcl_FindObject) /* 3 */
+#endif
+#ifndef Itcl_IsObject
+#define Itcl_IsObject \
+	(itclIntStubsPtr->itcl_IsObject) /* 4 */
+#endif
+#ifndef Itcl_ObjectIsa
+#define Itcl_ObjectIsa \
+	(itclIntStubsPtr->itcl_ObjectIsa) /* 5 */
+#endif
+#ifndef Itcl_Protection
+#define Itcl_Protection \
+	(itclIntStubsPtr->itcl_Protection) /* 6 */
+#endif
+#ifndef Itcl_ProtectionStr
+#define Itcl_ProtectionStr \
+	(itclIntStubsPtr->itcl_ProtectionStr) /* 7 */
+#endif
+#ifndef Itcl_CanAccess
+#define Itcl_CanAccess \
+	(itclIntStubsPtr->itcl_CanAccess) /* 8 */
+#endif
+#ifndef Itcl_CanAccessFunc
+#define Itcl_CanAccessFunc \
+	(itclIntStubsPtr->itcl_CanAccessFunc) /* 9 */
+#endif
+#ifndef Itcl_GetTrueNamespace
+#define Itcl_GetTrueNamespace \
+	(itclIntStubsPtr->itcl_GetTrueNamespace) /* 10 */
+#endif
+#ifndef Itcl_ParseNamespPath
+#define Itcl_ParseNamespPath \
+	(itclIntStubsPtr->itcl_ParseNamespPath) /* 11 */
+#endif
+#ifndef Itcl_DecodeScopedCommand
+#define Itcl_DecodeScopedCommand \
+	(itclIntStubsPtr->itcl_DecodeScopedCommand) /* 12 */
+#endif
+#ifndef Itcl_EvalArgs
+#define Itcl_EvalArgs \
+	(itclIntStubsPtr->itcl_EvalArgs) /* 13 */
+#endif
+#ifndef Itcl_CreateArgs
+#define Itcl_CreateArgs \
+	(itclIntStubsPtr->itcl_CreateArgs) /* 14 */
+#endif
+#ifndef Itcl_PushContext
+#define Itcl_PushContext \
+	(itclIntStubsPtr->itcl_PushContext) /* 15 */
+#endif
+#ifndef Itcl_PopContext
+#define Itcl_PopContext \
+	(itclIntStubsPtr->itcl_PopContext) /* 16 */
+#endif
+#ifndef Itcl_GetContext
+#define Itcl_GetContext \
+	(itclIntStubsPtr->itcl_GetContext) /* 17 */
+#endif
+#ifndef Itcl_InitHierIter
+#define Itcl_InitHierIter \
+	(itclIntStubsPtr->itcl_InitHierIter) /* 18 */
+#endif
+#ifndef Itcl_DeleteHierIter
+#define Itcl_DeleteHierIter \
+	(itclIntStubsPtr->itcl_DeleteHierIter) /* 19 */
+#endif
+#ifndef Itcl_AdvanceHierIter
+#define Itcl_AdvanceHierIter \
+	(itclIntStubsPtr->itcl_AdvanceHierIter) /* 20 */
+#endif
+#ifndef Itcl_FindClassesCmd
+#define Itcl_FindClassesCmd \
+	(itclIntStubsPtr->itcl_FindClassesCmd) /* 21 */
+#endif
+#ifndef Itcl_FindObjectsCmd
+#define Itcl_FindObjectsCmd \
+	(itclIntStubsPtr->itcl_FindObjectsCmd) /* 22 */
+#endif
+#ifndef Itcl_ProtectionCmd
+#define Itcl_ProtectionCmd \
+	(itclIntStubsPtr->itcl_ProtectionCmd) /* 23 */
+#endif
+#ifndef Itcl_DelClassCmd
+#define Itcl_DelClassCmd \
+	(itclIntStubsPtr->itcl_DelClassCmd) /* 24 */
+#endif
+#ifndef Itcl_DelObjectCmd
+#define Itcl_DelObjectCmd \
+	(itclIntStubsPtr->itcl_DelObjectCmd) /* 25 */
+#endif
+#ifndef Itcl_ScopeCmd
+#define Itcl_ScopeCmd \
+	(itclIntStubsPtr->itcl_ScopeCmd) /* 26 */
+#endif
+#ifndef Itcl_CodeCmd
+#define Itcl_CodeCmd \
+	(itclIntStubsPtr->itcl_CodeCmd) /* 27 */
+#endif
+#ifndef Itcl_StubCreateCmd
+#define Itcl_StubCreateCmd \
+	(itclIntStubsPtr->itcl_StubCreateCmd) /* 28 */
+#endif
+#ifndef Itcl_StubExistsCmd
+#define Itcl_StubExistsCmd \
+	(itclIntStubsPtr->itcl_StubExistsCmd) /* 29 */
+#endif
+#ifndef Itcl_IsStub
+#define Itcl_IsStub \
+	(itclIntStubsPtr->itcl_IsStub) /* 30 */
+#endif
+#ifndef Itcl_CreateClass
+#define Itcl_CreateClass \
+	(itclIntStubsPtr->itcl_CreateClass) /* 31 */
+#endif
+#ifndef Itcl_DeleteClass
+#define Itcl_DeleteClass \
+	(itclIntStubsPtr->itcl_DeleteClass) /* 32 */
+#endif
+#ifndef Itcl_FindClassNamespace
+#define Itcl_FindClassNamespace \
+	(itclIntStubsPtr->itcl_FindClassNamespace) /* 33 */
+#endif
+#ifndef Itcl_HandleClass
+#define Itcl_HandleClass \
+	(itclIntStubsPtr->itcl_HandleClass) /* 34 */
+#endif
+#ifndef Itcl_ClassCmdResolver
+#define Itcl_ClassCmdResolver \
+	(itclIntStubsPtr->itcl_ClassCmdResolver) /* 35 */
+#endif
+#ifndef Itcl_ClassVarResolver
+#define Itcl_ClassVarResolver \
+	(itclIntStubsPtr->itcl_ClassVarResolver) /* 36 */
+#endif
+#ifndef Itcl_ClassCompiledVarResolver
+#define Itcl_ClassCompiledVarResolver \
+	(itclIntStubsPtr->itcl_ClassCompiledVarResolver) /* 37 */
+#endif
+#ifndef Itcl_BuildVirtualTables
+#define Itcl_BuildVirtualTables \
+	(itclIntStubsPtr->itcl_BuildVirtualTables) /* 38 */
+#endif
+#ifndef Itcl_CreateVarDefn
+#define Itcl_CreateVarDefn \
+	(itclIntStubsPtr->itcl_CreateVarDefn) /* 39 */
+#endif
+#ifndef Itcl_DeleteVarDefn
+#define Itcl_DeleteVarDefn \
+	(itclIntStubsPtr->itcl_DeleteVarDefn) /* 40 */
+#endif
+#ifndef Itcl_GetCommonVar
+#define Itcl_GetCommonVar \
+	(itclIntStubsPtr->itcl_GetCommonVar) /* 41 */
+#endif
+#ifndef Itcl_CreateMember
+#define Itcl_CreateMember \
+	(itclIntStubsPtr->itcl_CreateMember) /* 42 */
+#endif
+#ifndef Itcl_DeleteMember
+#define Itcl_DeleteMember \
+	(itclIntStubsPtr->itcl_DeleteMember) /* 43 */
+#endif
+#ifndef Itcl_CreateObject
+#define Itcl_CreateObject \
+	(itclIntStubsPtr->itcl_CreateObject) /* 44 */
+#endif
+#ifndef Itcl_DeleteObject
+#define Itcl_DeleteObject \
+	(itclIntStubsPtr->itcl_DeleteObject) /* 45 */
+#endif
+#ifndef Itcl_DestructObject
+#define Itcl_DestructObject \
+	(itclIntStubsPtr->itcl_DestructObject) /* 46 */
+#endif
+#ifndef Itcl_HandleInstance
+#define Itcl_HandleInstance \
+	(itclIntStubsPtr->itcl_HandleInstance) /* 47 */
+#endif
+#ifndef Itcl_GetInstanceVar
+#define Itcl_GetInstanceVar \
+	(itclIntStubsPtr->itcl_GetInstanceVar) /* 48 */
+#endif
+#ifndef Itcl_ScopedVarResolver
+#define Itcl_ScopedVarResolver \
+	(itclIntStubsPtr->itcl_ScopedVarResolver) /* 49 */
+#endif
+#ifndef Itcl_BodyCmd
+#define Itcl_BodyCmd \
+	(itclIntStubsPtr->itcl_BodyCmd) /* 50 */
+#endif
+#ifndef Itcl_ConfigBodyCmd
+#define Itcl_ConfigBodyCmd \
+	(itclIntStubsPtr->itcl_ConfigBodyCmd) /* 51 */
+#endif
+#ifndef Itcl_CreateMethod
+#define Itcl_CreateMethod \
+	(itclIntStubsPtr->itcl_CreateMethod) /* 52 */
+#endif
+#ifndef Itcl_CreateProc
+#define Itcl_CreateProc \
+	(itclIntStubsPtr->itcl_CreateProc) /* 53 */
+#endif
+#ifndef Itcl_CreateMemberFunc
+#define Itcl_CreateMemberFunc \
+	(itclIntStubsPtr->itcl_CreateMemberFunc) /* 54 */
+#endif
+#ifndef Itcl_ChangeMemberFunc
+#define Itcl_ChangeMemberFunc \
+	(itclIntStubsPtr->itcl_ChangeMemberFunc) /* 55 */
+#endif
+#ifndef Itcl_DeleteMemberFunc
+#define Itcl_DeleteMemberFunc \
+	(itclIntStubsPtr->itcl_DeleteMemberFunc) /* 56 */
+#endif
+#ifndef Itcl_CreateMemberCode
+#define Itcl_CreateMemberCode \
+	(itclIntStubsPtr->itcl_CreateMemberCode) /* 57 */
+#endif
+#ifndef Itcl_DeleteMemberCode
+#define Itcl_DeleteMemberCode \
+	(itclIntStubsPtr->itcl_DeleteMemberCode) /* 58 */
+#endif
+#ifndef Itcl_GetMemberCode
+#define Itcl_GetMemberCode \
+	(itclIntStubsPtr->itcl_GetMemberCode) /* 59 */
+#endif
+/* Slot 60 is reserved */
+#ifndef Itcl_EvalMemberCode
+#define Itcl_EvalMemberCode \
+	(itclIntStubsPtr->itcl_EvalMemberCode) /* 61 */
+#endif
+#ifndef Itcl_CreateArgList
+#define Itcl_CreateArgList \
+	(itclIntStubsPtr->itcl_CreateArgList) /* 62 */
+#endif
+#ifndef Itcl_CreateArg
+#define Itcl_CreateArg \
+	(itclIntStubsPtr->itcl_CreateArg) /* 63 */
+#endif
+#ifndef Itcl_DeleteArgList
+#define Itcl_DeleteArgList \
+	(itclIntStubsPtr->itcl_DeleteArgList) /* 64 */
+#endif
+#ifndef Itcl_ArgList
+#define Itcl_ArgList \
+	(itclIntStubsPtr->itcl_ArgList) /* 65 */
+#endif
+#ifndef Itcl_EquivArgLists
+#define Itcl_EquivArgLists \
+	(itclIntStubsPtr->itcl_EquivArgLists) /* 66 */
+#endif
+#ifndef Itcl_GetMemberFuncUsage
+#define Itcl_GetMemberFuncUsage \
+	(itclIntStubsPtr->itcl_GetMemberFuncUsage) /* 67 */
+#endif
+#ifndef Itcl_ExecMethod
+#define Itcl_ExecMethod \
+	(itclIntStubsPtr->itcl_ExecMethod) /* 68 */
+#endif
+#ifndef Itcl_ExecProc
+#define Itcl_ExecProc \
+	(itclIntStubsPtr->itcl_ExecProc) /* 69 */
+#endif
+#ifndef Itcl_AssignArgs
+#define Itcl_AssignArgs \
+	(itclIntStubsPtr->itcl_AssignArgs) /* 70 */
+#endif
+#ifndef Itcl_ConstructBase
+#define Itcl_ConstructBase \
+	(itclIntStubsPtr->itcl_ConstructBase) /* 71 */
+#endif
+#ifndef Itcl_InvokeMethodIfExists
+#define Itcl_InvokeMethodIfExists \
+	(itclIntStubsPtr->itcl_InvokeMethodIfExists) /* 72 */
+#endif
+/* Slot 73 is reserved */
+#ifndef Itcl_ReportFuncErrors
+#define Itcl_ReportFuncErrors \
+	(itclIntStubsPtr->itcl_ReportFuncErrors) /* 74 */
+#endif
+#ifndef Itcl_ParseInit
+#define Itcl_ParseInit \
+	(itclIntStubsPtr->itcl_ParseInit) /* 75 */
+#endif
+#ifndef Itcl_ClassCmd
+#define Itcl_ClassCmd \
+	(itclIntStubsPtr->itcl_ClassCmd) /* 76 */
+#endif
+#ifndef Itcl_ClassInheritCmd
+#define Itcl_ClassInheritCmd \
+	(itclIntStubsPtr->itcl_ClassInheritCmd) /* 77 */
+#endif
+#ifndef Itcl_ClassProtectionCmd
+#define Itcl_ClassProtectionCmd \
+	(itclIntStubsPtr->itcl_ClassProtectionCmd) /* 78 */
+#endif
+#ifndef Itcl_ClassConstructorCmd
+#define Itcl_ClassConstructorCmd \
+	(itclIntStubsPtr->itcl_ClassConstructorCmd) /* 79 */
+#endif
+#ifndef Itcl_ClassDestructorCmd
+#define Itcl_ClassDestructorCmd \
+	(itclIntStubsPtr->itcl_ClassDestructorCmd) /* 80 */
+#endif
+#ifndef Itcl_ClassMethodCmd
+#define Itcl_ClassMethodCmd \
+	(itclIntStubsPtr->itcl_ClassMethodCmd) /* 81 */
+#endif
+#ifndef Itcl_ClassProcCmd
+#define Itcl_ClassProcCmd \
+	(itclIntStubsPtr->itcl_ClassProcCmd) /* 82 */
+#endif
+#ifndef Itcl_ClassVariableCmd
+#define Itcl_ClassVariableCmd \
+	(itclIntStubsPtr->itcl_ClassVariableCmd) /* 83 */
+#endif
+#ifndef Itcl_ClassCommonCmd
+#define Itcl_ClassCommonCmd \
+	(itclIntStubsPtr->itcl_ClassCommonCmd) /* 84 */
+#endif
+#ifndef Itcl_ParseVarResolver
+#define Itcl_ParseVarResolver \
+	(itclIntStubsPtr->itcl_ParseVarResolver) /* 85 */
+#endif
+#ifndef Itcl_BiInit
+#define Itcl_BiInit \
+	(itclIntStubsPtr->itcl_BiInit) /* 86 */
+#endif
+#ifndef Itcl_InstallBiMethods
+#define Itcl_InstallBiMethods \
+	(itclIntStubsPtr->itcl_InstallBiMethods) /* 87 */
+#endif
+#ifndef Itcl_BiIsaCmd
+#define Itcl_BiIsaCmd \
+	(itclIntStubsPtr->itcl_BiIsaCmd) /* 88 */
+#endif
+#ifndef Itcl_BiConfigureCmd
+#define Itcl_BiConfigureCmd \
+	(itclIntStubsPtr->itcl_BiConfigureCmd) /* 89 */
+#endif
+#ifndef Itcl_BiCgetCmd
+#define Itcl_BiCgetCmd \
+	(itclIntStubsPtr->itcl_BiCgetCmd) /* 90 */
+#endif
+#ifndef Itcl_BiChainCmd
+#define Itcl_BiChainCmd \
+	(itclIntStubsPtr->itcl_BiChainCmd) /* 91 */
+#endif
+#ifndef Itcl_BiInfoClassCmd
+#define Itcl_BiInfoClassCmd \
+	(itclIntStubsPtr->itcl_BiInfoClassCmd) /* 92 */
+#endif
+#ifndef Itcl_BiInfoInheritCmd
+#define Itcl_BiInfoInheritCmd \
+	(itclIntStubsPtr->itcl_BiInfoInheritCmd) /* 93 */
+#endif
+#ifndef Itcl_BiInfoHeritageCmd
+#define Itcl_BiInfoHeritageCmd \
+	(itclIntStubsPtr->itcl_BiInfoHeritageCmd) /* 94 */
+#endif
+#ifndef Itcl_BiInfoFunctionCmd
+#define Itcl_BiInfoFunctionCmd \
+	(itclIntStubsPtr->itcl_BiInfoFunctionCmd) /* 95 */
+#endif
+#ifndef Itcl_BiInfoVariableCmd
+#define Itcl_BiInfoVariableCmd \
+	(itclIntStubsPtr->itcl_BiInfoVariableCmd) /* 96 */
+#endif
+#ifndef Itcl_BiInfoBodyCmd
+#define Itcl_BiInfoBodyCmd \
+	(itclIntStubsPtr->itcl_BiInfoBodyCmd) /* 97 */
+#endif
+#ifndef Itcl_BiInfoArgsCmd
+#define Itcl_BiInfoArgsCmd \
+	(itclIntStubsPtr->itcl_BiInfoArgsCmd) /* 98 */
+#endif
+#ifndef Itcl_DefaultInfoCmd
+#define Itcl_DefaultInfoCmd \
+	(itclIntStubsPtr->itcl_DefaultInfoCmd) /* 99 */
+#endif
+#ifndef Itcl_EnsembleInit
+#define Itcl_EnsembleInit \
+	(itclIntStubsPtr->itcl_EnsembleInit) /* 100 */
+#endif
+#ifndef Itcl_CreateEnsemble
+#define Itcl_CreateEnsemble \
+	(itclIntStubsPtr->itcl_CreateEnsemble) /* 101 */
+#endif
+#ifndef Itcl_AddEnsemblePart
+#define Itcl_AddEnsemblePart \
+	(itclIntStubsPtr->itcl_AddEnsemblePart) /* 102 */
+#endif
+#ifndef Itcl_GetEnsemblePart
+#define Itcl_GetEnsemblePart \
+	(itclIntStubsPtr->itcl_GetEnsemblePart) /* 103 */
+#endif
+#ifndef Itcl_IsEnsemble
+#define Itcl_IsEnsemble \
+	(itclIntStubsPtr->itcl_IsEnsemble) /* 104 */
+#endif
+#ifndef Itcl_GetEnsembleUsage
+#define Itcl_GetEnsembleUsage \
+	(itclIntStubsPtr->itcl_GetEnsembleUsage) /* 105 */
+#endif
+#ifndef Itcl_GetEnsembleUsageForObj
+#define Itcl_GetEnsembleUsageForObj \
+	(itclIntStubsPtr->itcl_GetEnsembleUsageForObj) /* 106 */
+#endif
+#ifndef Itcl_EnsembleCmd
+#define Itcl_EnsembleCmd \
+	(itclIntStubsPtr->itcl_EnsembleCmd) /* 107 */
+#endif
+#ifndef Itcl_EnsPartCmd
+#define Itcl_EnsPartCmd \
+	(itclIntStubsPtr->itcl_EnsPartCmd) /* 108 */
+#endif
+#ifndef Itcl_EnsembleErrorCmd
+#define Itcl_EnsembleErrorCmd \
+	(itclIntStubsPtr->itcl_EnsembleErrorCmd) /* 109 */
+#endif
+/* Slot 110 is reserved */
+/* Slot 111 is reserved */
+#ifndef _Tcl_GetCallFrame
+#define _Tcl_GetCallFrame \
+	(itclIntStubsPtr->_Tcl_GetCallFrame) /* 112 */
+#endif
+#ifndef _Tcl_ActivateCallFrame
+#define _Tcl_ActivateCallFrame \
+	(itclIntStubsPtr->_Tcl_ActivateCallFrame) /* 113 */
+#endif
+#ifndef _TclNewVar
+#define _TclNewVar \
+	(itclIntStubsPtr->_TclNewVar) /* 114 */
+#endif
+#ifndef Itcl_Assert
+#define Itcl_Assert \
+	(itclIntStubsPtr->itcl_Assert) /* 115 */
+#endif
+#ifndef Itcl_IsObjectCmd
+#define Itcl_IsObjectCmd \
+	(itclIntStubsPtr->itcl_IsObjectCmd) /* 116 */
+#endif
+#ifndef Itcl_IsClassCmd
+#define Itcl_IsClassCmd \
+	(itclIntStubsPtr->itcl_IsClassCmd) /* 117 */
+#endif
+
+#endif /* defined(USE_ITCL_STUBS) && !defined(USE_ITCL_STUB_PROCS) */
+
+/* !END!: Do not edit above this line. */
+
+#endif /* _ITCLINTDECLS */
diff -Naur itk/generic/itcl3/itclInt.h ITK_BLD/generic/itcl3/itclInt.h
--- itk/generic/itcl3/itclInt.h	1969-12-31 19:00:00.000000000 -0500
+++ ITK_BLD/generic/itcl3/itclInt.h	2024-07-10 10:40:21.279659891 -0400
@@ -0,0 +1,468 @@
+/*
+ * ------------------------------------------------------------------------
+ *      PACKAGE:  [incr Tcl]
+ *  DESCRIPTION:  Object-Oriented Extensions to Tcl
+ *
+ *  [incr Tcl] provides object-oriented extensions to Tcl, much as
+ *  C++ provides object-oriented extensions to C.  It provides a means
+ *  of encapsulating related procedures together with their shared data
+ *  in a local namespace that is hidden from the outside world.  It
+ *  promotes code re-use through inheritance.  More than anything else,
+ *  it encourages better organization of Tcl applications through the
+ *  object-oriented paradigm, leading to code that is easier to
+ *  understand and maintain.
+ *  
+ *  ADDING [incr Tcl] TO A Tcl-BASED APPLICATION:
+ *
+ *    To add [incr Tcl] facilities to a Tcl application, modify the
+ *    Tcl_AppInit() routine as follows:
+ *
+ *    1) Include this header file near the top of the file containing
+ *       Tcl_AppInit():
+ *
+ *         #include "itcl.h"
+ *
+ *    2) Within the body of Tcl_AppInit(), add the following lines:
+ *
+ *         if (Itcl_Init(interp) == TCL_ERROR) {
+ *             return TCL_ERROR;
+ *         }
+ * 
+ *    3) Link your application with libitcl.a
+ *
+ *    NOTE:  An example file "tclAppInit.c" containing the changes shown
+ *           above is included in this distribution.
+ *  
+ * ========================================================================
+ *  AUTHOR:  Michael J. McLennan
+ *           Bell Labs Innovations for Lucent Technologies
+ *           mmclennan@lucent.com
+ *           http://www.tcltk.com/itcl
+ * ========================================================================
+ *           Copyright (c) 1993-1998  Lucent Technologies, Inc.
+ * ------------------------------------------------------------------------
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ */
+#ifndef ITCLINT_H
+#define ITCLINT_H
+
+#include "tclInt.h"
+#include "itcl.h"
+
+#ifdef BUILD_itcl
+# undef TCL_STORAGE_CLASS
+# define TCL_STORAGE_CLASS DLLEXPORT
+#endif
+
+/*
+ * Handle hiding of errorLine in 8.6
+ */
+#if (TCL_MAJOR_VERSION == 8) && (TCL_MINOR_VERSION < 6)
+#define Tcl_GetErrorLine(interp) ((interp)->errorLine)
+#endif
+
+#define ITCL_TCL_PRE_8_5 (TCL_MAJOR_VERSION == 8 && TCL_MINOR_VERSION < 5)
+
+#define ItclCallFrame CallFrame
+
+#if !ITCL_TCL_PRE_8_5
+
+#define Itcl_CallFrame Tcl_CallFrame
+
+#if defined(USE_TCL_STUBS)
+
+/*
+ * Fix Tcl bug #803489 the right way.  We need to always use the old Stub
+ * slot positions, not the new broken ones part of TIP 127.  I do like
+ * that these functions have moved to the public space (about time), but
+ * the slot change is the killer and is the painful side affect.
+ */
+
+#   undef Tcl_CreateNamespace
+#   define Tcl_CreateNamespace \
+	(tclIntStubsPtr->tcl_CreateNamespace)
+#   undef Tcl_DeleteNamespace
+#   define Tcl_DeleteNamespace \
+	(tclIntStubsPtr->tcl_DeleteNamespace)
+#   undef Tcl_AppendExportList
+#   define Tcl_AppendExportList \
+	(tclIntStubsPtr->tcl_AppendExportList)
+#   undef Tcl_Export
+#   define Tcl_Export \
+	(tclIntStubsPtr->tcl_Export)
+#   undef Tcl_Import
+#   define Tcl_Import \
+	(tclIntStubsPtr->tcl_Import)
+#   undef Tcl_ForgetImport
+#   define Tcl_ForgetImport \
+	(tclIntStubsPtr->tcl_ForgetImport)
+#   undef Tcl_GetCurrentNamespace
+#   define Tcl_GetCurrentNamespace \
+	(tclIntStubsPtr->tcl_GetCurrentNamespace)
+#   undef Tcl_GetGlobalNamespace
+#   define Tcl_GetGlobalNamespace \
+	(tclIntStubsPtr->tcl_GetGlobalNamespace)
+#   undef Tcl_FindNamespace
+#   define Tcl_FindNamespace \
+	(tclIntStubsPtr->tcl_FindNamespace)
+#   undef Tcl_FindCommand
+#   define Tcl_FindCommand \
+	(tclIntStubsPtr->tcl_FindCommand)
+#   undef Tcl_GetCommandFromObj
+#   define Tcl_GetCommandFromObj \
+	(tclIntStubsPtr->tcl_GetCommandFromObj)
+#   undef Tcl_GetCommandFullName
+#   define Tcl_GetCommandFullName \
+	(tclIntStubsPtr->tcl_GetCommandFullName)
+#endif /* use stubs */
+
+#define ItclInitVarFlags(varPtr) \
+    (varPtr)->flags = 0
+
+#define ItclInitVarArgument(varPtr) \
+   (varPtr)->flags = VAR_ARGUMENT 
+
+#define ItclVarHashCreateVar(tablePtr, key, newPtr) \
+    TclVarHashCreateVar((tablePtr), (key), (newPtr))
+
+#define ItclVarRefCount(varPtr) VarHashRefCount(varPtr)
+
+#define ItclClearVarUndefined(varPtr)
+
+#define ItclNextLocal(varPtr) ((varPtr)++)
+
+#define ItclVarObjValue(varPtr) ((varPtr)->value.objPtr)
+
+#define itclVarInHashSize sizeof(VarInHash)
+#define itclVarLocalSize  sizeof(Var)
+
+#else /* Compiling on Tcl8.x, x<5 */ 
+
+typedef struct Itcl_CallFrame {
+    Tcl_Namespace *nsPtr;
+    int dummy1;
+    int dummy2;
+    void *dummy3;
+    void *dummy4;
+    void *dummy5;
+    int dummy6;
+    void *dummy7;
+    void *dummy8;
+    int dummy9;
+    void *dummy10;
+    void *dummy11;
+    void *dummy12;
+    void *dummy13;
+} Itcl_CallFrame;
+
+/*
+ * Definition of runtime behaviour to be able to run irrespective of the Tcl
+ * version.
+ */
+
+#define VarInHash Var
+
+#define TclVarHashTable Tcl_HashTable
+
+typedef struct ItclShortVar {
+    int flags;
+    union {
+	Tcl_Obj *objPtr;
+	TclVarHashTable *tablePtr;
+	struct Var *linkPtr;
+    } value;
+} ItclShortVar;
+
+typedef struct ItclVarInHash {
+    ItclShortVar var;
+    int refCount;
+    Tcl_HashEntry entry;
+} ItclVarInHash;
+
+#define ItclOffset(type, field) ((int) ((char *) &((type *) 0)->field))
+
+#define itclOldRuntime (itclVarFlagOffset!=0)
+
+extern int itclVarFlagOffset; 
+extern int itclVarRefCountOffset;
+extern int itclVarInHashSize;
+extern int itclVarLocalSize;
+extern int itclVarValueOffset;
+
+/*
+ * VarReform related macros: provide access to the Var fields with offsets
+ * determined at load time, so that the same code copes with the different
+ * structs in Tcl8.5 and previous Tcl.
+ */
+
+#define ItclNextLocal(varPtr) \
+    ((varPtr) = (Var *) (((char *)(varPtr))+itclVarLocalSize))
+
+#define ItclVarObjValue(varPtr) \
+    (*((Tcl_Obj **) (((char *)(varPtr))+itclVarValueOffset)))
+
+#define ItclVarRefCount(varPtr) \
+    (*((int *) (((char *)(varPtr))+itclVarRefCountOffset)))
+
+#define ItclVarFlags(varPtr) \
+    (*((int *)(((char *)(varPtr))+itclVarFlagOffset)))
+
+/* Note that itclVarFlagOffset==0 exactly when we are running in Tcl8.5 */
+#define ItclInitVarFlags(varPtr) \
+    if (itclOldRuntime) { \
+	(varPtr)->flags = (VAR_SCALAR | VAR_UNDEFINED | VAR_IN_HASHTABLE);\
+    } else { \
+        ((ItclShortVar *)(varPtr))->flags = 0;\
+    }
+
+/* This is used for CompiledLocal, not for Var & Co. That struct did not
+ * change, but the correct flag init did! The flags bits themselves are
+ * unchanged */
+
+#define ItclInitVarArgument(varPtr) \
+    if (itclOldRuntime) { \
+	(varPtr)->flags = (VAR_SCALAR | VAR_ARGUMENT);\
+    } else { \
+	(varPtr)->flags = VAR_ARGUMENT;\
+    }
+
+#define TclIsVarNamespaceVar(varPtr) \
+    (ItclVarFlags(varPtr) & VAR_NAMESPACE_VAR)
+
+#define TclSetVarNamespaceVar(varPtr) \
+    if (!TclIsVarNamespaceVar(varPtr)) {\
+        ItclVarFlags(varPtr) |= VAR_NAMESPACE_VAR;\
+        ItclVarRefCount(varPtr)++;\
+    }
+
+#define ItclClearVarUndefined(varPtr) \
+    if (itclOldRuntime) { \
+	ItclVarFlags(varPtr) &= ~VAR_UNDEFINED;\
+    }
+
+#ifndef MODULE_SCOPE
+#define MODULE_SCOPE
+#endif
+
+MODULE_SCOPE Var * ItclVarHashCreateVar (TclVarHashTable * tablePtr, 
+				const char * key, int * newPtr);
+
+#endif /* Version dependent defs and macros */
+
+
+#define ItclVarHashFindVar(tablePtr, key) \
+    ItclVarHashCreateVar((tablePtr), (key), NULL)
+
+
+/*
+ *  Common info for managing all known objects.
+ *  Each interpreter has one of these data structures stored as
+ *  clientData in the "itcl" namespace.  It is also accessible
+ *  as associated data via the key ITCL_INTERP_DATA.
+ */
+struct ItclObject;
+typedef struct ItclObjectInfo {
+    Tcl_Interp *interp;             /* interpreter that manages this info */
+    Tcl_HashTable objects;          /* list of all known objects */
+
+    Itcl_Stack transparentFrames;   /* stack of call frames that should be
+                                     * treated transparently.  When
+                                     * Itcl_EvalMemberCode is invoked in
+                                     * one of these contexts, it does an
+                                     * "uplevel" to get past the transparent
+                                     * frame and back to the calling context. */
+    Tcl_HashTable contextFrames;    /* object contexts for active call frames */
+
+    int protection;                 /* protection level currently in effect */
+
+    Itcl_Stack cdefnStack;          /* stack of class definitions currently
+                                     * being parsed */
+} ItclObjectInfo;
+
+#define ITCL_INTERP_DATA "itcl_data"
+
+/*
+ *  Representation for each [incr Tcl] class.
+ */
+typedef struct ItclClass {
+    char *name;                   /* class name */
+    char *fullname;               /* fully qualified class name */
+    Tcl_Interp *interp;           /* interpreter that manages this info */
+    Tcl_Namespace *namesp;        /* namespace representing class scope */
+    Tcl_Command accessCmd;        /* access command for creating instances */
+
+    struct ItclObjectInfo *info;  /* info about all known objects */
+    Itcl_List bases;              /* list of base classes */
+    Itcl_List derived;            /* list of all derived classes */
+    Tcl_HashTable heritage;       /* table of all base classes.  Look up
+                                   * by pointer to class definition.  This
+                                   * provides fast lookup for inheritance
+                                   * tests. */
+    Tcl_Obj *initCode;            /* initialization code for new objs */
+    Tcl_HashTable variables;      /* definitions for all data members
+                                     in this class.  Look up simple string
+                                     names and get back ItclVarDefn* ptrs */
+    Tcl_HashTable functions;      /* definitions for all member functions
+                                     in this class.  Look up simple string
+                                     names and get back ItclMemberFunc* ptrs */
+    int numInstanceVars;          /* number of instance vars in variables
+                                     table */
+    Tcl_HashTable resolveVars;    /* all possible names for variables in
+                                   * this class (e.g., x, foo::x, etc.) */
+    Tcl_HashTable resolveCmds;    /* all possible names for functions in
+                                   * this class (e.g., x, foo::x, etc.) */
+    int unique;                   /* unique number for #auto generation */
+    int flags;                    /* maintains class status */
+} ItclClass;
+
+typedef struct ItclHierIter {
+    ItclClass *current;           /* current position in hierarchy */
+    Itcl_Stack stack;             /* stack used for traversal */
+} ItclHierIter;
+
+/*
+ *  Representation for each [incr Tcl] object.
+ */
+typedef struct ItclObject {
+    ItclClass *classDefn;        /* most-specific class */
+    Tcl_Command accessCmd;       /* object access command */
+
+    int dataSize;                /* number of elements in data array */
+    Var** data;                  /* all object-specific data members */
+    Tcl_HashTable* constructed;  /* temp storage used during construction */
+    Tcl_HashTable* destructed;   /* temp storage used during destruction */
+} ItclObject;
+
+#define ITCL_IGNORE_ERRS  0x002  /* useful for construction/destruction */
+
+/*
+ *  Implementation for any code body in an [incr Tcl] class.
+ */
+typedef struct ItclMemberCode {
+    int flags;                  /* flags describing implementation */
+    CompiledLocal *arglist;     /* list of arg names and initial values */
+    int argcount;               /* number of args in arglist */
+    Proc *procPtr;              /* Tcl proc representation (needed to
+                                 * handle compiled locals) */
+    union {
+        Tcl_CmdProc *argCmd;    /* (argc,argv) C implementation */
+        Tcl_ObjCmdProc *objCmd; /* (objc,objv) C implementation */
+    } cfunc;
+
+    ClientData clientData;      /* client data for C implementations */
+
+} ItclMemberCode;
+
+#define Itcl_IsMemberCodeImplemented(mcode) \
+    (((mcode)->flags & ITCL_IMPLEMENT_NONE) == 0)
+
+/*
+ *  Basic representation for class members (commands/variables)
+ */
+typedef struct ItclMember {
+    Tcl_Interp* interp;         /* interpreter containing the class */
+    ItclClass* classDefn;       /* class containing this member */
+    char* name;                 /* member name */
+    char* fullname;             /* member name with "class::" qualifier */
+    int protection;             /* protection level */
+    int flags;                  /* flags describing member (see below) */
+    ItclMemberCode *code;       /* code associated with member */
+} ItclMember;
+
+/*
+ *  Flag bits for ItclMemberCode and ItclMember:
+ */
+#define ITCL_IMPLEMENT_NONE    0x001  /* no implementation */
+#define ITCL_IMPLEMENT_TCL     0x002  /* Tcl implementation */
+#define ITCL_IMPLEMENT_ARGCMD  0x004  /* (argc,argv) C implementation */
+#define ITCL_IMPLEMENT_OBJCMD  0x008  /* (objc,objv) C implementation */
+#define ITCL_IMPLEMENT_C       0x00c  /* either kind of C implementation */
+#define ITCL_CONSTRUCTOR       0x010  /* non-zero => is a constructor */
+#define ITCL_DESTRUCTOR        0x020  /* non-zero => is a destructor */
+#define ITCL_COMMON            0x040  /* non-zero => is a "proc" */
+#define ITCL_ARG_SPEC          0x080  /* non-zero => has an argument spec */
+
+#define ITCL_OLD_STYLE         0x100  /* non-zero => old-style method
+                                       * (process "config" argument) */
+
+#define ITCL_THIS_VAR          0x200  /* non-zero => built-in "this" variable */
+
+/*
+ *  Representation of member functions in an [incr Tcl] class.
+ */
+typedef struct ItclMemberFunc {
+    ItclMember *member;          /* basic member info */
+    Tcl_Command accessCmd;       /* Tcl command installed for this function */
+    CompiledLocal *arglist;      /* list of arg names and initial values */
+    int argcount;                /* number of args in arglist */
+} ItclMemberFunc;
+
+/*
+ *  Instance variables.
+ */
+typedef struct ItclVarDefn {
+    ItclMember *member;          /* basic member info */
+    char* init;                  /* initial value */
+} ItclVarDefn;
+
+/*
+ *  Instance variable lookup entry.
+ */
+typedef struct ItclVarLookup {
+    ItclVarDefn* vdefn;       /* variable definition */
+    int usage;                /* number of uses for this record */
+    int accessible;           /* non-zero => accessible from class with
+                               * this lookup record in its resolveVars */
+    char *leastQualName;      /* simplist name for this variable, with
+                               * the fewest qualifiers.  This string is
+                               * taken from the resolveVars table, so
+                               * it shouldn't be freed. */
+    union {
+        int index;            /* index into virtual table (instance data) */
+        Tcl_Var common;       /* variable (common data) */
+    } var;
+} ItclVarLookup;
+
+/*
+ *  Representation for the context in which a body of [incr Tcl]
+ *  code executes.  In ordinary Tcl, this is a CallFrame.  But for
+ *  [incr Tcl] code bodies, we must be careful to set up the
+ *  CallFrame properly, to plug in instance variables before
+ *  executing the code body.
+ */
+typedef struct ItclContext {
+    ItclClass *classDefn;     /* class definition */
+    Itcl_CallFrame frame;      /* call frame for object context */
+    Var *compiledLocals;      /* points to storage for compiled locals */
+    Var localStorage[20];     /* default storage for compiled locals */
+} ItclContext;
+
+/*
+ *  Compatibility flags.  Used to support small "hacks".  These are stored
+ *  in the global variable named itclCompatFlags.
+ */
+
+extern int itclCompatFlags;
+
+#define ITCL_COMPAT_USE_ISTATE_API 0x2  /* Tcl 8.5a2 added interp state APIs */
+
+#include "itclIntDecls.h"
+
+/*
+ * Since the Tcl/Tk distribution doesn't perform any asserts,
+ * dynamic loading can fail to find the __assert function.
+ * As a workaround, we'll include our own.
+ */
+
+#undef  assert
+#ifndef  DEBUG
+#define assert(EX) ((void)0)
+#else
+#define assert(EX) (void)((EX) || (Itcl_Assert(STRINGIFY(EX), __FILE__, __LINE__), 0))
+#endif  /* DEBUG */
+
+#undef TCL_STORAGE_CLASS
+#define TCL_STORAGE_CLASS DLLIMPORT
+
+#endif /* ITCLINT_H */
diff -Naur itk/generic/itk_cmds.c ITK_BLD/generic/itk_cmds.c
--- itk/generic/itk_cmds.c	2024-07-10 10:44:13.330651607 -0400
+++ ITK_BLD/generic/itk_cmds.c	2024-07-10 10:32:07.734264686 -0400
@@ -111,8 +111,7 @@
  * ------------------------------------------------------------------------
  */
 static int
-Initialize(interp)
-    Tcl_Interp *interp;  /* interpreter to be updated */
+Initialize(Tcl_Interp *interp)
 {
     Tcl_Namespace *itkNs, *parserNs;
     ClientData parserInfo;
@@ -256,8 +255,7 @@
  * ------------------------------------------------------------------------
  */
 int
-Itk_Init(interp)
-    Tcl_Interp *interp;  /* interpreter to be updated */
+Itk_Init(Tcl_Interp *interp)
 {
     if (Initialize(interp) != TCL_OK) {
 	return TCL_ERROR;
@@ -282,8 +280,7 @@
  * ------------------------------------------------------------------------
  */  
 int 
-Itk_SafeInit(interp)
-    Tcl_Interp *interp;  /* interpreter to be updated */ 
+Itk_SafeInit(Tcl_Interp *interp)
 {   
     if (Initialize(interp) != TCL_OK) {
         return TCL_ERROR;
@@ -316,11 +313,7 @@
  */
 /* ARGSUSED */
 int
-Itk_ConfigBodyCmd(dummy, interp, objc, objv)
-    ClientData dummy;        /* unused */
-    Tcl_Interp *interp;      /* current interpreter */
-    int objc;                /* number of arguments */
-    Tcl_Obj *CONST objv[];   /* argument objects */
+Itk_ConfigBodyCmd(ClientData dummy, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
     int result = TCL_OK;
 
diff -Naur itk/win/rc/itk.rc ITK_BLD/win/rc/itk.rc
--- itk/win/rc/itk.rc	2024-07-10 10:44:13.334651538 -0400
+++ ITK_BLD/win/rc/itk.rc	2024-07-10 10:32:07.734264686 -0400
@@ -1,59 +1,59 @@
-//
-// Version resource script.
-//
-
-#include <winver.h>
-#include <itcl.h>
-#include <itk.h>
-
-//
-// build-up the name suffix that defines the type of build this is.
-//
-#if DEBUG
-#define SUFFIX_DEBUG	    "g"
-#else
-#define SUFFIX_DEBUG	    ""
-#endif
-
-#define SUFFIX		    SUFFIX_DEBUG
-
-
-VS_VERSION_INFO VERSIONINFO
- FILEVERSION    ITK_MAJOR_VERSION,ITK_MINOR_VERSION,ITK_RELEASE_LEVEL,ITK_RELEASE_SERIAL
- PRODUCTVERSION ITK_MAJOR_VERSION,ITK_MINOR_VERSION,ITK_RELEASE_LEVEL,ITK_RELEASE_SERIAL
- FILEFLAGSMASK	0x3fL
-#if DEBUG
- FILEFLAGS	VS_FF_DEBUG
-#else
- FILEFLAGS	0x0L
-#endif
- FILEOS		VOS__WINDOWS32
- FILETYPE	VFT_DLL
- FILESUBTYPE	0x0L
-
-BEGIN
-    BLOCK "StringFileInfo"
-    BEGIN
-        BLOCK "040904b0"
-        BEGIN
-            VALUE "FileDescription", "[Incr Tk] Object-Oriented Tk extension\0"
-            VALUE "Authors", "Michael McLennan\0"
-            VALUE "OriginalFilename", "itk" STRINGIFY(ITK_MAJOR_VERSION) STRINGIFY(ITK_MINOR_VERSION) SUFFIX ".dll\0"
-            VALUE "CompanyName", "Bell Labs Innovations for Lucent Technologies\0"
-            VALUE "FileVersion", ITK_PATCH_LEVEL
-            VALUE "LegalCopyright", "Copyright \251 1993-2003\0"
-            VALUE "ProductName", "[Incr Tk] " ITK_VERSION " for Windows\0"
-            VALUE "ProductVersion", ITK_PATCH_LEVEL
-        END
-    END
-    BLOCK "VarFileInfo"
-    BEGIN
-        VALUE "Translation", 0x409, 1200
-    END
-END
-
-//
-// Icons
-//
-
-toaster		ICON	DISCARDABLE	"itk.ico"
+//
+// Version resource script.
+//
+
+#include <winver.h>
+#include <itcl.h>
+#include <itk.h>
+
+//
+// build-up the name suffix that defines the type of build this is.
+//
+#if DEBUG
+#define SUFFIX_DEBUG	    "g"
+#else
+#define SUFFIX_DEBUG	    ""
+#endif
+
+#define SUFFIX		    SUFFIX_DEBUG
+
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION    ITK_MAJOR_VERSION,ITK_MINOR_VERSION,ITK_RELEASE_LEVEL,ITK_RELEASE_SERIAL
+ PRODUCTVERSION ITK_MAJOR_VERSION,ITK_MINOR_VERSION,ITK_RELEASE_LEVEL,ITK_RELEASE_SERIAL
+ FILEFLAGSMASK	0x3fL
+#if DEBUG
+ FILEFLAGS	VS_FF_DEBUG
+#else
+ FILEFLAGS	0x0L
+#endif
+ FILEOS		VOS__WINDOWS32
+ FILETYPE	VFT_DLL
+ FILESUBTYPE	0x0L
+
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040904b0"
+        BEGIN
+            VALUE "FileDescription", "[Incr Tk] Object-Oriented Tk extension\0"
+            VALUE "Authors", "Michael McLennan\0"
+            VALUE "OriginalFilename", "itk" STRINGIFY(ITK_MAJOR_VERSION) STRINGIFY(ITK_MINOR_VERSION) SUFFIX ".dll\0"
+            VALUE "CompanyName", "Bell Labs Innovations for Lucent Technologies\0"
+            VALUE "FileVersion", ITK_PATCH_LEVEL
+            VALUE "LegalCopyright", "Copyright \251 1993-2003\0"
+            VALUE "ProductName", "[Incr Tk] " ITK_VERSION " for Windows\0"
+            VALUE "ProductVersion", ITK_PATCH_LEVEL
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x409, 1200
+    END
+END
+
+//
+// Icons
+//
+
+toaster		ICON	DISCARDABLE	"itk.ico"
