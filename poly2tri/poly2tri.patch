diff -Naur poly2tri.orig/CMakeLists.txt POLY2TRI_BLD/CMakeLists.txt
--- poly2tri.orig/CMakeLists.txt	2023-09-17 14:48:01.014182570 -0400
+++ POLY2TRI_BLD/CMakeLists.txt	2023-09-17 14:48:33.341620451 -0400
@@ -1,28 +1,136 @@
-cmake_minimum_required(VERSION 3.12)
-
-project(poly2tri LANGUAGES CXX)
-set(CMAKE_CXX_STANDARD 14)
-
-option(P2T_BUILD_TESTS "Build tests" OFF)
-option(P2T_BUILD_TESTBED "Build the testbed application" OFF)
-
-file(GLOB SOURCES poly2tri/common/*.cc poly2tri/sweep/*.cc)
-file(GLOB HEADERS poly2tri/*.h poly2tri/common/*.h poly2tri/sweep/*.h)
-add_library(poly2tri ${SOURCES} ${HEADERS})
-target_include_directories(poly2tri INTERFACE ${CMAKE_CURRENT_SOURCE_DIR})
-
-get_target_property(poly2tri_target_type poly2tri TYPE)
-if(poly2tri_target_type STREQUAL SHARED_LIBRARY)
-  target_compile_definitions(poly2tri PRIVATE P2T_SHARED_EXPORTS)
-else()
-  target_compile_definitions(poly2tri PUBLIC P2T_STATIC_EXPORTS)
-endif()
-
-if(P2T_BUILD_TESTS)
-    enable_testing()
-    add_subdirectory(unittest)
-endif()
-
-if(P2T_BUILD_TESTBED)
-    add_subdirectory(testbed)
-endif()
+#                     C M A K E L I S T S . T X T
+# BRL-CAD
+#
+# Copyright (c) 2020 United States Government as represented by
+# the U.S. Army Research Laboratory.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above
+# copyright notice, this list of conditions and the following
+# disclaimer in the documentation and/or other materials provided
+# with the distribution.
+#
+# 3. The name of the author may not be used to endorse or promote
+# products derived from this software without specific prior written
+# permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Build file for poly2tri (above license applies to only this file -
+# poly2tri is convered by its own license.)
+###
+
+# Minimum required version of CMake
+cmake_minimum_required(VERSION 3.18)
+
+# Set CMake project name
+project(P2T)
+
+# Testing option
+option(P2T_TESTS "Build libp2t tests" OFF)
+mark_as_advanced(P2T_TESTS)
+if (P2T_TESTS)
+  include(CTest)
+  enable_testing()
+endif (P2T_TESTS)
+
+include_directories(
+  ${CMAKE_CURRENT_SOURCE_DIR}
+  )
+
+if (NOT DEFINED BIN_DIR)
+  set (BIN_DIR bin)
+endif (NOT DEFINED BIN_DIR)
+
+if (NOT DEFINED LIB_DIR)
+  set (LIB_DIR lib)
+endif (NOT DEFINED LIB_DIR)
+
+if (NOT DEFINED INCLUDE_DIR)
+  set (INCLUDE_DIR include)
+endif (NOT DEFINED INCLUDE_DIR)
+
+if (NOT DEFINED BUILD_SHARED_LIBS)
+  set(BUILD_SHARED_LIBS ON)
+endif (NOT DEFINED BUILD_SHARED_LIBS)
+
+if (NOT DEFINED BUILD_STATIC_LIBS)
+  set(BUILD_STATIC_LIBS OFF)
+endif (NOT DEFINED BUILD_STATIC_LIBS)
+
+include(CheckLibraryExists)
+check_library_exists(m cos "" HAVE_M_LIBRARY)
+if (HAVE_M_LIBRARY)
+  set(M_LIBRARY m)
+endif (HAVE_M_LIBRARY)
+
+set(SWEEP_HDRS
+  poly2tri/sweep/cdt.h
+  poly2tri/sweep/advancing_front.h
+  poly2tri/sweep/sweep.h
+  poly2tri/sweep/sweep_context.h
+  )
+install(FILES ${SWEEP_HDRS} DESTINATION ${INCLUDE_DIR}/poly2tri/sweep)
+install(FILES poly2tri/poly2tri.h DESTINATION ${INCLUDE_DIR}/poly2tri)
+install(FILES poly2tri/common/shapes.h DESTINATION ${INCLUDE_DIR}/poly2tri/common)
+install(FILES poly2tri/common/dll_symbol.h DESTINATION ${INCLUDE_DIR}/poly2tri/common)
+
+set(SOURCES
+  poly2tri/common/shapes.cc
+  poly2tri/sweep/advancing_front.cc
+  poly2tri/sweep/cdt.cc
+  poly2tri/sweep/sweep_context.cc
+  poly2tri/sweep/sweep.cc
+  )
+
+add_definitions("-DP2T_NO_GLFW")
+
+if (BUILD_SHARED_LIBS)
+  add_library(poly2tri ${SOURCES})
+  target_link_libraries(poly2tri ${M_LIBRARY})
+  if (MSVC)
+    set_target_properties(poly2tri PROPERTIES DEFINE_SYMBOL P2T_BUILD_DLL)
+    set_property(TARGET poly2tri APPEND PROPERTY COMPILE_DEFINITIONS "P2T_DLL_EXPORTS")
+  endif (MSVC)
+  install(TARGETS poly2tri
+    RUNTIME DESTINATION ${BIN_DIR}
+    LIBRARY DESTINATION ${LIB_DIR}
+    ARCHIVE DESTINATION ${LIB_DIR})
+endif (BUILD_SHARED_LIBS)
+
+if (BUILD_STATIC_LIBS)
+  add_library(poly2tri-static STATIC ${SOURCES})
+  if (MSVC)
+    # msvc does not append 'lib' - do it here to have consistent name
+    set_target_properties(poly2tri-static PROPERTIES PREFIX "lib")
+  else(MSVC)
+    set_target_properties(poly2tri-static PROPERTIES OUTPUT_NAME poly2tri)
+  endif (MSVC)
+  install(TARGETS poly2tri-static
+    RUNTIME DESTINATION ${BIN_DIR}
+    LIBRARY DESTINATION ${LIB_DIR}
+    ARCHIVE DESTINATION ${LIB_DIR})
+endif (BUILD_STATIC_LIBS)
+
+# Local Variables:
+# tab-width: 8
+# mode: cmake
+# indent-tabs-mode: t
+# End:
+# ex: shiftwidth=2 tabstop=8
diff -Naur poly2tri.orig/poly2tri/common/dll_symbol.h POLY2TRI_BLD/poly2tri/common/dll_symbol.h
--- poly2tri.orig/poly2tri/common/dll_symbol.h	2023-09-17 14:48:01.014182570 -0400
+++ POLY2TRI_BLD/poly2tri/common/dll_symbol.h	2023-09-17 14:48:33.341620451 -0400
@@ -32,22 +32,21 @@
 #pragma once
 
 #if defined(_WIN32)
-#  define P2T_COMPILER_DLLEXPORT __declspec(dllexport)
-#  define P2T_COMPILER_DLLIMPORT __declspec(dllimport)
-#elif defined(__GNUC__)
-#  define P2T_COMPILER_DLLEXPORT __attribute__ ((visibility ("default")))
-#  define P2T_COMPILER_DLLIMPORT __attribute__ ((visibility ("default")))
+# define COMPILER_DLLEXPORT __declspec(dllexport)
+# define COMPILER_DLLIMPORT __declspec(dllimport)
 #else
-#  define P2T_COMPILER_DLLEXPORT
-#  define P2T_COMPILER_DLLIMPORT
+# define COMPILER_DLLEXPORT __attribute__ ((visibility ("default")))
+# define COMPILER_DLLIMPORT __attribute__ ((visibility ("default")))
 #endif
 
-#ifndef P2T_DLL_SYMBOL
-#  if defined(P2T_STATIC_EXPORTS)
-#    define P2T_DLL_SYMBOL
-#  elif defined(P2T_SHARED_EXPORTS)
-#    define P2T_DLL_SYMBOL P2T_COMPILER_DLLEXPORT
+#ifndef P2T_EXPORT
+#  if defined(P2T_DLL_EXPORTS) && defined(P2T_DLL_IMPORTS)
+#    error "Only P2T_DLL_EXPORTS or P2T_DLL_IMPORTS can be defined, not both."
+#  elif defined(P2T_DLL_EXPORTS)
+#    define P2T_EXPORT COMPILER_DLLEXPORT
+#  elif defined(P2T_DLL_IMPORTS)
+#    define P2T_EXPORT COMPILER_DLLIMPORT
 #  else
-#    define P2T_DLL_SYMBOL P2T_COMPILER_DLLIMPORT
+#    define P2T_EXPORT
 #  endif
 #endif
diff -Naur poly2tri.orig/poly2tri/common/shapes.cc POLY2TRI_BLD/poly2tri/common/shapes.cc
--- poly2tri.orig/poly2tri/common/shapes.cc	2023-09-17 14:48:01.014182570 -0400
+++ POLY2TRI_BLD/poly2tri/common/shapes.cc	2023-09-17 14:48:33.341620451 -0400
@@ -29,383 +29,347 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 #include "shapes.h"
-
-#include <cassert>
+#include <stdexcept>
 #include <iostream>
 
 namespace p2t {
 
-Point::Point(double x, double y) : x(x), y(y)
-{
-}
-
-std::ostream& operator<<(std::ostream& out, const Point& point) {
-  return out << point.x << "," << point.y;
-}
-
-Triangle::Triangle(Point& a, Point& b, Point& c)
-{
-  points_[0] = &a; points_[1] = &b; points_[2] = &c;
-  neighbors_[0] = nullptr; neighbors_[1] = nullptr; neighbors_[2] = nullptr;
-  constrained_edge[0] = constrained_edge[1] = constrained_edge[2] = false;
-  delaunay_edge[0] = delaunay_edge[1] = delaunay_edge[2] = false;
-  interior_ = false;
-}
-
-// Update neighbor pointers
-void Triangle::MarkNeighbor(Point* p1, Point* p2, Triangle* t)
-{
-  if ((p1 == points_[2] && p2 == points_[1]) || (p1 == points_[1] && p2 == points_[2]))
-    neighbors_[0] = t;
-  else if ((p1 == points_[0] && p2 == points_[2]) || (p1 == points_[2] && p2 == points_[0]))
-    neighbors_[1] = t;
-  else if ((p1 == points_[0] && p2 == points_[1]) || (p1 == points_[1] && p2 == points_[0]))
-    neighbors_[2] = t;
-  else
-    assert(0);
-}
-
-// Exhaustive search to update neighbor pointers
-void Triangle::MarkNeighbor(Triangle& t)
-{
-  if (t.Contains(points_[1], points_[2])) {
-    neighbors_[0] = &t;
-    t.MarkNeighbor(points_[1], points_[2], this);
-  } else if (t.Contains(points_[0], points_[2])) {
-    neighbors_[1] = &t;
-    t.MarkNeighbor(points_[0], points_[2], this);
-  } else if (t.Contains(points_[0], points_[1])) {
-    neighbors_[2] = &t;
-    t.MarkNeighbor(points_[0], points_[1], this);
-  }
-}
-
-/**
- * Clears all references to all other triangles and points
- */
-void Triangle::Clear()
-{
-    Triangle *t;
-    for (auto& neighbor : neighbors_) {
-      t = neighbor;
-      if (t != nullptr) {
-        t->ClearNeighbor(this);
-      }
+    Triangle::Triangle(Point& a, Point& b, Point& c)
+    {
+	points_[0] = &a; points_[1] = &b; points_[2] = &c;
+	neighbors_[0] = NULL; neighbors_[1] = NULL; neighbors_[2] = NULL;
+	constrained_edge[0] = constrained_edge[1] = constrained_edge[2] = false;
+	delaunay_edge[0] = delaunay_edge[1] = delaunay_edge[2] = false;
+	interior_ = false;
+	checked_ = false;
     }
-    ClearNeighbors();
-    points_[0]=points_[1]=points_[2] = nullptr;
-}
 
-void Triangle::ClearNeighbor(const Triangle *triangle )
-{
-    if( neighbors_[0] == triangle )
+    // Update neighbor pointers
+    void Triangle::MarkNeighbor(Point* p1, Point* p2, Triangle* t)
     {
-        neighbors_[0] = nullptr;
+	if ((p1 == points_[2] && p2 == points_[1]) || (p1 == points_[1] && p2 == points_[2]))
+	    neighbors_[0] = t;
+	else if ((p1 == points_[0] && p2 == points_[2]) || (p1 == points_[2] && p2 == points_[0]))
+	    neighbors_[1] = t;
+	else if ((p1 == points_[0] && p2 == points_[1]) || (p1 == points_[1] && p2 == points_[0]))
+	    neighbors_[2] = t;
+	else
+	    throw std::runtime_error("MarkNeighbor");
     }
-    else if( neighbors_[1] == triangle )
+
+    // Exhaustive search to update neighbor pointers
+    void Triangle::MarkNeighbor(Triangle& t)
     {
-        neighbors_[1] = nullptr;
+	if (t.Contains(points_[1], points_[2])) {
+	    neighbors_[0] = &t;
+	    t.MarkNeighbor(points_[1], points_[2], this);
+	} else if (t.Contains(points_[0], points_[2])) {
+	    neighbors_[1] = &t;
+	    t.MarkNeighbor(points_[0], points_[2], this);
+	} else if (t.Contains(points_[0], points_[1])) {
+	    neighbors_[2] = &t;
+	    t.MarkNeighbor(points_[0], points_[1], this);
+	}
     }
-    else
+
+    /**
+     * Clears all references to all other triangles and points
+     */
+    void Triangle::Clear()
     {
-        neighbors_[2] = nullptr;
+	Triangle *t;
+	for( int i=0; i<3; i++ )
+	{
+	    t = neighbors_[i];
+	    if( t != NULL )
+	    {
+		t->ClearNeighbor( this );
+	    }
+	}
+	ClearNeighbors();
+	points_[0]=points_[1]=points_[2] = NULL;
     }
-}
 
-void Triangle::ClearNeighbors()
-{
-  neighbors_[0] = nullptr;
-  neighbors_[1] = nullptr;
-  neighbors_[2] = nullptr;
-}
+    void Triangle::ClearNeighbor(Triangle *triangle )
+    {
+	if( neighbors_[0] == triangle )
+	{
+	    neighbors_[0] = NULL;
+	}
+	else if( neighbors_[1] == triangle )
+	{
+	    neighbors_[1] = NULL;
+	}
+	else
+	{
+	    neighbors_[2] = NULL;
+	}
+    }
 
-void Triangle::ClearDelunayEdges()
-{
-  delaunay_edge[0] = delaunay_edge[1] = delaunay_edge[2] = false;
-}
+    void Triangle::ClearNeighbors()
+    {
+	neighbors_[0] = NULL;
+	neighbors_[1] = NULL;
+	neighbors_[2] = NULL;
+    }
 
-Point* Triangle::OppositePoint(Triangle& t, const Point& p)
-{
-  Point *cw = t.PointCW(p);
-  return PointCW(*cw);
-}
+    void Triangle::ClearDelunayEdges()
+    {
+	delaunay_edge[0] = delaunay_edge[1] = delaunay_edge[2] = false;
+    }
 
-// Legalized triangle by rotating clockwise around point(0)
-void Triangle::Legalize(Point& point)
-{
-  points_[1] = points_[0];
-  points_[0] = points_[2];
-  points_[2] = &point;
-}
+    Point* Triangle::OppositePoint(Triangle& t, Point& p)
+    {
+	Point *cw = t.PointCW(p);
+	return PointCW(*cw);
+    }
 
-// Legalize triagnle by rotating clockwise around oPoint
-void Triangle::Legalize(Point& opoint, Point& npoint)
-{
-  if (&opoint == points_[0]) {
-    points_[1] = points_[0];
-    points_[0] = points_[2];
-    points_[2] = &npoint;
-  } else if (&opoint == points_[1]) {
-    points_[2] = points_[1];
-    points_[1] = points_[0];
-    points_[0] = &npoint;
-  } else if (&opoint == points_[2]) {
-    points_[0] = points_[2];
-    points_[2] = points_[1];
-    points_[1] = &npoint;
-  } else {
-    assert(0);
-  }
-}
+    // Legalized triangle by rotating clockwise around point(0)
+    void Triangle::Legalize(Point& point)
+    {
+	points_[1] = points_[0];
+	points_[0] = points_[2];
+	points_[2] = &point;
+    }
 
-int Triangle::Index(const Point* p)
-{
-  if (p == points_[0]) {
-    return 0;
-  } else if (p == points_[1]) {
-    return 1;
-  } else if (p == points_[2]) {
-    return 2;
-  }
-  assert(0);
-  return -1;
-}
+    // Legalize triagnle by rotating clockwise around oPoint
+    void Triangle::Legalize(Point& opoint, Point& npoint)
+    {
+	if (&opoint == points_[0]) {
+	    points_[1] = points_[0];
+	    points_[0] = points_[2];
+	    points_[2] = &npoint;
+	} else if (&opoint == points_[1]) {
+	    points_[2] = points_[1];
+	    points_[1] = points_[0];
+	    points_[0] = &npoint;
+	} else if (&opoint == points_[2]) {
+	    points_[0] = points_[2];
+	    points_[2] = points_[1];
+	    points_[1] = &npoint;
+	} else {
+	    throw std::runtime_error("Legalize");
+	}
+    }
 
-int Triangle::EdgeIndex(const Point* p1, const Point* p2)
-{
-  if (points_[0] == p1) {
-    if (points_[1] == p2) {
-      return 2;
-    } else if (points_[2] == p2) {
-      return 1;
-    }
-  } else if (points_[1] == p1) {
-    if (points_[2] == p2) {
-      return 0;
-    } else if (points_[0] == p2) {
-      return 2;
-    }
-  } else if (points_[2] == p1) {
-    if (points_[0] == p2) {
-      return 1;
-    } else if (points_[1] == p2) {
-      return 0;
+    int Triangle::Index(const Point* p)
+    {
+	if (p == points_[0]) {
+	    return 0;
+	} else if (p == points_[1]) {
+	    return 1;
+	} else if (p == points_[2]) {
+	    return 2;
+	}
+	throw std::runtime_error("Index");
     }
-  }
-  return -1;
-}
 
-void Triangle::MarkConstrainedEdge(int index)
-{
-  constrained_edge[index] = true;
-}
+    int Triangle::EdgeIndex(const Point* p1, const Point* p2)
+    {
+	if (points_[0] == p1) {
+	    if (points_[1] == p2) {
+		return 2;
+	    } else if (points_[2] == p2) {
+		return 1;
+	    }
+	} else if (points_[1] == p1) {
+	    if (points_[2] == p2) {
+		return 0;
+	    } else if (points_[0] == p2) {
+		return 2;
+	    }
+	} else if (points_[2] == p1) {
+	    if (points_[0] == p2) {
+		return 1;
+	    } else if (points_[1] == p2) {
+		return 0;
+	    }
+	}
+	return -1;
+    }
 
-void Triangle::MarkConstrainedEdge(Edge& edge)
-{
-  MarkConstrainedEdge(edge.p, edge.q);
-}
+    void Triangle::MarkConstrainedEdge(const int index)
+    {
+	constrained_edge[index] = true;
+    }
 
-// Mark edge as constrained
-void Triangle::MarkConstrainedEdge(Point* p, Point* q)
-{
-  if ((q == points_[0] && p == points_[1]) || (q == points_[1] && p == points_[0])) {
-    constrained_edge[2] = true;
-  } else if ((q == points_[0] && p == points_[2]) || (q == points_[2] && p == points_[0])) {
-    constrained_edge[1] = true;
-  } else if ((q == points_[1] && p == points_[2]) || (q == points_[2] && p == points_[1])) {
-    constrained_edge[0] = true;
-  }
-}
+    void Triangle::MarkConstrainedEdge(Edge& edge)
+    {
+	MarkConstrainedEdge(edge.p, edge.q);
+    }
 
-// The point counter-clockwise to given point
-Point* Triangle::PointCW(const Point& point)
-{
-  if (&point == points_[0]) {
-    return points_[2];
-  } else if (&point == points_[1]) {
-    return points_[0];
-  } else if (&point == points_[2]) {
-    return points_[1];
-  }
-  assert(0);
-  return nullptr;
-}
+    // Mark edge as constrained
+    void Triangle::MarkConstrainedEdge(Point* p, Point* q)
+    {
+	if ((q == points_[0] && p == points_[1]) || (q == points_[1] && p == points_[0])) {
+	    constrained_edge[2] = true;
+	} else if ((q == points_[0] && p == points_[2]) || (q == points_[2] && p == points_[0])) {
+	    constrained_edge[1] = true;
+	} else if ((q == points_[1] && p == points_[2]) || (q == points_[2] && p == points_[1])) {
+	    constrained_edge[0] = true;
+	}
+    }
 
-// The point counter-clockwise to given point
-Point* Triangle::PointCCW(const Point& point)
-{
-  if (&point == points_[0]) {
-    return points_[1];
-  } else if (&point == points_[1]) {
-    return points_[2];
-  } else if (&point == points_[2]) {
-    return points_[0];
-  }
-  assert(0);
-  return nullptr;
-}
+    // The point counter-clockwise to given point
+    Point* Triangle::PointCW(Point& point)
+    {
+	if (&point == points_[0]) {
+	    return points_[2];
+	} else if (&point == points_[1]) {
+	    return points_[0];
+	} else if (&point == points_[2]) {
+	    return points_[1];
+	}
+        throw std::runtime_error("PointCW");
+    }
 
-// The neighbor across to given point
-Triangle* Triangle::NeighborAcross(const Point& point)
-{
-  if (&point == points_[0]) {
-    return neighbors_[0];
-  } else if (&point == points_[1]) {
-    return neighbors_[1];
-  }
-  return neighbors_[2];
-}
+    // The point counter-clockwise to given point
+    Point* Triangle::PointCCW(Point& point)
+    {
+	if (&point == points_[0]) {
+	    return points_[1];
+	} else if (&point == points_[1]) {
+	    return points_[2];
+	} else if (&point == points_[2]) {
+	    return points_[0];
+	}
+	throw std::runtime_error("PointCCW");
+    }
 
-// The neighbor clockwise to given point
-Triangle* Triangle::NeighborCW(const Point& point)
-{
-  if (&point == points_[0]) {
-    return neighbors_[1];
-  } else if (&point == points_[1]) {
-    return neighbors_[2];
-  }
-  return neighbors_[0];
-}
+    // The neighbor clockwise to given point
+    Triangle* Triangle::NeighborCW(Point& point)
+    {
+	if (&point == points_[0]) {
+	    return neighbors_[1];
+	} else if (&point == points_[1]) {
+	    return neighbors_[2];
+	}
+	return neighbors_[0];
+    }
 
-// The neighbor counter-clockwise to given point
-Triangle* Triangle::NeighborCCW(const Point& point)
-{
-  if (&point == points_[0]) {
-    return neighbors_[2];
-  } else if (&point == points_[1]) {
-    return neighbors_[0];
-  }
-  return neighbors_[1];
-}
+    // The neighbor across to given point
+    Triangle* Triangle::NeighborAcross(Point& opoint)
+    {
+	if (&opoint == points_[0]) {
+	    return neighbors_[0];
+	} else if (&opoint == points_[1]) {
+	    return neighbors_[1];
+	}
+	return neighbors_[2];
+    }
 
-bool Triangle::GetConstrainedEdgeCCW(const Point& p)
-{
-  if (&p == points_[0]) {
-    return constrained_edge[2];
-  } else if (&p == points_[1]) {
-    return constrained_edge[0];
-  }
-  return constrained_edge[1];
-}
+    // The neighbor counter-clockwise to given point
+    Triangle* Triangle::NeighborCCW(Point& point)
+    {
+	if (&point == points_[0]) {
+	    return neighbors_[2];
+	} else if (&point == points_[1]) {
+	    return neighbors_[0];
+	}
+	return neighbors_[1];
+    }
 
-bool Triangle::GetConstrainedEdgeCW(const Point& p)
-{
-  if (&p == points_[0]) {
-    return constrained_edge[1];
-  } else if (&p == points_[1]) {
-    return constrained_edge[2];
-  }
-  return constrained_edge[0];
-}
+    bool Triangle::GetConstrainedEdgeCCW(Point& p)
+    {
+	if (&p == points_[0]) {
+	    return constrained_edge[2];
+	} else if (&p == points_[1]) {
+	    return constrained_edge[0];
+	}
+	return constrained_edge[1];
+    }
 
-void Triangle::SetConstrainedEdgeCCW(const Point& p, bool ce)
-{
-  if (&p == points_[0]) {
-    constrained_edge[2] = ce;
-  } else if (&p == points_[1]) {
-    constrained_edge[0] = ce;
-  } else {
-    constrained_edge[1] = ce;
-  }
-}
+    bool Triangle::GetConstrainedEdgeCW(Point& p)
+    {
+	if (&p == points_[0]) {
+	    return constrained_edge[1];
+	} else if (&p == points_[1]) {
+	    return constrained_edge[2];
+	}
+	return constrained_edge[0];
+    }
 
-void Triangle::SetConstrainedEdgeCW(const Point& p, bool ce)
-{
-  if (&p == points_[0]) {
-    constrained_edge[1] = ce;
-  } else if (&p == points_[1]) {
-    constrained_edge[2] = ce;
-  } else {
-    constrained_edge[0] = ce;
-  }
-}
+    void Triangle::SetConstrainedEdgeCCW(Point& p, bool ce)
+    {
+	if (&p == points_[0]) {
+	    constrained_edge[2] = ce;
+	} else if (&p == points_[1]) {
+	    constrained_edge[0] = ce;
+	} else {
+	    constrained_edge[1] = ce;
+	}
+    }
 
-bool Triangle::GetDelunayEdgeCCW(const Point& p)
-{
-  if (&p == points_[0]) {
-    return delaunay_edge[2];
-  } else if (&p == points_[1]) {
-    return delaunay_edge[0];
-  }
-  return delaunay_edge[1];
-}
+    void Triangle::SetConstrainedEdgeCW(Point& p, bool ce)
+    {
+	if (&p == points_[0]) {
+	    constrained_edge[1] = ce;
+	} else if (&p == points_[1]) {
+	    constrained_edge[2] = ce;
+	} else {
+	    constrained_edge[0] = ce;
+	}
+    }
 
-bool Triangle::GetDelunayEdgeCW(const Point& p)
-{
-  if (&p == points_[0]) {
-    return delaunay_edge[1];
-  } else if (&p == points_[1]) {
-    return delaunay_edge[2];
-  }
-  return delaunay_edge[0];
-}
+    bool Triangle::GetDelunayEdgeCCW(Point& p)
+    {
+	if (&p == points_[0]) {
+	    return delaunay_edge[2];
+	} else if (&p == points_[1]) {
+	    return delaunay_edge[0];
+	}
+	return delaunay_edge[1];
+    }
 
-void Triangle::SetDelunayEdgeCCW(const Point& p, bool e)
-{
-  if (&p == points_[0]) {
-    delaunay_edge[2] = e;
-  } else if (&p == points_[1]) {
-    delaunay_edge[0] = e;
-  } else {
-    delaunay_edge[1] = e;
-  }
-}
+    bool Triangle::GetDelunayEdgeCW(Point& p)
+    {
+	if (&p == points_[0]) {
+	    return delaunay_edge[1];
+	} else if (&p == points_[1]) {
+	    return delaunay_edge[2];
+	}
+	return delaunay_edge[0];
+    }
 
-void Triangle::SetDelunayEdgeCW(const Point& p, bool e)
-{
-  if (&p == points_[0]) {
-    delaunay_edge[1] = e;
-  } else if (&p == points_[1]) {
-    delaunay_edge[2] = e;
-  } else {
-    delaunay_edge[0] = e;
-  }
-}
+    void Triangle::SetDelunayEdgeCCW(Point& p, bool e)
+    {
+	if (&p == points_[0]) {
+	    delaunay_edge[2] = e;
+	} else if (&p == points_[1]) {
+	    delaunay_edge[0] = e;
+	} else {
+	    delaunay_edge[1] = e;
+	}
+    }
 
-void Triangle::DebugPrint()
-{
-  std::cout << *points_[0] << " " << *points_[1] << " " << *points_[2] << std::endl;
-}
+    void Triangle::SetDelunayEdgeCW(Point& p, bool e)
+    {
+	if (&p == points_[0]) {
+	    delaunay_edge[1] = e;
+	} else if (&p == points_[1]) {
+	    delaunay_edge[2] = e;
+	} else {
+	    delaunay_edge[0] = e;
+	}
+    }
 
-bool Triangle::CircumcicleContains(const Point& point) const
-{
-  assert(IsCounterClockwise());
-  const double dx = points_[0]->x - point.x;
-  const double dy = points_[0]->y - point.y;
-  const double ex = points_[1]->x - point.x;
-  const double ey = points_[1]->y - point.y;
-  const double fx = points_[2]->x - point.x;
-  const double fy = points_[2]->y - point.y;
-
-  const double ap = dx * dx + dy * dy;
-  const double bp = ex * ex + ey * ey;
-  const double cp = fx * fx + fy * fy;
+    void Triangle::DebugPrint()
+    {
+	using namespace std;
+	cout << points_[0]->x << "," << points_[0]->y << " ";
+	cout << points_[1]->x << "," << points_[1]->y << " ";
+	cout << points_[2]->x << "," << points_[2]->y << endl;
+    }
 
-  return (dx * (fy * bp - cp * ey) - dy * (fx * bp - cp * ex) + ap * (fx * ey - fy * ex)) < 0;
 }
 
-bool Triangle::IsCounterClockwise() const
-{
-  return (points_[1]->x - points_[0]->x) * (points_[2]->y - points_[0]->y) -
-             (points_[2]->x - points_[0]->x) * (points_[1]->y - points_[0]->y) >
-         0;
-}
 
-bool IsDelaunay(const std::vector<p2t::Triangle*>& triangles)
-{
-  for (const auto triangle : triangles) {
-    for (const auto other : triangles) {
-      if (triangle == other) {
-        continue;
-      }
-      for (int i = 0; i < 3; ++i) {
-        if (triangle->CircumcicleContains(*other->GetPoint(i))) {
-          return false;
-        }
-      }
-    }
-  }
-  return true;
-}
+// Local Variables:
+// tab-width: 8
+// mode: C++
+// c-basic-offset: 4
+// indent-tabs-mode: t
+// c-file-style: "stroustrup"
+// End:
+// ex: shiftwidth=4 tabstop=8
 
-} // namespace p2t
diff -Naur poly2tri.orig/poly2tri/common/shapes.h POLY2TRI_BLD/poly2tri/common/shapes.h
--- poly2tri.orig/poly2tri/common/shapes.h	2023-09-17 14:48:01.014182570 -0400
+++ POLY2TRI_BLD/poly2tri/common/shapes.h	2023-09-17 14:48:33.341620451 -0400
@@ -29,301 +29,327 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#pragma once
+// Include guard
+#ifndef SHAPES_H
+#define SHAPES_H
 
-#include "dll_symbol.h"
+#include "../common/dll_symbol.h"
 
-#include <cmath>
+#include <vector>
 #include <cstddef>
 #include <stdexcept>
-#include <vector>
+#include <cfloat>
+#include <cmath>
+
+/* Avoid exact floating point comparison warnings, but this macro
+ * is used in some places where *very* tight equality is needed - 
+ * use DBL_MIN */
+#define EQ(v1, v2) ((v1 - v2 > -DBL_MIN) && (v1 - v2 < DBL_MIN))
 
 namespace p2t {
 
-struct Edge;
+    struct Edge;
 
-struct P2T_DLL_SYMBOL Point {
+    struct Point {
 
-  double x, y;
+	double x, y;
 
-  /// Default constructor does nothing (for performance).
-  Point()
-  {
-    x = 0.0;
-    y = 0.0;
-  }
-
-  /// The edges this point constitutes an upper ending point
-  std::vector<Edge*> edge_list;
-
-  /// Construct using coordinates.
-  Point(double x, double y);
-
-  /// Set this point to all zeros.
-  void set_zero()
-  {
-    x = 0.0;
-    y = 0.0;
-  }
-
-  /// Set this point to some specified coordinates.
-  void set(double x_, double y_)
-  {
-    x = x_;
-    y = y_;
-  }
-
-  /// Negate this point.
-  Point operator -() const
-  {
-    Point v;
-    v.set(-x, -y);
-    return v;
-  }
-
-  /// Add a point to this point.
-  void operator +=(const Point& v)
-  {
-    x += v.x;
-    y += v.y;
-  }
-
-  /// Subtract a point from this point.
-  void operator -=(const Point& v)
-  {
-    x -= v.x;
-    y -= v.y;
-  }
-
-  /// Multiply this point by a scalar.
-  void operator *=(double a)
-  {
-    x *= a;
-    y *= a;
-  }
-
-  /// Get the length of this point (the norm).
-  double Length() const
-  {
-    return sqrt(x * x + y * y);
-  }
-
-  /// Convert this point into a unit point. Returns the Length.
-  double Normalize()
-  {
-    const double len = Length();
-    x /= len;
-    y /= len;
-    return len;
-  }
-
-};
-
-P2T_DLL_SYMBOL std::ostream& operator<<(std::ostream&, const Point&);
-
-// Represents a simple polygon's edge
-struct P2T_DLL_SYMBOL Edge {
-
-  Point* p, *q;
-
-  /// Constructor
-  Edge(Point& p1, Point& p2) : p(&p1), q(&p2)
-  {
-    if (p1.y > p2.y) {
-      q = &p1;
-      p = &p2;
-    } else if (p1.y == p2.y) {
-      if (p1.x > p2.x) {
-        q = &p1;
-        p = &p2;
-      } else if (p1.x == p2.x) {
-        // Repeat points
-        throw std::runtime_error("Edge::Edge: p1 == p2");
-      }
-    }
-
-    q->edge_list.push_back(this);
-  }
-};
-
-// Triangle-based data structures are know to have better performance than quad-edge structures
-// See: J. Shewchuk, "Triangle: Engineering a 2D Quality Mesh Generator and Delaunay Triangulator"
-//      "Triangulations in CGAL"
-class P2T_DLL_SYMBOL Triangle {
-public:
-
-/// Constructor
-Triangle(Point& a, Point& b, Point& c);
-
-/// Flags to determine if an edge is a Constrained edge
-bool constrained_edge[3];
-/// Flags to determine if an edge is a Delauney edge
-bool delaunay_edge[3];
-
-Point* GetPoint(int index);
-Point* PointCW(const Point& point);
-Point* PointCCW(const Point& point);
-Point* OppositePoint(Triangle& t, const Point& p);
-
-Triangle* GetNeighbor(int index);
-void MarkNeighbor(Point* p1, Point* p2, Triangle* t);
-void MarkNeighbor(Triangle& t);
-
-void MarkConstrainedEdge(int index);
-void MarkConstrainedEdge(Edge& edge);
-void MarkConstrainedEdge(Point* p, Point* q);
-
-int Index(const Point* p);
-int EdgeIndex(const Point* p1, const Point* p2);
-
-Triangle* NeighborAcross(const Point& point);
-Triangle* NeighborCW(const Point& point);
-Triangle* NeighborCCW(const Point& point);
-bool GetConstrainedEdgeCCW(const Point& p);
-bool GetConstrainedEdgeCW(const Point& p);
-void SetConstrainedEdgeCCW(const Point& p, bool ce);
-void SetConstrainedEdgeCW(const Point& p, bool ce);
-bool GetDelunayEdgeCCW(const Point& p);
-bool GetDelunayEdgeCW(const Point& p);
-void SetDelunayEdgeCCW(const Point& p, bool e);
-void SetDelunayEdgeCW(const Point& p, bool e);
-
-bool Contains(const Point* p);
-bool Contains(const Edge& e);
-bool Contains(const Point* p, const Point* q);
-void Legalize(Point& point);
-void Legalize(Point& opoint, Point& npoint);
-/**
- * Clears all references to all other triangles and points
- */
-void Clear();
-void ClearNeighbor(const Triangle *triangle);
-void ClearNeighbors();
-void ClearDelunayEdges();
-
-inline bool IsInterior();
-inline void IsInterior(bool b);
-
-void DebugPrint();
-
-bool CircumcicleContains(const Point&) const;
-
-private:
-
-bool IsCounterClockwise() const;
-
-/// Triangle points
-Point* points_[3];
-/// Neighbor list
-Triangle* neighbors_[3];
-
-/// Has this triangle been marked as an interior triangle?
-bool interior_;
-};
-
-inline bool cmp(const Point* a, const Point* b)
-{
-  if (a->y < b->y) {
-    return true;
-  } else if (a->y == b->y) {
-    // Make sure q is point with greater x value
-    if (a->x < b->x) {
-      return true;
+	/// Default constructor does nothing (for performance).
+	P2T_EXPORT Point()
+	{
+	    x = 0.0;
+	    y = 0.0;
+	}
+
+	/// The edges this point constitutes an upper ending point
+	std::vector<Edge*> edge_list;
+
+	/// Construct using coordinates.
+	P2T_EXPORT Point(double x_, double y_) : x(x_), y(y_) {}
+
+	/// Set this point to all zeros.
+	P2T_EXPORT void set_zero()
+	{
+	    x = 0.0;
+	    y = 0.0;
+	}
+
+	/// Set this point to some specified coordinates.
+	P2T_EXPORT void set(double x_, double y_)
+	{
+	    x = x_;
+	    y = y_;
+	}
+
+	/// Negate this point.
+	P2T_EXPORT Point operator -() const
+	{
+	    Point v;
+	    v.set(-x, -y);
+	    return v;
+	}
+
+	/// Add a point to this point.
+	P2T_EXPORT void operator +=(const Point& v)
+	{
+	    x += v.x;
+	    y += v.y;
+	}
+
+	/// Subtract a point from this point.
+	P2T_EXPORT void operator -=(const Point& v)
+	{
+	    x -= v.x;
+	    y -= v.y;
+	}
+
+	/// Multiply this point by a scalar.
+	P2T_EXPORT void operator *=(double a)
+	{
+	    x *= a;
+	    y *= a;
+	}
+
+	/// Get the length of this point (the norm).
+	P2T_EXPORT double Length() const
+	{
+	    return sqrt(x * x + y * y);
+	}
+
+	/// Convert this point into a unit point. Returns the Length.
+	P2T_EXPORT double Normalize()
+	{
+	    double len = Length();
+	    x /= len;
+	    y /= len;
+	    return len;
+	}
+
+    };
+
+    // Represents a simple polygon's edge
+    struct Edge {
+
+	Point* p, *q;
+
+	/// Constructor
+	P2T_EXPORT Edge(Point& p1, Point& p2) : p(&p1), q(&p2)
+	{
+	    if (p1.y > p2.y) {
+		q = &p1;
+		p = &p2;
+	    } else if (EQ(p1.y, p2.y)) {
+		if (p1.x > p2.x) {
+		    q = &p1;
+		    p = &p2;
+		} else if (EQ(p1.x, p2.x)) {
+		    // Repeat points
+		    throw std::runtime_error("Repeat points");
+		}
+	    }
+
+	    q->edge_list.push_back(this);
+	}
+    };
+
+    // Triangle-based data structures are know to have better performance than quad-edge structures
+    // See: J. Shewchuk, "Triangle: Engineering a 2D Quality Mesh Generator and Delaunay Triangulator"
+    //      "Triangulations in CGAL"
+    class Triangle {
+	public:
+
+	    /// Constructor
+	    P2T_EXPORT Triangle(Point& a, Point& b, Point& c);
+
+	    /// Flags to determine if an edge is a Constrained edge
+	    bool constrained_edge[3];
+	    /// Flags to determine if an edge is a Delauney edge
+	    bool delaunay_edge[3];
+
+	    P2T_EXPORT Point* GetPoint(const int& index);
+	    P2T_EXPORT Point* PointCW(Point& point);
+	    P2T_EXPORT Point* PointCCW(Point& point);
+	    P2T_EXPORT Point* OppositePoint(Triangle& t, Point& p);
+
+	    P2T_EXPORT Triangle* GetNeighbor(const int& index);
+	    P2T_EXPORT void MarkNeighbor(Point* p1, Point* p2, Triangle* t);
+	    P2T_EXPORT void MarkNeighbor(Triangle& t);
+
+	    P2T_EXPORT void MarkConstrainedEdge(const int index);
+	    P2T_EXPORT void MarkConstrainedEdge(Edge& edge);
+	    P2T_EXPORT void MarkConstrainedEdge(Point* p, Point* q);
+
+	    P2T_EXPORT int Index(const Point* p);
+	    P2T_EXPORT int EdgeIndex(const Point* p1, const Point* p2);
+
+	    P2T_EXPORT Triangle* NeighborCW(Point& point);
+	    P2T_EXPORT Triangle* NeighborCCW(Point& point);
+	    P2T_EXPORT Triangle* NeighborAcross(Point& opoint);
+	    P2T_EXPORT bool GetConstrainedEdgeCCW(Point& p);
+	    P2T_EXPORT bool GetConstrainedEdgeCW(Point& p);
+	    P2T_EXPORT void SetConstrainedEdgeCCW(Point& p, bool ce);
+	    P2T_EXPORT void SetConstrainedEdgeCW(Point& p, bool ce);
+	    P2T_EXPORT bool GetDelunayEdgeCCW(Point& p);
+	    P2T_EXPORT bool GetDelunayEdgeCW(Point& p);
+	    P2T_EXPORT void SetDelunayEdgeCCW(Point& p, bool e);
+	    P2T_EXPORT void SetDelunayEdgeCW(Point& p, bool e);
+
+	    P2T_EXPORT bool Contains(Point* p);
+	    P2T_EXPORT bool Contains(const Edge& e);
+	    P2T_EXPORT bool Contains(Point* p, Point* q);
+	    P2T_EXPORT void Legalize(Point& point);
+	    P2T_EXPORT void Legalize(Point& opoint, Point& npoint);
+	    /**
+	     * Clears all references to all other triangles and points
+	     */
+	    P2T_EXPORT void Clear();
+	    P2T_EXPORT void ClearNeighbor(Triangle *triangle );
+	    P2T_EXPORT void ClearNeighbors();
+	    P2T_EXPORT void ClearDelunayEdges();
+
+	    P2T_EXPORT inline bool IsInterior();
+	    P2T_EXPORT inline void IsInterior(bool b);
+
+	    P2T_EXPORT inline bool IsChecked();
+	    P2T_EXPORT inline void IsChecked(bool b);
+
+	    P2T_EXPORT void DebugPrint();
+
+	private:
+
+	    /// Triangle points
+	    Point* points_[3];
+	    /// Neighbor list
+	    Triangle* neighbors_[3];
+
+	    /// Has this triangle been marked as an interior triangle?
+	    bool interior_;
+	    /// Has this triangle been checked as an interior triangle?
+	    bool checked_;
+    };
+
+    inline bool cmp(const Point* a, const Point* b)
+    {
+	if (a->y < b->y) {
+	    return true;
+	} else if (EQ(a->y, b->y)) {
+	    // Make sure q is point with greater x value
+	    if (a->x < b->x) {
+		return true;
+	    }
+	}
+	return false;
     }
-  }
-  return false;
-}
 
-/// Add two points_ component-wise.
-inline Point operator +(const Point& a, const Point& b)
-{
-  return Point(a.x + b.x, a.y + b.y);
-}
+    /// Add two points_ component-wise.
+    inline Point operator +(const Point& a, const Point& b)
+    {
+	return Point(a.x + b.x, a.y + b.y);
+    }
 
-/// Subtract two points_ component-wise.
-inline Point operator -(const Point& a, const Point& b)
-{
-  return Point(a.x - b.x, a.y - b.y);
-}
+    /// Subtract two points_ component-wise.
+    inline Point operator -(const Point& a, const Point& b)
+    {
+	return Point(a.x - b.x, a.y - b.y);
+    }
 
-/// Multiply point by scalar
-inline Point operator *(double s, const Point& a)
-{
-  return Point(s * a.x, s * a.y);
-}
+    /// Multiply point by scalar
+    inline Point operator *(double s, const Point& a)
+    {
+	return Point(s * a.x, s * a.y);
+    }
 
-inline bool operator ==(const Point& a, const Point& b)
-{
-  return a.x == b.x && a.y == b.y;
-}
+    inline bool operator ==(const Point& a, const Point& b)
+    {
+	return EQ(a.x, b.x) && EQ(a.y, b.y);
+    }
 
-inline bool operator !=(const Point& a, const Point& b)
-{
-  return !(a.x == b.x) || !(a.y == b.y);
-}
+    inline bool operator !=(const Point& a, const Point& b)
+    {
+	return !(a == b);
+    }
 
-/// Peform the dot product on two vectors.
-inline double Dot(const Point& a, const Point& b)
-{
-  return a.x * b.x + a.y * b.y;
-}
+    /// Peform the dot product on two vectors.
+    inline double Dot(const Point& a, const Point& b)
+    {
+	return a.x * b.x + a.y * b.y;
+    }
 
-/// Perform the cross product on two vectors. In 2D this produces a scalar.
-inline double Cross(const Point& a, const Point& b)
-{
-  return a.x * b.y - a.y * b.x;
-}
+    /// Perform the cross product on two vectors. In 2D this produces a scalar.
+    inline double Cross(const Point& a, const Point& b)
+    {
+	return a.x * b.y - a.y * b.x;
+    }
 
-/// Perform the cross product on a point and a scalar. In 2D this produces
-/// a point.
-inline Point Cross(const Point& a, double s)
-{
-  return Point(s * a.y, -s * a.x);
-}
+    /// Perform the cross product on a point and a scalar. In 2D this produces
+    /// a point.
+    inline Point Cross(const Point& a, double s)
+    {
+	return Point(s * a.y, -s * a.x);
+    }
 
-/// Perform the cross product on a scalar and a point. In 2D this produces
-/// a point.
-inline Point Cross(double s, const Point& a)
-{
-  return Point(-s * a.y, s * a.x);
-}
+    /// Perform the cross product on a scalar and a point. In 2D this produces
+    /// a point.
+    inline Point Cross(const double s, const Point& a)
+    {
+	return Point(-s * a.y, s * a.x);
+    }
 
-inline Point* Triangle::GetPoint(int index)
-{
-  return points_[index];
-}
+    inline Point* Triangle::GetPoint(const int& index)
+    {
+	return points_[index];
+    }
 
-inline Triangle* Triangle::GetNeighbor(int index)
-{
-  return neighbors_[index];
-}
+    inline Triangle* Triangle::GetNeighbor(const int& index)
+    {
+	return neighbors_[index];
+    }
 
-inline bool Triangle::Contains(const Point* p)
-{
-  return p == points_[0] || p == points_[1] || p == points_[2];
-}
+    inline bool Triangle::Contains(Point* p)
+    {
+	return p == points_[0] || p == points_[1] || p == points_[2];
+    }
 
-inline bool Triangle::Contains(const Edge& e)
-{
-  return Contains(e.p) && Contains(e.q);
-}
+    inline bool Triangle::Contains(const Edge& e)
+    {
+	return Contains(e.p) && Contains(e.q);
+    }
 
-inline bool Triangle::Contains(const Point* p, const Point* q)
-{
-  return Contains(p) && Contains(q);
-}
+    inline bool Triangle::Contains(Point* p, Point* q)
+    {
+	return Contains(p) && Contains(q);
+    }
 
-inline bool Triangle::IsInterior()
-{
-  return interior_;
-}
+    inline bool Triangle::IsInterior()
+    {
+	return interior_;
+    }
 
-inline void Triangle::IsInterior(bool b)
-{
-  interior_ = b;
-}
+    inline void Triangle::IsInterior(bool b)
+    {
+	interior_ = b;
+    }
 
-/// Is this set a valid delaunay triangulation?
-P2T_DLL_SYMBOL bool IsDelaunay(const std::vector<p2t::Triangle*>&);
+    inline bool Triangle::IsChecked()
+    {
+	return checked_;
+    }
+
+    inline void Triangle::IsChecked(bool b)
+    {
+	checked_ = b;
+    }
 
 }
+
+#endif
+
+// Local Variables:
+// tab-width: 8
+// mode: C++
+// c-basic-offset: 4
+// indent-tabs-mode: t
+// c-file-style: "stroustrup"
+// End:
+// ex: shiftwidth=4 tabstop=8
+
diff -Naur poly2tri.orig/poly2tri/common/utils.h POLY2TRI_BLD/poly2tri/common/utils.h
--- poly2tri.orig/poly2tri/common/utils.h	2023-09-17 14:48:01.014182570 -0400
+++ POLY2TRI_BLD/poly2tri/common/utils.h	2023-09-17 14:48:33.341620451 -0400
@@ -29,102 +29,74 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#pragma once
+#ifndef UTILS_H
+#define UTILS_H
 
-// Otherwise #defines like M_PI are undeclared under Visual Studio
-#define _USE_MATH_DEFINES
-
-#include "shapes.h"
-
-#include <cmath>
 #include <exception>
-
-// C99 removes M_PI from math.h
-#ifndef M_PI
-#define M_PI 3.14159265358979323846264338327
+#ifdef _WIN32
+// Otherwise #defines like M_PI are undeclared under Visual Studio
+# define _USE_MATH_DEFINES
 #endif
+#include <math.h>
+#include <float.h>
+#include "shapes.h"
+#include "utils.h"
 
 namespace p2t {
 
-const double PI_3div4 = 3 * M_PI / 4;
-const double PI_div2 = 1.57079632679489661923;
-const double EPSILON = 1e-12;
-
-enum Orientation { CW, CCW, COLLINEAR };
-
-/**
- * Forumla to calculate signed area<br>
- * Positive if CCW<br>
- * Negative if CW<br>
- * 0 if collinear<br>
- * <pre>
- * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
- *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
- * </pre>
- */
-Orientation Orient2d(const Point& pa, const Point& pb, const Point& pc)
-{
-  double detleft = (pa.x - pc.x) * (pb.y - pc.y);
-  double detright = (pa.y - pc.y) * (pb.x - pc.x);
-  double val = detleft - detright;
-
-// Using a tolerance here fails on concave-by-subepsilon boundaries
-//   if (val > -EPSILON && val < EPSILON) {
-// Using == on double makes -Wfloat-equal warnings yell at us
-  if (std::fpclassify(val) == FP_ZERO) {
-    return COLLINEAR;
-  } else if (val > 0) {
-    return CCW;
-  }
-  return CW;
+    struct Point;
+    const double PI_3div4 = 3 * M_PI / 4;
+    const double PI_div2 = 1.57079632679489661923;
+    const double EPSILON = DBL_MIN;
+
+    enum Orientation { CW, CCW, COLLINEAR };
+
+    /**
+     * Forumla to calculate signed area<br>
+     * Positive if CCW<br>
+     * Negative if CW<br>
+     * 0 if collinear<br>
+     * <pre>
+     * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
+     *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
+     * </pre>
+     */
+    Orientation Orient2d(Point& pa, Point& pb, Point& pc)
+    {
+	double detleft = (pa.x - pc.x) * (pb.y - pc.y);
+	double detright = (pa.y - pc.y) * (pb.x - pc.x);
+	double val = detleft - detright;
+	if (val > -EPSILON && val < EPSILON) {
+	    return COLLINEAR;
+	} else if (val > 0) {
+	    return CCW;
+	}
+	return CW;
+    }
+
+    bool InScanArea(Point& pa, Point& pb, Point& pc, Point& pd)
+    {
+	double oadb = (pa.x - pb.x)*(pd.y - pb.y) - (pd.x - pb.x)*(pa.y - pb.y);
+	if (oadb >= -EPSILON) {
+	    return false;
+	}
+
+	double oadc = (pa.x - pc.x)*(pd.y - pc.y) - (pd.x - pc.x)*(pa.y - pc.y);
+	if (oadc <= EPSILON) {
+	    return false;
+	}
+	return true;
+    }
 }
 
-/*
-bool InScanArea(Point& pa, Point& pb, Point& pc, Point& pd)
-{
-  double pdx = pd.x;
-  double pdy = pd.y;
-  double adx = pa.x - pdx;
-  double ady = pa.y - pdy;
-  double bdx = pb.x - pdx;
-  double bdy = pb.y - pdy;
-
-  double adxbdy = adx * bdy;
-  double bdxady = bdx * ady;
-  double oabd = adxbdy - bdxady;
-
-  if (oabd <= EPSILON) {
-    return false;
-  }
-
-  double cdx = pc.x - pdx;
-  double cdy = pc.y - pdy;
-
-  double cdxady = cdx * ady;
-  double adxcdy = adx * cdy;
-  double ocad = cdxady - adxcdy;
-
-  if (ocad <= EPSILON) {
-    return false;
-  }
-
-  return true;
-}
-
-*/
+#endif
 
-bool InScanArea(const Point& pa, const Point& pb, const Point& pc, const Point& pd)
-{
-  double oadb = (pa.x - pb.x)*(pd.y - pb.y) - (pd.x - pb.x)*(pa.y - pb.y);
-  if (oadb >= -EPSILON) {
-    return false;
-  }
-
-  double oadc = (pa.x - pc.x)*(pd.y - pc.y) - (pd.x - pc.x)*(pa.y - pc.y);
-  if (oadc <= EPSILON) {
-    return false;
-  }
-  return true;
-}
+// Local Variables:
+// tab-width: 8
+// mode: C++
+// c-basic-offset: 4
+// indent-tabs-mode: t
+// c-file-style: "stroustrup"
+// End:
+// ex: shiftwidth=4 tabstop=8
 
-}
diff -Naur poly2tri.orig/poly2tri/poly2tri.h POLY2TRI_BLD/poly2tri/poly2tri.h
--- poly2tri.orig/poly2tri/poly2tri.h	2023-09-17 14:48:01.014182570 -0400
+++ POLY2TRI_BLD/poly2tri/poly2tri.h	2023-09-17 14:48:33.341620451 -0400
@@ -29,7 +29,11 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#pragma once
+#ifndef POLY2TRI_H
+#define POLY2TRI_H
 
 #include "common/shapes.h"
 #include "sweep/cdt.h"
+
+#endif
+
diff -Naur poly2tri.orig/poly2tri/sweep/advancing_front.cc POLY2TRI_BLD/poly2tri/sweep/advancing_front.cc
--- poly2tri.orig/poly2tri/sweep/advancing_front.cc	2023-09-17 14:48:01.014182570 -0400
+++ POLY2TRI_BLD/poly2tri/sweep/advancing_front.cc	2023-09-17 14:48:33.341620451 -0400
@@ -30,81 +30,90 @@
  */
 #include "advancing_front.h"
 
-#include <cassert>
-
 namespace p2t {
 
-AdvancingFront::AdvancingFront(Node& head, Node& tail)
-{
-  head_ = &head;
-  tail_ = &tail;
-  search_node_ = &head;
-}
-
-Node* AdvancingFront::LocateNode(double x)
-{
-  Node* node = search_node_;
-
-  if (x < node->value) {
-    while ((node = node->prev) != nullptr) {
-      if (x >= node->value) {
-        search_node_ = node;
-        return node;
-      }
+    AdvancingFront::AdvancingFront(Node& head, Node& tail)
+    {
+	head_ = &head;
+	tail_ = &tail;
+	search_node_ = &head;
     }
-  } else {
-    while ((node = node->next) != nullptr) {
-      if (x < node->value) {
-        search_node_ = node->prev;
-        return node->prev;
-      }
-    }
-  }
-  return nullptr;
-}
 
-Node* AdvancingFront::FindSearchNode(double x)
-{
-  (void)x; // suppress compiler warnings "unused parameter 'x'"
-  // TODO: implement BST index
-  return search_node_;
-}
+    Node* AdvancingFront::LocateNode(const double& x)
+    {
+	Node* node = search_node_;
+
+	if (x < node->value) {
+	    while ((node = node->prev) != NULL) {
+		if (x >= node->value) {
+		    search_node_ = node;
+		    return node;
+		}
+	    }
+	} else {
+	    while ((node = node->next) != NULL) {
+		if (x < node->value) {
+		    search_node_ = node->prev;
+		    return node->prev;
+		}
+	    }
+	}
+	return NULL;
+    }
 
-Node* AdvancingFront::LocatePoint(const Point* point)
-{
-  const double px = point->x;
-  Node* node = FindSearchNode(px);
-  const double nx = node->point->x;
-
-  if (px == nx) {
-    if (point != node->point) {
-      // We might have two nodes with same x value for a short time
-      if (point == node->prev->point) {
-        node = node->prev;
-      } else if (point == node->next->point) {
-        node = node->next;
-      } else {
-        assert(0);
-      }
+    Node* AdvancingFront::FindSearchNode(const double& x)
+    {
+	(void)x; // suppress compiler warnings "unused parameter 'x'"
+	// TODO: implement BST index
+	return search_node_;
     }
-  } else if (px < nx) {
-    while ((node = node->prev) != nullptr) {
-      if (point == node->point) {
-        break;
-      }
+
+    Node* AdvancingFront::LocatePoint(const Point* point)
+    {
+	const double px = point->x;
+	Node* node = FindSearchNode(px);
+	const double nx = node->point->x;
+
+	if (px == nx) {
+	    if (point != node->point) {
+		// We might have two nodes with same x value for a short time
+		if (point == node->prev->point) {
+		    node = node->prev;
+		} else if (point == node->next->point) {
+		    node = node->next;
+		} else {
+		    throw std::runtime_error("LocatePoint");
+		}
+	    }
+	} else if (px < nx) {
+	    while ((node = node->prev) != NULL) {
+		if (point == node->point) {
+		    break;
+		}
+	    }
+	} else {
+	    while ((node = node->next) != NULL) {
+		if (point == node->point)
+		    break;
+	    }
+	}
+	if(node) search_node_ = node;
+	return node;
     }
-  } else {
-    while ((node = node->next) != nullptr) {
-      if (point == node->point)
-        break;
+
+    AdvancingFront::~AdvancingFront()
+    {
     }
-  }
-  if(node) search_node_ = node;
-  return node;
-}
 
-AdvancingFront::~AdvancingFront()
-{
 }
 
-} // namespace p2t
+
+// Local Variables:
+// tab-width: 8
+// mode: C++
+// c-basic-offset: 4
+// indent-tabs-mode: t
+// c-file-style: "stroustrup"
+// End:
+// ex: shiftwidth=4 tabstop=8
+
diff -Naur poly2tri.orig/poly2tri/sweep/advancing_front.h POLY2TRI_BLD/poly2tri/sweep/advancing_front.h
--- poly2tri.orig/poly2tri/sweep/advancing_front.h	2023-09-17 14:48:01.014182570 -0400
+++ POLY2TRI_BLD/poly2tri/sweep/advancing_front.h	2023-09-17 14:48:33.345620383 -0400
@@ -29,87 +29,103 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#pragma once
+#ifndef ADVANCED_FRONT_H
+#define ADVANCED_FRONT_H
 
 #include "../common/shapes.h"
 
 namespace p2t {
 
-struct Node;
+    struct Node;
 
-// Advancing front node
-struct Node {
-  Point* point;
-  Triangle* triangle;
+    // Advancing front node
+    struct Node {
+	Point* point;
+	Triangle* triangle;
+
+	Node* next;
+	Node* prev;
+
+	double value;
+	double angle;
+	bool circum;
+	double circumheight;
+
+	Node(Point& p) : point(&p), triangle(NULL), next(NULL), prev(NULL), value(p.x), circum(false)
+	{
+	}
+
+	Node(Point& p, Triangle& t) : point(&p), triangle(&t), next(NULL), prev(NULL), value(p.x), circum(false)
+	{
+	}
+
+    };
+
+    // Advancing front
+    class AdvancingFront {
+	public:
+
+	    AdvancingFront(Node& head, Node& tail);
+	    // Destructor
+	    ~AdvancingFront();
+
+	    Node* head();
+	    void set_head(Node* node);
+	    Node* tail();
+	    void set_tail(Node* node);
+	    Node* search();
+	    void set_search(Node* node);
+
+	    /// Locate insertion point along advancing front
+	    Node* LocateNode(const double& x);
+
+	    Node* LocatePoint(const Point* point);
+
+	private:
+
+	    Node* head_, *tail_, *search_node_;
+
+	    Node* FindSearchNode(const double& x);
+    };
+
+    inline Node* AdvancingFront::head()
+    {
+	return head_;
+    }
+    inline void AdvancingFront::set_head(Node* node)
+    {
+	head_ = node;
+    }
+
+    inline Node* AdvancingFront::tail()
+    {
+	return tail_;
+    }
+    inline void AdvancingFront::set_tail(Node* node)
+    {
+	tail_ = node;
+    }
+
+    inline Node* AdvancingFront::search()
+    {
+	return search_node_;
+    }
+
+    inline void AdvancingFront::set_search(Node* node)
+    {
+	search_node_ = node;
+    }
+
+}
+
+#endif
+
+// Local Variables:
+// tab-width: 8
+// mode: C++
+// c-basic-offset: 4
+// indent-tabs-mode: t
+// c-file-style: "stroustrup"
+// End:
+// ex: shiftwidth=4 tabstop=8
 
-  Node* next;
-  Node* prev;
-
-  double value;
-
-  Node(Point& p) : point(&p), triangle(NULL), next(NULL), prev(NULL), value(p.x)
-  {
-  }
-
-  Node(Point& p, Triangle& t) : point(&p), triangle(&t), next(NULL), prev(NULL), value(p.x)
-  {
-  }
-
-};
-
-// Advancing front
-class AdvancingFront {
-public:
-
-AdvancingFront(Node& head, Node& tail);
-// Destructor
-~AdvancingFront();
-
-Node* head();
-void set_head(Node* node);
-Node* tail();
-void set_tail(Node* node);
-Node* search();
-void set_search(Node* node);
-
-/// Locate insertion point along advancing front
-Node* LocateNode(double x);
-
-Node* LocatePoint(const Point* point);
-
-private:
-
-Node* head_, *tail_, *search_node_;
-
-Node* FindSearchNode(double x);
-};
-
-inline Node* AdvancingFront::head()
-{
-  return head_;
-}
-inline void AdvancingFront::set_head(Node* node)
-{
-  head_ = node;
-}
-
-inline Node* AdvancingFront::tail()
-{
-  return tail_;
-}
-inline void AdvancingFront::set_tail(Node* node)
-{
-  tail_ = node;
-}
-
-inline Node* AdvancingFront::search()
-{
-  return search_node_;
-}
-
-inline void AdvancingFront::set_search(Node* node)
-{
-  search_node_ = node;
-}
-
-}
diff -Naur poly2tri.orig/poly2tri/sweep/cdt.cc POLY2TRI_BLD/poly2tri/sweep/cdt.cc
--- poly2tri.orig/poly2tri/sweep/cdt.cc	2023-09-17 14:48:01.014182570 -0400
+++ POLY2TRI_BLD/poly2tri/sweep/cdt.cc	2023-09-17 14:48:33.345620383 -0400
@@ -32,40 +32,65 @@
 
 namespace p2t {
 
-CDT::CDT(const std::vector<Point*>& polyline)
-{
-  sweep_context_ = new SweepContext(polyline);
-  sweep_ = new Sweep;
-}
+    CDT::CDT()
+    {
+	sweep_context_ = new SweepContext();
+	sweep_ = new Sweep;
+    }
+
+    CDT::CDT(std::vector<Point*> &polyline)
+    {
+	sweep_context_ = new SweepContext(polyline);
+	sweep_ = new Sweep;
+    }
+
+    void CDT::AddOuterLoop(std::vector<Point*> &polyline)
+    {
+	sweep_context_->AddOuterLoop(polyline);
+    }
+    void CDT::AddHole(std::vector<Point*> &polyline)
+    {
+	sweep_context_->AddHole(polyline);
+    }
+
+    void CDT::AddPoint(Point* point) {
+	sweep_context_->AddPoint(point);
+    }
+
+    std::vector<Point*>& CDT::GetPoints() {
+	return sweep_context_->GetPoints();
+    }
+
+    void CDT::Triangulate(bool finalize, int num_points, long maxtime)
+    {
+	sweep_->Triangulate(*sweep_context_, finalize, num_points, maxtime);
+    }
+
+    std::vector<p2t::Triangle*>& CDT::GetTriangles()
+    {
+	return sweep_context_->GetTriangles();
+    }
+
+    std::list<p2t::Triangle*>& CDT::GetMap()
+    {
+	return sweep_context_->GetMap();
+    }
+
+    CDT::~CDT()
+    {
+	delete sweep_context_;
+	delete sweep_;
+    }
 
-void CDT::AddHole(const std::vector<Point*>& polyline)
-{
-  sweep_context_->AddHole(polyline);
 }
 
-void CDT::AddPoint(Point* point) {
-  sweep_context_->AddPoint(point);
-}
 
-void CDT::Triangulate()
-{
-  sweep_->Triangulate(*sweep_context_);
-}
-
-std::vector<p2t::Triangle*> CDT::GetTriangles()
-{
-  return sweep_context_->GetTriangles();
-}
-
-std::list<p2t::Triangle*> CDT::GetMap()
-{
-  return sweep_context_->GetMap();
-}
-
-CDT::~CDT()
-{
-  delete sweep_context_;
-  delete sweep_;
-}
+// Local Variables:
+// tab-width: 8
+// mode: C++
+// c-basic-offset: 4
+// indent-tabs-mode: t
+// c-file-style: "stroustrup"
+// End:
+// ex: shiftwidth=4 tabstop=8
 
-} // namespace p2t
diff -Naur poly2tri.orig/poly2tri/sweep/cdt.h POLY2TRI_BLD/poly2tri/sweep/cdt.h
--- poly2tri.orig/poly2tri/sweep/cdt.h	2023-09-17 14:48:01.014182570 -0400
+++ POLY2TRI_BLD/poly2tri/sweep/cdt.h	2023-09-17 14:48:33.345620383 -0400
@@ -29,14 +29,33 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#pragma once
+#ifndef CDT_H
+#define CDT_H
+
+#if defined(_WIN32)
+# define COMPILER_DLLEXPORT __declspec(dllexport)
+# define COMPILER_DLLIMPORT __declspec(dllimport)
+#else
+# define COMPILER_DLLEXPORT __attribute__ ((visibility ("default")))
+# define COMPILER_DLLIMPORT __attribute__ ((visibility ("default")))
+#endif
+
+#ifndef P2T_EXPORT
+#  if defined(P2T_DLL_EXPORTS) && defined(P2T_DLL_IMPORTS)
+#    error "Only P2T_DLL_EXPORTS or P2T_DLL_IMPORTS can be defined, not both."
+#  elif defined(P2T_DLL_EXPORTS)
+#    define P2T_EXPORT COMPILER_DLLEXPORT
+#  elif defined(P2T_DLL_IMPORTS)
+#    define P2T_EXPORT COMPILER_DLLIMPORT
+#  else
+#    define P2T_EXPORT
+#  endif
+#endif
 
 #include "advancing_front.h"
 #include "sweep_context.h"
 #include "sweep.h"
 
-#include "../common/dll_symbol.h"
-
 /**
  *
  * @author Mason Green <mason.green@gmail.com>
@@ -45,60 +64,74 @@
 
 namespace p2t {
 
-class P2T_DLL_SYMBOL CDT
-{
-public:
-
-  /**
-   * Constructor - add polyline with non repeating points
-   *
-   * @param polyline
-   */
-  CDT(const std::vector<Point*>& polyline);
-
-   /**
-   * Destructor - clean up memory
-   */
-  ~CDT();
-
-  /**
-   * Add a hole
-   *
-   * @param polyline
-   */
-  void AddHole(const std::vector<Point*>& polyline);
-
-  /**
-   * Add a steiner point
-   *
-   * @param point
-   */
-  void AddPoint(Point* point);
-
-  /**
-   * Triangulate - do this AFTER you've added the polyline, holes, and Steiner points
-   */
-  void Triangulate();
-
-  /**
-   * Get CDT triangles
-   */
-  std::vector<Triangle*> GetTriangles();
-
-  /**
-   * Get triangle map
-   */
-  std::list<Triangle*> GetMap();
-
-  private:
-
-  /**
-   * Internals
-   */
+    class CDT
+    {
+	public:
+
+	    /**
+	     * Constructor - add polyline with non repeating points
+	     */
+	    P2T_EXPORT CDT();
+	    P2T_EXPORT CDT(std::vector<Point*> &polyline);
+
+	    /**
+	     * Destructor - clean up memory
+	     */
+	    P2T_EXPORT ~CDT();
+
+	    /**
+	     * Add outer loop
+	     */
+	    P2T_EXPORT void AddOuterLoop(std::vector<Point*> &polyline);
+
+	    /**
+	     * Add a hole
+	     */
+	    P2T_EXPORT void AddHole(std::vector<Point*> &polyline);
+
+	    /**
+	     * Add a steiner point
+	     */
+	    P2T_EXPORT void AddPoint(Point* point);
+
+	    P2T_EXPORT std::vector<Point*>& GetPoints();
+
+	    /**
+	     * Triangulate - do this AFTER you've added the polyline, holes, and Steiner points
+	     */
+	    P2T_EXPORT void Triangulate(bool finalize = true, int num_points = -1, long maxtime = POLY2TRI_MAXTIME);
+
+	    /**
+	     * Get CDT triangles
+	     */
+	    P2T_EXPORT std::vector<Triangle*>& GetTriangles();
+
+	    /**
+	     * Get triangle map
+	     */
+	    P2T_EXPORT std::list<Triangle*>& GetMap();
+
+	private:
+
+	    /**
+	     * Internals
+	     */
 
-  SweepContext* sweep_context_;
-  Sweep* sweep_;
+	    SweepContext* sweep_context_;
+	    Sweep* sweep_;
 
-};
+    };
 
 }
+
+#endif
+
+// Local Variables:
+// tab-width: 8
+// mode: C++
+// c-basic-offset: 4
+// indent-tabs-mode: t
+// c-file-style: "stroustrup"
+// End:
+// ex: shiftwidth=4 tabstop=8
+
diff -Naur poly2tri.orig/poly2tri/sweep/sweep.cc POLY2TRI_BLD/poly2tri/sweep/sweep.cc
--- poly2tri.orig/poly2tri/sweep/sweep.cc	2023-09-17 14:48:01.014182570 -0400
+++ POLY2TRI_BLD/poly2tri/sweep/sweep.cc	2023-09-17 14:48:33.345620383 -0400
@@ -28,833 +28,979 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
+#ifdef _WIN32
+// Otherwise #defines like M_PI are undeclared under Visual Studio
+# define _USE_MATH_DEFINES
+#endif
+#include <math.h>
+#include <float.h>
+#include <limits.h>
+#include <stdexcept>
+#include <iostream>
 #include "sweep.h"
 #include "sweep_context.h"
 #include "advancing_front.h"
 #include "../common/utils.h"
 
-#include <cassert>
-#include <stdexcept>
-
 namespace p2t {
 
-// Triangulate simple polygon with holes
-void Sweep::Triangulate(SweepContext& tcx)
-{
-  tcx.InitTriangulation();
-  tcx.CreateAdvancingFront();
-  // Sweep points; build mesh
-  SweepPoints(tcx);
-  // Clean up
-  FinalizationPolygon(tcx);
-}
-
-void Sweep::SweepPoints(SweepContext& tcx)
-{
-  for (size_t i = 1; i < tcx.point_count(); i++) {
-    Point& point = *tcx.GetPoint(i);
-    Node* node = &PointEvent(tcx, point);
-    for (auto& j : point.edge_list) {
-      EdgeEvent(tcx, j, node);
-    }
-  }
-}
-
-void Sweep::FinalizationPolygon(SweepContext& tcx)
-{
-  // Get an Internal triangle to start with
-  Triangle* t = tcx.front()->head()->next->triangle;
-  Point* p = tcx.front()->head()->next->point;
-  while (t && !t->GetConstrainedEdgeCW(*p)) {
-    t = t->NeighborCCW(*p);
-  }
-
-  // Collect interior triangles constrained by edges
-  if (t) {
-    tcx.MeshClean(*t);
-  }
-}
-
-Node& Sweep::PointEvent(SweepContext& tcx, Point& point)
-{
-  Node* node_ptr = tcx.LocateNode(point);
-  if (!node_ptr || !node_ptr->point || !node_ptr->next || !node_ptr->next->point)
-  {
-    throw std::runtime_error("PointEvent - null node");
-  }
-
-  Node& node = *node_ptr;
-  Node& new_node = NewFrontTriangle(tcx, point, node);
-
-  // Only need to check +epsilon since point never have smaller
-  // x value than node due to how we fetch nodes from the front
-  if (point.x <= node.point->x + EPSILON) {
-    Fill(tcx, node);
-  }
-
-  //tcx.AddNode(new_node);
-
-  FillAdvancingFront(tcx, new_node);
-  return new_node;
-}
-
-void Sweep::EdgeEvent(SweepContext& tcx, Edge* edge, Node* node)
-{
-  tcx.edge_event.constrained_edge = edge;
-  tcx.edge_event.right = (edge->p->x > edge->q->x);
-
-  if (IsEdgeSideOfTriangle(*node->triangle, *edge->p, *edge->q)) {
-    return;
-  }
-
-  // For now we will do all needed filling
-  // TODO: integrate with flip process might give some better performance
-  //       but for now this avoid the issue with cases that needs both flips and fills
-  FillEdgeEvent(tcx, edge, node);
-  EdgeEvent(tcx, *edge->p, *edge->q, node->triangle, *edge->q);
-}
-
-void Sweep::EdgeEvent(SweepContext& tcx, Point& ep, Point& eq, Triangle* triangle, Point& point)
-{
-  if (triangle == nullptr) {
-    throw std::runtime_error("EdgeEvent - null triangle");
-  }
-  if (IsEdgeSideOfTriangle(*triangle, ep, eq)) {
-    return;
-  }
-
-  Point* p1 = triangle->PointCCW(point);
-  Orientation o1 = Orient2d(eq, *p1, ep);
-  if (o1 == COLLINEAR) {
-    if (triangle->Contains(&eq, p1)) {
-      triangle->MarkConstrainedEdge(&eq, p1);
-      // We are modifying the constraint maybe it would be better to
-      // not change the given constraint and just keep a variable for the new constraint
-      tcx.edge_event.constrained_edge->q = p1;
-      triangle = triangle->NeighborAcross(point);
-      EdgeEvent(tcx, ep, *p1, triangle, *p1);
-    } else {
-      throw std::runtime_error("EdgeEvent - collinear points not supported");
-    }
-    return;
-  }
-
-  Point* p2 = triangle->PointCW(point);
-  Orientation o2 = Orient2d(eq, *p2, ep);
-  if (o2 == COLLINEAR) {
-    if (triangle->Contains(&eq, p2)) {
-      triangle->MarkConstrainedEdge(&eq, p2);
-      // We are modifying the constraint maybe it would be better to
-      // not change the given constraint and just keep a variable for the new constraint
-      tcx.edge_event.constrained_edge->q = p2;
-      triangle = triangle->NeighborAcross(point);
-      EdgeEvent(tcx, ep, *p2, triangle, *p2);
-    } else {
-      throw std::runtime_error("EdgeEvent - collinear points not supported");
-    }
-    return;
-  }
-
-  if (o1 == o2) {
-    // Need to decide if we are rotating CW or CCW to get to a triangle
-    // that will cross edge
-    if (o1 == CW) {
-      triangle = triangle->NeighborCCW(point);
-    } else {
-      triangle = triangle->NeighborCW(point);
-    }
-    EdgeEvent(tcx, ep, eq, triangle, point);
-  } else {
-    // This triangle crosses constraint so lets flippin start!
-    assert(triangle);
-    FlipEdgeEvent(tcx, ep, eq, triangle, point);
-  }
-}
-
-bool Sweep::IsEdgeSideOfTriangle(Triangle& triangle, Point& ep, Point& eq)
-{
-  const int index = triangle.EdgeIndex(&ep, &eq);
-
-  if (index != -1) {
-    triangle.MarkConstrainedEdge(index);
-    Triangle* t = triangle.GetNeighbor(index);
-    if (t) {
-      t->MarkConstrainedEdge(&ep, &eq);
-    }
-    return true;
-  }
-  return false;
-}
-
-Node& Sweep::NewFrontTriangle(SweepContext& tcx, Point& point, Node& node)
-{
-  Triangle* triangle = new Triangle(point, *node.point, *node.next->point);
-
-  triangle->MarkNeighbor(*node.triangle);
-  tcx.AddToMap(triangle);
-
-  Node* new_node = new Node(point);
-  nodes_.push_back(new_node);
-
-  new_node->next = node.next;
-  new_node->prev = &node;
-  node.next->prev = new_node;
-  node.next = new_node;
-
-  if (!Legalize(tcx, *triangle)) {
-    tcx.MapTriangleToNodes(*triangle);
-  }
-
-  return *new_node;
-}
-
-void Sweep::Fill(SweepContext& tcx, Node& node)
-{
-  Triangle* triangle = new Triangle(*node.prev->point, *node.point, *node.next->point);
-
-  // TODO: should copy the constrained_edge value from neighbor triangles
-  //       for now constrained_edge values are copied during the legalize
-  triangle->MarkNeighbor(*node.prev->triangle);
-  triangle->MarkNeighbor(*node.triangle);
-
-  tcx.AddToMap(triangle);
-
-  // Update the advancing front
-  node.prev->next = node.next;
-  node.next->prev = node.prev;
-
-  // If it was legalized the triangle has already been mapped
-  if (!Legalize(tcx, *triangle)) {
-    tcx.MapTriangleToNodes(*triangle);
-  }
-}
-
-void Sweep::FillAdvancingFront(SweepContext& tcx, Node& n)
-{
-
-  // Fill right holes
-  Node* node = n.next;
-
-  while (node && node->next) {
-    // if HoleAngle exceeds 90 degrees then break.
-    if (LargeHole_DontFill(node)) break;
-    Fill(tcx, *node);
-    node = node->next;
-  }
-
-  // Fill left holes
-  node = n.prev;
-
-  while (node && node->prev) {
-    // if HoleAngle exceeds 90 degrees then break.
-    if (LargeHole_DontFill(node)) break;
-    Fill(tcx, *node);
-    node = node->prev;
-  }
-
-  // Fill right basins
-  if (n.next && n.next->next) {
-    const double angle = BasinAngle(n);
-    if (angle < PI_3div4) {
-      FillBasin(tcx, n);
-    }
-  }
-}
-
-// True if HoleAngle exceeds 90 degrees.
-// LargeHole_DontFill checks if the advancing front has a large hole.
-// A "Large hole" is a triangle formed by a sequence of points in the advancing
-// front where three neighbor points form a triangle.
-// And angle between left-top, bottom, and right-top points is more than 90 degrees.
-// The first part of the algorithm reviews only three neighbor points, e.g. named A, B, C.
-// Additional part of this logic reviews a sequence of 5 points -
-// additionally reviews one point before and one after the sequence of three (A, B, C),
-// e.g. named X and Y.
-// In this case, angles are XBC and ABY and this if angles are negative or more
-// than 90 degrees LargeHole_DontFill returns true.
-// But there is a configuration when ABC has a negative angle but XBC or ABY is less
-// than 90 degrees and positive.
-// Then function LargeHole_DontFill return false and initiates filling.
-// This filling creates a triangle ABC and adds it to the advancing front.
-// But in the case when angle ABC is negative this triangle goes inside the advancing front
-// and can intersect previously created triangles.
-// This triangle leads to making wrong advancing front and problems in triangulation in the future.
-// Looks like such a triangle should not be created.
-// The simplest way to check and fix it is to check an angle ABC.
-// If it is negative LargeHole_DontFill should return true and
-// not initiate creating the ABC triangle in the advancing front.
-// X______A         Y
-//        \        /
-//         \      /
-//          \ B  /
-//           |  /
-//           | /
-//           |/
-//           C
-bool Sweep::LargeHole_DontFill(const Node* node) const {
-
-  const Node* nextNode = node->next;
-  const Node* prevNode = node->prev;
-  if (!AngleExceeds90Degrees(node->point, nextNode->point, prevNode->point))
-          return false;
-
-  if (AngleIsNegative(node->point, nextNode->point, prevNode->point))
-          return true;
-
-  // Check additional points on front.
-  const Node* next2Node = nextNode->next;
-  // "..Plus.." because only want angles on same side as point being added.
-  if ((next2Node != nullptr) && !AngleExceedsPlus90DegreesOrIsNegative(node->point, next2Node->point, prevNode->point))
-          return false;
-
-  const Node* prev2Node = prevNode->prev;
-  // "..Plus.." because only want angles on same side as point being added.
-  if ((prev2Node != nullptr) && !AngleExceedsPlus90DegreesOrIsNegative(node->point, nextNode->point, prev2Node->point))
-          return false;
-
-  return true;
-}
-
-bool Sweep::AngleIsNegative(const Point* origin, const Point* pa, const Point* pb) const {
-    const double angle = Angle(origin, pa, pb);
-    return angle < 0;
-}
-
-bool Sweep::AngleExceeds90Degrees(const Point* origin, const Point* pa, const Point* pb) const {
-  const double angle = Angle(origin, pa, pb);
-  return ((angle > PI_div2) || (angle < -PI_div2));
-}
-
-bool Sweep::AngleExceedsPlus90DegreesOrIsNegative(const Point* origin, const Point* pa, const Point* pb) const {
-  const double angle = Angle(origin, pa, pb);
-  return (angle > PI_div2) || (angle < 0);
-}
-
-double Sweep::Angle(const Point* origin, const Point* pa, const Point* pb) const {
-  /* Complex plane
-   * ab = cosA +i*sinA
-   * ab = (ax + ay*i)(bx + by*i) = (ax*bx + ay*by) + i(ax*by-ay*bx)
-   * atan2(y,x) computes the principal value of the argument function
-   * applied to the complex number x+iy
-   * Where x = ax*bx + ay*by
-   *       y = ax*by - ay*bx
-   */
-  const double px = origin->x;
-  const double py = origin->y;
-  const double ax = pa->x - px;
-  const double ay = pa->y - py;
-  const double bx = pb->x - px;
-  const double by = pb->y - py;
-  const double x = ax * by - ay * bx;
-  const double y = ax * bx + ay * by;
-  return atan2(x, y);
-}
-
-double Sweep::BasinAngle(const Node& node) const
-{
-  const double ax = node.point->x - node.next->next->point->x;
-  const double ay = node.point->y - node.next->next->point->y;
-  return atan2(ay, ax);
-}
-
-double Sweep::HoleAngle(const Node& node) const
-{
-  /* Complex plane
-   * ab = cosA +i*sinA
-   * ab = (ax + ay*i)(bx + by*i) = (ax*bx + ay*by) + i(ax*by-ay*bx)
-   * atan2(y,x) computes the principal value of the argument function
-   * applied to the complex number x+iy
-   * Where x = ax*bx + ay*by
-   *       y = ax*by - ay*bx
-   */
-  const double ax = node.next->point->x - node.point->x;
-  const double ay = node.next->point->y - node.point->y;
-  const double bx = node.prev->point->x - node.point->x;
-  const double by = node.prev->point->y - node.point->y;
-  return atan2(ax * by - ay * bx, ax * bx + ay * by);
-}
-
-bool Sweep::Legalize(SweepContext& tcx, Triangle& t)
-{
-  // To legalize a triangle we start by finding if any of the three edges
-  // violate the Delaunay condition
-  for (int i = 0; i < 3; i++) {
-    if (t.delaunay_edge[i])
-      continue;
-
-    Triangle* ot = t.GetNeighbor(i);
-
-    if (ot) {
-      Point* p = t.GetPoint(i);
-      Point* op = ot->OppositePoint(t, *p);
-      int oi = ot->Index(op);
-
-      // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)
-      // then we should not try to legalize
-      if (ot->constrained_edge[oi] || ot->delaunay_edge[oi]) {
-        t.constrained_edge[i] = ot->constrained_edge[oi];
-        continue;
-      }
-
-      bool inside = Incircle(*p, *t.PointCCW(*p), *t.PointCW(*p), *op);
-
-      if (inside) {
-        // Lets mark this shared edge as Delaunay
-        t.delaunay_edge[i] = true;
-        ot->delaunay_edge[oi] = true;
-
-        // Lets rotate shared edge one vertex CW to legalize it
-        RotateTrianglePair(t, *p, *ot, *op);
-
-        // We now got one valid Delaunay Edge shared by two triangles
-        // This gives us 4 new edges to check for Delaunay
-
-        // Make sure that triangle to node mapping is done only one time for a specific triangle
-        bool not_legalized = !Legalize(tcx, t);
-        if (not_legalized) {
-          tcx.MapTriangleToNodes(t);
-        }
-
-        not_legalized = !Legalize(tcx, *ot);
-        if (not_legalized)
-          tcx.MapTriangleToNodes(*ot);
-
-        // Reset the Delaunay edges, since they only are valid Delaunay edges
-        // until we add a new triangle or point.
-        // XXX: need to think about this. Can these edges be tried after we
-        //      return to previous recursive level?
-        t.delaunay_edge[i] = false;
-        ot->delaunay_edge[oi] = false;
-
-        // If triangle have been legalized no need to check the other edges since
-        // the recursive legalization will handles those so we can end here.
-        return true;
-      }
-    }
-  }
-  return false;
-}
-
-bool Sweep::Incircle(const Point& pa, const Point& pb, const Point& pc, const Point& pd) const
-{
-  const double adx = pa.x - pd.x;
-  const double ady = pa.y - pd.y;
-  const double bdx = pb.x - pd.x;
-  const double bdy = pb.y - pd.y;
-
-  const double adxbdy = adx * bdy;
-  const double bdxady = bdx * ady;
-  const double oabd = adxbdy - bdxady;
-
-  if (oabd <= 0)
-    return false;
-
-  const double cdx = pc.x - pd.x;
-  const double cdy = pc.y - pd.y;
-
-  const double cdxady = cdx * ady;
-  const double adxcdy = adx * cdy;
-  const double ocad = cdxady - adxcdy;
-
-  if (ocad <= 0)
-    return false;
-
-  const double bdxcdy = bdx * cdy;
-  const double cdxbdy = cdx * bdy;
-
-  const double alift = adx * adx + ady * ady;
-  const double blift = bdx * bdx + bdy * bdy;
-  const double clift = cdx * cdx + cdy * cdy;
-
-  const double det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;
-
-  return det > 0;
-}
-
-void Sweep::RotateTrianglePair(Triangle& t, Point& p, Triangle& ot, Point& op) const
-{
-  Triangle* n1, *n2, *n3, *n4;
-  n1 = t.NeighborCCW(p);
-  n2 = t.NeighborCW(p);
-  n3 = ot.NeighborCCW(op);
-  n4 = ot.NeighborCW(op);
-
-  bool ce1, ce2, ce3, ce4;
-  ce1 = t.GetConstrainedEdgeCCW(p);
-  ce2 = t.GetConstrainedEdgeCW(p);
-  ce3 = ot.GetConstrainedEdgeCCW(op);
-  ce4 = ot.GetConstrainedEdgeCW(op);
-
-  bool de1, de2, de3, de4;
-  de1 = t.GetDelunayEdgeCCW(p);
-  de2 = t.GetDelunayEdgeCW(p);
-  de3 = ot.GetDelunayEdgeCCW(op);
-  de4 = ot.GetDelunayEdgeCW(op);
-
-  t.Legalize(p, op);
-  ot.Legalize(op, p);
-
-  // Remap delaunay_edge
-  ot.SetDelunayEdgeCCW(p, de1);
-  t.SetDelunayEdgeCW(p, de2);
-  t.SetDelunayEdgeCCW(op, de3);
-  ot.SetDelunayEdgeCW(op, de4);
-
-  // Remap constrained_edge
-  ot.SetConstrainedEdgeCCW(p, ce1);
-  t.SetConstrainedEdgeCW(p, ce2);
-  t.SetConstrainedEdgeCCW(op, ce3);
-  ot.SetConstrainedEdgeCW(op, ce4);
-
-  // Remap neighbors
-  // XXX: might optimize the markNeighbor by keeping track of
-  //      what side should be assigned to what neighbor after the
-  //      rotation. Now mark neighbor does lots of testing to find
-  //      the right side.
-  t.ClearNeighbors();
-  ot.ClearNeighbors();
-  if (n1) ot.MarkNeighbor(*n1);
-  if (n2) t.MarkNeighbor(*n2);
-  if (n3) t.MarkNeighbor(*n3);
-  if (n4) ot.MarkNeighbor(*n4);
-  t.MarkNeighbor(ot);
-}
-
-void Sweep::FillBasin(SweepContext& tcx, Node& node)
-{
-  if (Orient2d(*node.point, *node.next->point, *node.next->next->point) == CCW) {
-    tcx.basin.left_node = node.next->next;
-  } else {
-    tcx.basin.left_node = node.next;
-  }
-
-  // Find the bottom and right node
-  tcx.basin.bottom_node = tcx.basin.left_node;
-  while (tcx.basin.bottom_node->next
-         && tcx.basin.bottom_node->point->y >= tcx.basin.bottom_node->next->point->y) {
-    tcx.basin.bottom_node = tcx.basin.bottom_node->next;
-  }
-  if (tcx.basin.bottom_node == tcx.basin.left_node) {
-    // No valid basin
-    return;
-  }
-
-  tcx.basin.right_node = tcx.basin.bottom_node;
-  while (tcx.basin.right_node->next
-         && tcx.basin.right_node->point->y < tcx.basin.right_node->next->point->y) {
-    tcx.basin.right_node = tcx.basin.right_node->next;
-  }
-  if (tcx.basin.right_node == tcx.basin.bottom_node) {
-    // No valid basins
-    return;
-  }
-
-  tcx.basin.width = tcx.basin.right_node->point->x - tcx.basin.left_node->point->x;
-  tcx.basin.left_highest = tcx.basin.left_node->point->y > tcx.basin.right_node->point->y;
-
-  FillBasinReq(tcx, tcx.basin.bottom_node);
-}
-
-void Sweep::FillBasinReq(SweepContext& tcx, Node* node)
-{
-  // if shallow stop filling
-  if (IsShallow(tcx, *node)) {
-    return;
-  }
-
-  Fill(tcx, *node);
-
-  if (node->prev == tcx.basin.left_node && node->next == tcx.basin.right_node) {
-    return;
-  } else if (node->prev == tcx.basin.left_node) {
-    Orientation o = Orient2d(*node->point, *node->next->point, *node->next->next->point);
-    if (o == CW) {
-      return;
-    }
-    node = node->next;
-  } else if (node->next == tcx.basin.right_node) {
-    Orientation o = Orient2d(*node->point, *node->prev->point, *node->prev->prev->point);
-    if (o == CCW) {
-      return;
-    }
-    node = node->prev;
-  } else {
-    // Continue with the neighbor node with lowest Y value
-    if (node->prev->point->y < node->next->point->y) {
-      node = node->prev;
-    } else {
-      node = node->next;
-    }
-  }
-
-  FillBasinReq(tcx, node);
-}
-
-bool Sweep::IsShallow(SweepContext& tcx, Node& node)
-{
-  double height;
-
-  if (tcx.basin.left_highest) {
-    height = tcx.basin.left_node->point->y - node.point->y;
-  } else {
-    height = tcx.basin.right_node->point->y - node.point->y;
-  }
-
-  // if shallow stop filling
-  if (tcx.basin.width > height) {
-    return true;
-  }
-  return false;
-}
-
-void Sweep::FillEdgeEvent(SweepContext& tcx, Edge* edge, Node* node)
-{
-  if (tcx.edge_event.right) {
-    FillRightAboveEdgeEvent(tcx, edge, node);
-  } else {
-    FillLeftAboveEdgeEvent(tcx, edge, node);
-  }
-}
-
-void Sweep::FillRightAboveEdgeEvent(SweepContext& tcx, Edge* edge, Node* node)
-{
-  while (node->next->point->x < edge->p->x) {
-    // Check if next node is below the edge
-    if (Orient2d(*edge->q, *node->next->point, *edge->p) == CCW) {
-      FillRightBelowEdgeEvent(tcx, edge, *node);
-    } else {
-      node = node->next;
-    }
-  }
-}
-
-void Sweep::FillRightBelowEdgeEvent(SweepContext& tcx, Edge* edge, Node& node)
-{
-  if (node.point->x < edge->p->x) {
-    if (Orient2d(*node.point, *node.next->point, *node.next->next->point) == CCW) {
-      // Concave
-      FillRightConcaveEdgeEvent(tcx, edge, node);
-    } else {
-      // Convex
-      FillRightConvexEdgeEvent(tcx, edge, node);
-      // Retry this one
-      FillRightBelowEdgeEvent(tcx, edge, node);
-    }
-  }
-}
-
-void Sweep::FillRightConcaveEdgeEvent(SweepContext& tcx, Edge* edge, Node& node)
-{
-  Fill(tcx, *node.next);
-  if (node.next->point != edge->p) {
-    // Next above or below edge?
-    if (Orient2d(*edge->q, *node.next->point, *edge->p) == CCW) {
-      // Below
-      if (Orient2d(*node.point, *node.next->point, *node.next->next->point) == CCW) {
-        // Next is concave
-        FillRightConcaveEdgeEvent(tcx, edge, node);
-      } else {
-        // Next is convex
-      }
-    }
-  }
-}
-
-void Sweep::FillRightConvexEdgeEvent(SweepContext& tcx, Edge* edge, Node& node)
-{
-  // Next concave or convex?
-  if (Orient2d(*node.next->point, *node.next->next->point, *node.next->next->next->point) == CCW) {
-    // Concave
-    FillRightConcaveEdgeEvent(tcx, edge, *node.next);
-  } else {
-    // Convex
-    // Next above or below edge?
-    if (Orient2d(*edge->q, *node.next->next->point, *edge->p) == CCW) {
-      // Below
-      FillRightConvexEdgeEvent(tcx, edge, *node.next);
-    } else {
-      // Above
-    }
-  }
-}
-
-void Sweep::FillLeftAboveEdgeEvent(SweepContext& tcx, Edge* edge, Node* node)
-{
-  while (node->prev->point->x > edge->p->x) {
-    // Check if next node is below the edge
-    if (Orient2d(*edge->q, *node->prev->point, *edge->p) == CW) {
-      FillLeftBelowEdgeEvent(tcx, edge, *node);
-    } else {
-      node = node->prev;
-    }
-  }
-}
-
-void Sweep::FillLeftBelowEdgeEvent(SweepContext& tcx, Edge* edge, Node& node)
-{
-  if (node.point->x > edge->p->x) {
-    if (Orient2d(*node.point, *node.prev->point, *node.prev->prev->point) == CW) {
-      // Concave
-      FillLeftConcaveEdgeEvent(tcx, edge, node);
-    } else {
-      // Convex
-      FillLeftConvexEdgeEvent(tcx, edge, node);
-      // Retry this one
-      FillLeftBelowEdgeEvent(tcx, edge, node);
-    }
-  }
-}
-
-void Sweep::FillLeftConvexEdgeEvent(SweepContext& tcx, Edge* edge, Node& node)
-{
-  // Next concave or convex?
-  if (Orient2d(*node.prev->point, *node.prev->prev->point, *node.prev->prev->prev->point) == CW) {
-    // Concave
-    FillLeftConcaveEdgeEvent(tcx, edge, *node.prev);
-  } else {
-    // Convex
-    // Next above or below edge?
-    if (Orient2d(*edge->q, *node.prev->prev->point, *edge->p) == CW) {
-      // Below
-      FillLeftConvexEdgeEvent(tcx, edge, *node.prev);
-    } else {
-      // Above
-    }
-  }
-}
-
-void Sweep::FillLeftConcaveEdgeEvent(SweepContext& tcx, Edge* edge, Node& node)
-{
-  Fill(tcx, *node.prev);
-  if (node.prev->point != edge->p) {
-    // Next above or below edge?
-    if (Orient2d(*edge->q, *node.prev->point, *edge->p) == CW) {
-      // Below
-      if (Orient2d(*node.point, *node.prev->point, *node.prev->prev->point) == CW) {
-        // Next is concave
-        FillLeftConcaveEdgeEvent(tcx, edge, node);
-      } else {
-        // Next is convex
-      }
-    }
-  }
-}
-
-void Sweep::FlipEdgeEvent(SweepContext& tcx, Point& ep, Point& eq, Triangle* t, Point& p)
-{
-  assert(t);
-  Triangle* ot_ptr = t->NeighborAcross(p);
-  if (ot_ptr == nullptr)
-  {
-    throw std::runtime_error("FlipEdgeEvent - null neighbor across");
-  }
-  Triangle& ot = *ot_ptr;
-  Point& op = *ot.OppositePoint(*t, p);
-
-  if (InScanArea(p, *t->PointCCW(p), *t->PointCW(p), op)) {
-    // Lets rotate shared edge one vertex CW
-    RotateTrianglePair(*t, p, ot, op);
-    tcx.MapTriangleToNodes(*t);
-    tcx.MapTriangleToNodes(ot);
-
-    if (p == eq && op == ep) {
-      if (eq == *tcx.edge_event.constrained_edge->q && ep == *tcx.edge_event.constrained_edge->p) {
-        t->MarkConstrainedEdge(&ep, &eq);
-        ot.MarkConstrainedEdge(&ep, &eq);
-        Legalize(tcx, *t);
-        Legalize(tcx, ot);
-      } else {
-        // XXX: I think one of the triangles should be legalized here?
-      }
-    } else {
-      Orientation o = Orient2d(eq, op, ep);
-      t = &NextFlipTriangle(tcx, (int)o, *t, ot, p, op);
-      FlipEdgeEvent(tcx, ep, eq, t, p);
-    }
-  } else {
-    Point& newP = NextFlipPoint(ep, eq, ot, op);
-    FlipScanEdgeEvent(tcx, ep, eq, *t, ot, newP);
-    EdgeEvent(tcx, ep, eq, t, p);
-  }
-}
-
-Triangle& Sweep::NextFlipTriangle(SweepContext& tcx, int o, Triangle& t, Triangle& ot, Point& p, Point& op)
-{
-  if (o == CCW) {
-    // ot is not crossing edge after flip
-    int edge_index = ot.EdgeIndex(&p, &op);
-    ot.delaunay_edge[edge_index] = true;
-    Legalize(tcx, ot);
-    ot.ClearDelunayEdges();
-    return t;
-  }
-
-  // t is not crossing edge after flip
-  int edge_index = t.EdgeIndex(&p, &op);
-
-  t.delaunay_edge[edge_index] = true;
-  Legalize(tcx, t);
-  t.ClearDelunayEdges();
-  return ot;
-}
-
-Point& Sweep::NextFlipPoint(Point& ep, Point& eq, Triangle& ot, Point& op)
-{
-  Orientation o2d = Orient2d(eq, op, ep);
-  if (o2d == CW) {
-    // Right
-    return *ot.PointCCW(op);
-  } else if (o2d == CCW) {
-    // Left
-    return *ot.PointCW(op);
-  }
-  throw std::runtime_error("[Unsupported] Opposing point on constrained edge");
-}
-
-void Sweep::FlipScanEdgeEvent(SweepContext& tcx, Point& ep, Point& eq, Triangle& flip_triangle,
-                              Triangle& t, Point& p)
-{
-  Triangle* ot_ptr = t.NeighborAcross(p);
-  if (ot_ptr == nullptr) {
-    throw std::runtime_error("FlipScanEdgeEvent - null neighbor across");
-  }
-
-  Point* op_ptr = ot_ptr->OppositePoint(t, p);
-  if (op_ptr == nullptr) {
-    throw std::runtime_error("FlipScanEdgeEvent - null opposing point");
-  }
-
-  Point* p1 = flip_triangle.PointCCW(eq);
-  Point* p2 = flip_triangle.PointCW(eq);
-  if (p1 == nullptr || p2 == nullptr) {
-    throw std::runtime_error("FlipScanEdgeEvent - null on either of points");
-  }
-
-  Triangle& ot = *ot_ptr;
-  Point& op = *op_ptr;
-
-  if (InScanArea(eq, *p1, *p2, op)) {
-    // flip with new edge op->eq
-    FlipEdgeEvent(tcx, eq, op, &ot, op);
-    // TODO: Actually I just figured out that it should be possible to
-    //       improve this by getting the next ot and op before the the above
-    //       flip and continue the flipScanEdgeEvent here
-    // set new ot and op here and loop back to inScanArea test
-    // also need to set a new flip_triangle first
-    // Turns out at first glance that this is somewhat complicated
-    // so it will have to wait.
-  } else {
-    Point& newP = NextFlipPoint(ep, eq, ot, op);
-    FlipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);
-  }
-}
-
-Sweep::~Sweep() {
-
-    // Clean up memory
-    for (auto& node : nodes_) {
-      delete node;
-    }
-}
+    // Triangulate simple polygon with holes
+    void Sweep::Triangulate(SweepContext& tcx, bool finalize, int num_points, long maxtime)
+    {
+	tri_start_time = std::chrono::steady_clock::now();
+	timeout = (maxtime > 0) ? maxtime : LONG_MAX;
+	tcx.InitTriangulation();
+	tcx.CreateAdvancingFront(nodes_);
+	// Sweep points; build mesh
+	SweepPoints(tcx,num_points);
+	// Clean up
+	if (finalize) {
+	    FinalizationPolygon(tcx);
+	}
+
+	curr_time = std::chrono::steady_clock::now();
+	//std::cout << "triangulation time (microseconds): " << std::chrono::duration_cast<std::chrono::microseconds>(curr_time - tri_start_time).count() << "\n";
+    }
+
+    void Sweep::SweepPoints(SweepContext& tcx, int num_points)
+    {
+	double currentheight = tcx.GetPoint(0)->y;
+	for (size_t i = 1; (i < tcx.point_count()) && (i <= num_points); i++) {
+	    Point& point = *tcx.GetPoint(i);
+	    if (point.y > currentheight) {
+		CheckCircleEvent(tcx,point.y);
+		currentheight = point.y;
+	    }
+	    Node* node = &PointEvent(tcx, point);
+	    for (size_t j = 0; j < point.edge_list.size(); j++) {
+		EdgeEvent(tcx, point.edge_list[j], node);
+	    }
+	}
+    }
+
+    Triangle* Sweep::FindInternalTriangle(Triangle* ext_tri)
+    {
+	Triangle* t = NULL;
+
+	if (ext_tri != NULL) {
+	    if (ext_tri->constrained_edge[0]) {
+		return ext_tri->GetNeighbor(0);
+	    } else if (ext_tri->constrained_edge[1]) {
+		return ext_tri->GetNeighbor(1);
+	    } else if (ext_tri->constrained_edge[2]) {
+		return ext_tri->GetNeighbor(2);
+	    } else {
+		ext_tri->IsChecked(true);
+		for(int i=0; i<3; i++) {
+		    Triangle* n = ext_tri->GetNeighbor(i);
+		    if ((n != NULL) && (!n->IsChecked())) {
+			t = FindInternalTriangle(n);
+			if (t != NULL)
+			    break;
+		    }
+		}
+	    }
+	}
+	return t;
+    }
+
+    void Sweep::FinalizationPolygon(SweepContext& tcx)
+    {
+	// Get an Internal triangle to start with
+	Triangle* t = FindInternalTriangle(tcx.af_tail_->triangle);
+	if (!t) return;
+
+	// Collect interior triangles constrained by edges
+	tcx.MeshClean(*t);
+    }
+
+    Node& Sweep::PointEvent(SweepContext& tcx, Point& point)
+    {
+	Node& node = tcx.LocateNode(point);
+	Node& new_node = NewFrontTriangle(tcx, point, node);
+
+	// Only need to check +epsilon since point never have smaller
+	// x value than node due to how we fetch nodes from the front
+	if (point.x <= node.point->x + EPSILON) {
+	    Fill(tcx, node);
+	}
+
+	//tcx.AddNode(new_node);
+
+	FillAdvancingFront(tcx, new_node);
+	return new_node;
+    }
+
+    void Sweep::EdgeEvent(SweepContext& tcx, Edge* edge, Node* node)
+    {
+	tcx.edge_event.constrained_edge = edge;
+	tcx.edge_event.right = (edge->p->x > edge->q->x);
+
+	if (IsEdgeSideOfTriangle(*node->triangle, *edge->p, *edge->q)) {
+	    return;
+	}
+
+	// For now we will do all needed filling
+	// TODO: integrate with flip process might give some better performance
+	//       but for now this avoid the issue with cases that needs both flips and fills
+	FillEdgeEvent(tcx, edge, node);
+	EdgeEvent(tcx, *edge->p, *edge->q, node->triangle, *edge->q);
+    }
+
+    void Sweep::EdgeEvent(SweepContext& tcx, Point& ep, Point& eq, Triangle* triangle, Point& point)
+    {
+	if (IsEdgeSideOfTriangle(*triangle, ep, eq)) {
+	    return;
+	}
+
+	Point* p1 = triangle->PointCCW(point);
+	Orientation o1 = Orient2d(eq, *p1, ep);
+	if (o1 == COLLINEAR) {
+	    if( triangle->Contains(&eq, p1)) {
+		triangle->MarkConstrainedEdge(&eq, p1 );
+		// We are modifying the constraint maybe it would be better to
+		// not change the given constraint and just keep a variable for the new constraint
+		tcx.edge_event.constrained_edge->q = p1;
+		triangle = triangle->NeighborAcross(point);
+		EdgeEvent( tcx, ep, *p1, triangle, *p1 );
+	    } else {
+		std::runtime_error("EdgeEvent - collinear points not supported");
+	    }
+	    return;
+	}
+
+	Point* p2 = triangle->PointCW(point);
+	Orientation o2 = Orient2d(eq, *p2, ep);
+	if (o2 == COLLINEAR) {
+	    if( triangle->Contains(&eq, p2)) {
+		triangle->MarkConstrainedEdge(&eq, p2 );
+		// We are modifying the constraint maybe it would be better to
+		// not change the given constraint and just keep a variable for the new constraint
+		tcx.edge_event.constrained_edge->q = p2;
+		triangle = triangle->NeighborAcross(point);
+		EdgeEvent( tcx, ep, *p2, triangle, *p2 );
+	    } else {
+		std::runtime_error("EdgeEvent - collinear points not supported");
+	    }
+	    return;
+	}
+
+	if (o1 == o2) {
+	    // Need to decide if we are rotating CW or CCW to get to a triangle
+	    // that will cross edge
+	    if (o1 == CW) {
+		triangle = triangle->NeighborCCW(point);
+	    }       else{
+		triangle = triangle->NeighborCW(point);
+	    }
+	    EdgeEvent(tcx, ep, eq, triangle, point);
+	} else {
+	    // This triangle crosses constraint so lets flippin start!
+	    FlipEdgeEvent(tcx, ep, eq, triangle, point);
+	}
+    }
+
+    bool Sweep::IsEdgeSideOfTriangle(Triangle& triangle, Point& ep, Point& eq)
+    {
+	if (&triangle == NULL)
+	    throw std::runtime_error("NULL triangle(?)");
+
+	int index = triangle.EdgeIndex(&ep, &eq);
+
+	if (index != -1) {
+	    triangle.MarkConstrainedEdge(index);
+	    Triangle* t = triangle.GetNeighbor(index);
+	    if (t) {
+		t->MarkConstrainedEdge(&ep, &eq);
+	    }
+	    return true;
+	}
+	return false;
+    }
+
+    Node& Sweep::NewFrontTriangle(SweepContext& tcx, Point& point, Node& node)
+    {
+	Triangle* triangle = new Triangle(point, *node.point, *node.next->point);
+
+	triangle->MarkNeighbor(*node.triangle);
+	tcx.AddToMap(triangle);
+
+	Node* new_node = new Node(point);
+	nodes_.push_back(new_node);
+
+	new_node->next = node.next;
+	new_node->prev = &node;
+	node.next->prev = new_node;
+	node.next = new_node;
+
+	if (new_node->next)
+	    UpdateNodeAngleCircum(*new_node->next);
+
+	UpdateNodeAngleCircum(*new_node);
+
+	if (new_node->prev)
+	    UpdateNodeAngleCircum(*new_node->prev);
+
+	if (!Legalize(tcx, *triangle)) {
+	    tcx.MapTriangleToNodes(*triangle);
+	}
+
+	return *new_node;
+    }
+
+    void Sweep::UpdateNodeAngleCircum(Node& n)
+    {
+	if (n.next && n.prev) {
+	    Point* nextPoint = n.next->point;
+	    Point* prevPoint = n.prev->point;
+
+	    n.angle = Angle(*n.point, *nextPoint, *prevPoint);
+
+	    if ((n.angle > 0) && (n.angle < M_PI)) {
+		Point center;
+		double radius;
+		n.circum = Circumcircle(*n.point, *nextPoint, *prevPoint, center, radius);
+		if (n.circum) {
+		    n.circumheight = center.y + radius;
+		}
+	    }
+	}
+    }
+
+    void Sweep::Fill(SweepContext& tcx, Node& node)
+    {
+	Triangle* triangle = new Triangle(*node.prev->point, *node.point, *node.next->point);
+
+	// TODO: should copy the constrained_edge value from neighbor triangles
+	//       for now constrained_edge values are copied during the legalize
+	triangle->MarkNeighbor(*node.prev->triangle);
+	triangle->MarkNeighbor(*node.triangle);
+
+	tcx.AddToMap(triangle);
+
+	// Update the advancing front
+	node.prev->next = node.next;
+	node.next->prev = node.prev;
+	if (node.next)
+	    UpdateNodeAngleCircum(*node.next);
+
+	if (node.prev)
+	    UpdateNodeAngleCircum(*node.prev);
+
+	// If it was legalized the triangle has already been mapped
+	if (!Legalize(tcx, *triangle)) {
+	    tcx.MapTriangleToNodes(*triangle);
+	}
+
+    }
+
+    void Sweep::CheckCircleEvent(SweepContext& tcx, double currentheight)
+    {
+	Node *node = tcx.front()->head();
+
+	while (node->next) {
+	    // if HoleAngle exceeds 90 degrees then break.
+	    if (node->circum && (node->circumheight < currentheight)) {
+		Fill(tcx, *node);
+		node = node->prev;
+	    } else {
+		node = node->next;
+	    }
+	}
+    }
+
+    void Sweep::FillAdvancingFront(SweepContext& tcx, Node& n)
+    {
+
+	curr_time = std::chrono::steady_clock::now();
+	if (std::chrono::duration_cast<std::chrono::microseconds>(curr_time - tri_start_time).count() > timeout)
+	    throw std::runtime_error("Poly2Tri timeout");
+
+	// Fill right holes
+	Node* node = n.next;
+	Node* leftboundnode = NULL;
+
+	while (node->next) {
+	    // if HoleAngle exceeds 90 degrees then break.
+	    if (LargeHole_DontFill(node)) break;
+	    Fill(tcx, *node);
+	    node = node->next;
+	}
+
+	// Fill left holes
+	node = n.prev;
+
+	while (node->prev) {
+	    // if HoleAngle exceeds 90 degrees then break.
+	    if (LargeHole_DontFill(node)) break;
+	    Fill(tcx, *node);
+	    node = node->prev;
+	}
+
+	node = n.prev;
+	if (node->point->x < n.point->x) {
+	    node = node->prev;
+	    while (node) {
+		// if HoleAngle exceeds 90 degrees then break.
+		if (node->point->x >= n.point->x) {
+		    leftboundnode = node;
+		}
+		node = node->prev;
+	    }
+	    if (leftboundnode) {
+		node = n.prev;
+		while (node != leftboundnode) {
+		    Fill(tcx, *node);
+		    node = node->prev;
+		}
+	    }
+	}
+
+	// Fill right basins
+	if (n.next && n.next->next) {
+	    double angle = BasinAngle(n);
+	    if (angle < PI_3div4) {
+		FillBasin(tcx, n);
+	    }
+	}
+    }
+
+    // True if HoleAngle exceeds 90 degrees.
+    // LargeHole_DontFill checks if the advancing front has a large hole.
+    // A "Large hole" is a triangle formed by a sequence of points in the advancing
+    // front where three neighbor points form a triangle.
+    // And angle between left-top, bottom, and right-top points is more than 90 degrees.
+    // The first part of the algorithm reviews only three neighbor points, e.g. named A, B, C.
+    // Additional part of this logic reviews a sequence of 5 points -
+    // additionally reviews one point before and one after the sequence of three (A, B, C),
+    // e.g. named X and Y.
+    // In this case, angles are XBC and ABY and this if angles are negative or more
+    // than 90 degrees LargeHole_DontFill returns true.
+    // But there is a configuration when ABC has a negative angle but XBC or ABY is less
+    // than 90 degrees and positive.
+    // Then function LargeHole_DontFill return false and initiates filling.
+    // This filling creates a triangle ABC and adds it to the advancing front.
+    // But in the case when angle ABC is negative this triangle goes inside the advancing front
+    // and can intersect previously created triangles.
+    // This triangle leads to making wrong advancing front and problems in triangulation in the future.
+    // Looks like such a triangle should not be created.
+    // The simplest way to check and fix it is to check an angle ABC.
+    // If it is negative LargeHole_DontFill should return true and
+    // not initiate creating the ABC triangle in the advancing front.
+    // X______A         Y
+    //        \        /
+    //         \      /
+    //          \ B  /
+    //           |  /
+    //           | /
+    //           |/
+    //           C
+    bool Sweep::LargeHole_DontFill(const Node* node) const {
+
+	const Node* nextNode = node->next;
+	const Node* prevNode = node->prev;
+	if (!AngleExceeds90Degrees(node->point, nextNode->point, prevNode->point))
+	    return false;
+
+	if (AngleIsNegative(node->point, nextNode->point, prevNode->point))
+	    return true;
+
+	// Check additional points on front.
+	const Node* next2Node = nextNode->next;
+	// "..Plus.." because only want angles on same side as point being added.
+	if ((next2Node != nullptr) && !AngleExceedsPlus90DegreesOrIsNegative(node->point, next2Node->point, prevNode->point))
+	    return false;
+
+	const Node* prev2Node = prevNode->prev;
+	// "..Plus.." because only want angles on same side as point being added.
+	if ((prev2Node != nullptr) && !AngleExceedsPlus90DegreesOrIsNegative(node->point, nextNode->point, prev2Node->point))
+	    return false;
+
+	return true;
+    }
+
+    bool Sweep::AngleIsNegative(const Point* origin, const Point* pa, const Point* pb) const {
+	const double angle = Angle(*origin, *pa, *pb);
+	return angle < 0;
+    }
+
+    bool Sweep::AngleExceeds90Degrees(const Point* origin, const Point* pa, const Point* pb) const {
+	double angle = Angle(*origin, *pa, *pb);
+	bool exceeds90Degrees = ((angle > PI_div2) || (angle < -PI_div2));
+	return exceeds90Degrees;
+    }
+
+    bool Sweep::AngleExceedsPlus90DegreesOrIsNegative(const Point* origin, const Point* pa, const Point* pb) const {
+	double angle = Angle(*origin, *pa, *pb);
+	bool exceedsPlus90DegreesOrIsNegative = (angle > PI_div2) || (angle < 0);
+	return exceedsPlus90DegreesOrIsNegative;
+    }
+
+    double Sweep::Angle(const Point& origin, const Point& pa, const Point& pb) const {
+	/* Complex plane
+	 * ab = cosA +i*sinA
+	 * ab = (ax + ay*i)(bx + by*i) = (ax*bx + ay*by) + i(ax*by-ay*bx)
+	 * atan2(y,x) computes the principal value of the argument function
+	 * applied to the complex number x+iy
+	 * Where x = ax*bx + ay*by
+	 *       y = ax*by - ay*bx
+	 */
+	double px = origin.x;
+	double py = origin.y;
+	double ax = pa.x- px;
+	double ay = pa.y - py;
+	double bx = pb.x - px;
+	double by = pb.y - py;
+	double x = ax * by - ay * bx;
+	double y = ax * bx + ay * by;
+	double angle = atan2(x, y);
+	return angle;
+    }
+
+    double Sweep::BasinAngle(Node& node)
+    {
+	double ax = node.point->x - node.next->next->point->x;
+	double ay = node.point->y - node.next->next->point->y;
+	return atan2(ay, ax);
+    }
+
+    double Sweep::HoleAngle(Node& node)
+    {
+	/* Complex plane
+	 * ab = cosA +i*sinA
+	 * ab = (ax + ay*i)(bx + by*i) = (ax*bx + ay*by) + i(ax*by-ay*bx)
+	 * atan2(y,x) computes the principal value of the argument function
+	 * applied to the complex number x+iy
+	 * Where x = ax*bx + ay*by
+	 *       y = ax*by - ay*bx
+	 */
+	double ax = node.next->point->x - node.point->x;
+	double ay = node.next->point->y - node.point->y;
+	double bx = node.prev->point->x - node.point->x;
+	double by = node.prev->point->y - node.point->y;
+	return atan2(ax * by - ay * bx, ax * bx + ay * by);
+    }
+
+    bool Sweep::Legalize(SweepContext& tcx, Triangle& t)
+    {
+	// To legalize a triangle we start by finding if any of the three edges
+	// violate the Delaunay condition
+	for (int i = 0; i < 3; i++) {
+	    if (t.delaunay_edge[i])
+		continue;
+
+	    Triangle* ot = t.GetNeighbor(i);
+
+	    if (ot) {
+		Point* p = t.GetPoint(i);
+		Point* op = ot->OppositePoint(t, *p);
+		int oi = ot->Index(op);
+		if (oi < 0) return false;
+
+		// If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)
+		// then we should not try to legalize
+		if (ot->constrained_edge[oi] || ot->delaunay_edge[oi]) {
+		    t.constrained_edge[i] = ot->constrained_edge[oi];
+		    continue;
+		}
+
+		bool inside = Incircle(*p, *t.PointCCW(*p), *t.PointCW(*p), *op);
+
+		if (inside) {
+		    // Lets mark this shared edge as Delaunay
+		    t.delaunay_edge[i] = true;
+		    ot->delaunay_edge[oi] = true;
+
+		    // Lets rotate shared edge one vertex CW to legalize it
+		    RotateTrianglePair(t, *p, *ot, *op);
+
+		    // We now got one valid Delaunay Edge shared by two triangles
+		    // This gives us 4 new edges to check for Delaunay
+
+		    // Make sure that triangle to node mapping is done only one time for a specific triangle
+		    bool not_legalized = !Legalize(tcx, t);
+		    if (not_legalized) {
+			tcx.MapTriangleToNodes(t);
+		    }
+
+		    not_legalized = !Legalize(tcx, *ot);
+		    if (not_legalized)
+			tcx.MapTriangleToNodes(*ot);
+
+		    // Reset the Delaunay edges, since they only are valid Delaunay edges
+		    // until we add a new triangle or point.
+		    // XXX: need to think about this. Can these edges be tried after we
+		    //      return to previous recursive level?
+		    t.delaunay_edge[i] = false;
+		    ot->delaunay_edge[oi] = false;
+
+		    // If triangle have been legalized no need to check the other edges since
+		    // the recursive legalization will handles those so we can end here.
+		    return true;
+		}
+	    }
+	}
+	return false;
+    }
+
+    bool Sweep::Circumcircle(const Point& a, const Point& b, const Point& c, Point& center, double &radius)
+    {
+	double cross_product = Cross(a - b,b - c);
+
+	if (cross_product > DBL_MIN) {
+	    double cp2 = cross_product * cross_product;
+	    double dotp_a = Dot(a - b,a - c);
+	    double dotp_b = Dot(b - a,b - c);
+	    double dotp_c = Dot(c - a,c - b);
+	    double ablen = (a -b).Length();
+	    double bclen = (b-c).Length();
+	    double calen = (c-a).Length();
+
+	    radius = ablen * bclen * calen / (2.0 * cross_product);
+
+	    double alpha = bclen * bclen * dotp_a / (2.0 * cp2);
+	    double beta = calen * calen * dotp_b / (2.0 * cp2);
+	    double gamma = ablen * ablen * dotp_c / (2.0 * cp2);
+
+	    center = alpha * a + beta * b + gamma * c;
+	} else {
+	    return  false;
+	}
+	return true;
+    }
+
+    bool Sweep::Incircle(Point& pa, Point& pb, Point& pc, Point& pd)
+    {
+	double adx = pa.x - pd.x;
+	double ady = pa.y - pd.y;
+	double bdx = pb.x - pd.x;
+	double bdy = pb.y - pd.y;
+
+	double adxbdy = adx * bdy;
+	double bdxady = bdx * ady;
+	double oabd = adxbdy - bdxady;
+
+	if (oabd <= 0)
+	    return false;
+
+	double cdx = pc.x - pd.x;
+	double cdy = pc.y - pd.y;
+
+	double cdxady = cdx * ady;
+	double adxcdy = adx * cdy;
+	double ocad = cdxady - adxcdy;
+
+	if (ocad <= 0)
+	    return false;
+
+	double bdxcdy = bdx * cdy;
+	double cdxbdy = cdx * bdy;
+
+	double alift = adx * adx + ady * ady;
+	double blift = bdx * bdx + bdy * bdy;
+	double clift = cdx * cdx + cdy * cdy;
+
+	double det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;
+
+	return det > 0;
+    }
+
+    void Sweep::RotateTrianglePair(Triangle& t, Point& p, Triangle& ot, Point& op)
+    {
+	Triangle* n1, *n2, *n3, *n4;
+	n1 = t.NeighborCCW(p);
+	n2 = t.NeighborCW(p);
+	n3 = ot.NeighborCCW(op);
+	n4 = ot.NeighborCW(op);
+
+	bool ce1, ce2, ce3, ce4;
+	ce1 = t.GetConstrainedEdgeCCW(p);
+	ce2 = t.GetConstrainedEdgeCW(p);
+	ce3 = ot.GetConstrainedEdgeCCW(op);
+	ce4 = ot.GetConstrainedEdgeCW(op);
+
+	bool de1, de2, de3, de4;
+	de1 = t.GetDelunayEdgeCCW(p);
+	de2 = t.GetDelunayEdgeCW(p);
+	de3 = ot.GetDelunayEdgeCCW(op);
+	de4 = ot.GetDelunayEdgeCW(op);
+
+	t.Legalize(p, op);
+	ot.Legalize(op, p);
+
+	// Remap delaunay_edge
+	ot.SetDelunayEdgeCCW(p, de1);
+	t.SetDelunayEdgeCW(p, de2);
+	t.SetDelunayEdgeCCW(op, de3);
+	ot.SetDelunayEdgeCW(op, de4);
+
+	// Remap constrained_edge
+	ot.SetConstrainedEdgeCCW(p, ce1);
+	t.SetConstrainedEdgeCW(p, ce2);
+	t.SetConstrainedEdgeCCW(op, ce3);
+	ot.SetConstrainedEdgeCW(op, ce4);
+
+	// Remap neighbors
+	// XXX: might optimize the markNeighbor by keeping track of
+	//      what side should be assigned to what neighbor after the
+	//      rotation. Now mark neighbor does lots of testing to find
+	//      the right side.
+	t.ClearNeighbors();
+	ot.ClearNeighbors();
+	if (n1) ot.MarkNeighbor(*n1);
+	if (n2) t.MarkNeighbor(*n2);
+	if (n3) t.MarkNeighbor(*n3);
+	if (n4) ot.MarkNeighbor(*n4);
+	t.MarkNeighbor(ot);
+    }
+
+    void Sweep::FillBasin(SweepContext& tcx, Node& node)
+    {
+	if (Orient2d(*node.point, *node.next->point, *node.next->next->point) == CCW) {
+	    tcx.basin.left_node = node.next->next;
+	} else {
+	    tcx.basin.left_node = node.next;
+	}
+
+	// Find the bottom and right node
+	tcx.basin.bottom_node = tcx.basin.left_node;
+	while (tcx.basin.bottom_node->next
+		&& tcx.basin.bottom_node->point->y >= tcx.basin.bottom_node->next->point->y) {
+	    tcx.basin.bottom_node = tcx.basin.bottom_node->next;
+	}
+	if (tcx.basin.bottom_node == tcx.basin.left_node) {
+	    // No valid basin
+	    return;
+	}
+
+	tcx.basin.right_node = tcx.basin.bottom_node;
+	while (tcx.basin.right_node->next
+		&& tcx.basin.right_node->point->y < tcx.basin.right_node->next->point->y) {
+	    tcx.basin.right_node = tcx.basin.right_node->next;
+	}
+	if (tcx.basin.right_node == tcx.basin.bottom_node) {
+	    // No valid basins
+	    return;
+	}
+
+	tcx.basin.width = tcx.basin.right_node->point->x - tcx.basin.left_node->point->x;
+	tcx.basin.left_highest = tcx.basin.left_node->point->y > tcx.basin.right_node->point->y;
+
+	FillBasinReq(tcx, tcx.basin.bottom_node);
+    }
+
+    void Sweep::FillBasinReq(SweepContext& tcx, Node* node)
+    {
+	// if shallow stop filling
+	if (IsShallow(tcx, *node)) {
+	    return;
+	}
+
+	Fill(tcx, *node);
+
+	if (node->prev == tcx.basin.left_node && node->next == tcx.basin.right_node) {
+	    return;
+	} else if (node->prev == tcx.basin.left_node) {
+	    Orientation o = Orient2d(*node->point, *node->next->point, *node->next->next->point);
+	    if (o == CW) {
+		return;
+	    }
+	    node = node->next;
+	} else if (node->next == tcx.basin.right_node) {
+	    Orientation o = Orient2d(*node->point, *node->prev->point, *node->prev->prev->point);
+	    if (o == CCW) {
+		return;
+	    }
+	    node = node->prev;
+	} else {
+	    // Continue with the neighbor node with lowest Y value
+	    if (node->prev->point->y < node->next->point->y) {
+		node = node->prev;
+	    } else {
+		node = node->next;
+	    }
+	}
+
+	FillBasinReq(tcx, node);
+    }
+
+    bool Sweep::IsShallow(SweepContext& tcx, Node& node)
+    {
+	double height;
+
+	if (tcx.basin.left_highest) {
+	    height = tcx.basin.left_node->point->y - node.point->y;
+	} else {
+	    height = tcx.basin.right_node->point->y - node.point->y;
+	}
+
+	// if shallow stop filling
+	if (tcx.basin.width > height) {
+	    return true;
+	}
+	return false;
+    }
+
+    void Sweep::FillEdgeEvent(SweepContext& tcx, Edge* edge, Node* node)
+    {
+	if (tcx.edge_event.right) {
+	    FillRightAboveEdgeEvent(tcx, edge, node);
+	} else {
+	    FillLeftAboveEdgeEvent(tcx, edge, node);
+	}
+    }
+
+    void Sweep::FillRightAboveEdgeEvent(SweepContext& tcx, Edge* edge, Node* node)
+    {
+	while (node->next->point->x < edge->p->x) {
+	    // Check if next node is below the edge
+	    if (Orient2d(*edge->q, *node->next->point, *edge->p) == CCW) {
+		FillRightBelowEdgeEvent(tcx, edge, *node);
+	    } else {
+		node = node->next;
+	    }
+	}
+    }
+
+    void Sweep::FillRightBelowEdgeEvent(SweepContext& tcx, Edge* edge, Node& node)
+    {
+	if (node.point->x < edge->p->x) {
+	    if (Orient2d(*node.point, *node.next->point, *node.next->next->point) == CCW) {
+		// Concave
+		FillRightConcaveEdgeEvent(tcx, edge, node);
+	    } else{
+		// Convex
+		FillRightConvexEdgeEvent(tcx, edge, node);
+		// Retry this one
+		FillRightBelowEdgeEvent(tcx, edge, node);
+	    }
+	}
+    }
+
+    void Sweep::FillRightConcaveEdgeEvent(SweepContext& tcx, Edge* edge, Node& node)
+    {
+	Fill(tcx, *node.next);
+	if (node.next->point != edge->p) {
+	    // Next above or below edge?
+	    if (Orient2d(*edge->q, *node.next->point, *edge->p) == CCW) {
+		// Below
+		if (Orient2d(*node.point, *node.next->point, *node.next->next->point) == CCW) {
+		    // Next is concave
+		    FillRightConcaveEdgeEvent(tcx, edge, node);
+		} else {
+		    // Next is convex
+		}
+	    }
+	}
+
+    }
+
+    void Sweep::FillRightConvexEdgeEvent(SweepContext& tcx, Edge* edge, Node& node)
+    {
+	// Next concave or convex?
+	if (Orient2d(*node.next->point, *node.next->next->point, *node.next->next->next->point) == CCW) {
+	    // Concave
+	    FillRightConcaveEdgeEvent(tcx, edge, *node.next);
+	} else{
+	    // Convex
+	    // Next above or below edge?
+	    if (Orient2d(*edge->q, *node.next->next->point, *edge->p) == CCW) {
+		// Below
+		FillRightConvexEdgeEvent(tcx, edge, *node.next);
+	    } else{
+		// Above
+	    }
+	}
+    }
+
+    void Sweep::FillLeftAboveEdgeEvent(SweepContext& tcx, Edge* edge, Node* node)
+    {
+	while (node->prev->point->x > edge->p->x) {
+	    // Check if next node is below the edge
+	    if (Orient2d(*edge->q, *node->prev->point, *edge->p) == CW) {
+		FillLeftBelowEdgeEvent(tcx, edge, *node);
+	    } else {
+		node = node->prev;
+	    }
+	}
+    }
+
+    void Sweep::FillLeftBelowEdgeEvent(SweepContext& tcx, Edge* edge, Node& node)
+    {
+	if (node.point->x > edge->p->x) {
+	    if (Orient2d(*node.point, *node.prev->point, *node.prev->prev->point) == CW) {
+		// Concave
+		FillLeftConcaveEdgeEvent(tcx, edge, node);
+	    } else {
+		// Convex
+		FillLeftConvexEdgeEvent(tcx, edge, node);
+		// Retry this one
+		FillLeftBelowEdgeEvent(tcx, edge, node);
+	    }
+	}
+    }
+
+    void Sweep::FillLeftConvexEdgeEvent(SweepContext& tcx, Edge* edge, Node& node)
+    {
+	// Next concave or convex?
+	if (Orient2d(*node.prev->point, *node.prev->prev->point, *node.prev->prev->prev->point) == CW) {
+	    // Concave
+	    FillLeftConcaveEdgeEvent(tcx, edge, *node.prev);
+	} else{
+	    // Convex
+	    // Next above or below edge?
+	    if (Orient2d(*edge->q, *node.prev->prev->point, *edge->p) == CW) {
+		// Below
+		FillLeftConvexEdgeEvent(tcx, edge, *node.prev);
+	    } else{
+		// Above
+	    }
+	}
+    }
+
+    void Sweep::FillLeftConcaveEdgeEvent(SweepContext& tcx, Edge* edge, Node& node)
+    {
+	Fill(tcx, *node.prev);
+	if (node.prev->point != edge->p) {
+	    // Next above or below edge?
+	    if (Orient2d(*edge->q, *node.prev->point, *edge->p) == CW) {
+		// Below
+		if (Orient2d(*node.point, *node.prev->point, *node.prev->prev->point) == CW) {
+		    // Next is concave
+		    FillLeftConcaveEdgeEvent(tcx, edge, node);
+		} else{
+		    // Next is convex
+		}
+	    }
+	}
+
+    }
+
+    void Sweep::FlipEdgeEvent(SweepContext& tcx, Point& ep, Point& eq, Triangle* t, Point& p)
+    {
+	Triangle& ot = *t->NeighborAcross(p);
+	Point& op = *ot.OppositePoint(*t, p);
+
+	flip_edge_event_cnt++;
+
+	if (flip_edge_event_cnt > 10000) {
+	    throw std::runtime_error("FLIP edge event call stack too deep");
+	}
+
+	if (&ot == NULL) {
+	    // If we want to integrate the fillEdgeEvent do it here
+	    // With current implementation we should never get here
+	    throw std::runtime_error( "[BUG:FIXME] FLIP failed due to missing triangle");
+	}
+
+	if (InScanArea(p, *t->PointCCW(p), *t->PointCW(p), op)) {
+	    // Lets rotate shared edge one vertex CW
+	    RotateTrianglePair(*t, p, ot, op);
+	    tcx.MapTriangleToNodes(*t);
+	    tcx.MapTriangleToNodes(ot);
+
+	    if (p == eq && op == ep) {
+		if (eq == *tcx.edge_event.constrained_edge->q && ep == *tcx.edge_event.constrained_edge->p) {
+		    t->MarkConstrainedEdge(&ep, &eq);
+		    ot.MarkConstrainedEdge(&ep, &eq);
+		    Legalize(tcx, *t);
+		    Legalize(tcx, ot);
+		} else {
+		    // XXX: I think one of the triangles should be legalized here?
+		}
+	    } else {
+		Orientation o = Orient2d(eq, op, ep);
+		t = &NextFlipTriangle(tcx, (int)o, *t, ot, p, op);
+		FlipEdgeEvent(tcx, ep, eq, t, p);
+	    }
+	} else {
+	    Point& newP = NextFlipPoint(ep, eq, ot, op);
+	    FlipScanEdgeEvent(tcx, ep, eq, *t, ot, newP);
+	    EdgeEvent(tcx, ep, eq, t, p);
+	}
+
+	flip_edge_event_cnt--;
+    }
+
+    Triangle& Sweep::NextFlipTriangle(SweepContext& tcx, int o, Triangle& t, Triangle& ot, Point& p, Point& op)
+    {
+	if (o == CCW) {
+	    // ot is not crossing edge after flip
+	    int edge_index = ot.EdgeIndex(&p, &op);
+	    ot.delaunay_edge[edge_index] = true;
+	    Legalize(tcx, ot);
+	    ot.ClearDelunayEdges();
+	    return t;
+	}
+
+	// t is not crossing edge after flip
+	int edge_index = t.EdgeIndex(&p, &op);
+
+	t.delaunay_edge[edge_index] = true;
+	Legalize(tcx, t);
+	t.ClearDelunayEdges();
+	return ot;
+    }
+
+    Point& Sweep::NextFlipPoint(Point& ep, Point& eq, Triangle& ot, Point& op)
+    {
+	Orientation o2d = Orient2d(eq, op, ep);
+	if (o2d == CW) {
+	    // Right
+	    return *ot.PointCCW(op);
+	} else if (o2d == CCW) {
+	    // Left
+	    return *ot.PointCW(op);
+	}
+	throw std::runtime_error("[Unsupported] Opposing point on constrained edge");
+    }
+
+    void Sweep::FlipScanEdgeEvent(SweepContext& tcx, Point& ep, Point& eq, Triangle& flip_triangle,
+	    Triangle& t, Point& p)
+    {
+	Triangle& ot = *t.NeighborAcross(p);
+	Point& op = *ot.OppositePoint(t, p);
+
+	if (t.NeighborAcross(p) == NULL) {
+	    // If we want to integrate the fillEdgeEvent do it here
+	    // With current implementation we should never get here
+	    throw std::runtime_error( "[BUG:FIXME] FLIP failed due to missing triangle");
+	}
+
+	if (InScanArea(eq, *flip_triangle.PointCCW(eq), *flip_triangle.PointCW(eq), op)) {
+	    // flip with new edge op->eq
+	    FlipEdgeEvent(tcx, eq, op, &ot, op);
+	    // TODO: Actually I just figured out that it should be possible to
+	    //       improve this by getting the next ot and op before the the above
+	    //       flip and continue the flipScanEdgeEvent here
+	    // set new ot and op here and loop back to inScanArea test
+	    // also need to set a new flip_triangle first
+	    // Turns out at first glance that this is somewhat complicated
+	    // so it will have to wait.
+	} else{
+	    Point& newP = NextFlipPoint(ep, eq, ot, op);
+	    FlipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);
+	}
+    }
+
+    Sweep::~Sweep() {
+
+	// Clean up memory
+	for(size_t i = 0; i < nodes_.size(); i++) {
+	    delete nodes_[i];
+	}
+
+    }
+
+}
+
+
+// Local Variables:
+// tab-width: 8
+// mode: C++
+// c-basic-offset: 4
+// indent-tabs-mode: t
+// c-file-style: "stroustrup"
+// End:
+// ex: shiftwidth=4 tabstop=8
 
-} // namespace p2t
diff -Naur poly2tri.orig/poly2tri/sweep/sweep_context.cc POLY2TRI_BLD/poly2tri/sweep/sweep_context.cc
--- poly2tri.orig/poly2tri/sweep/sweep_context.cc	2023-09-17 14:48:01.014182570 -0400
+++ POLY2TRI_BLD/poly2tri/sweep/sweep_context.cc	2023-09-17 14:48:33.345620383 -0400
@@ -30,177 +30,247 @@
  */
 #include "sweep_context.h"
 #include <algorithm>
+#include <stdexcept>
 #include "advancing_front.h"
 
 namespace p2t {
 
-SweepContext::SweepContext(std::vector<Point*> polyline) : points_(std::move(polyline)),
-  front_(nullptr),
-  head_(nullptr),
-  tail_(nullptr),
-  af_head_(nullptr),
-  af_middle_(nullptr),
-  af_tail_(nullptr)
-{
-  InitEdges(points_);
-}
+    bool SweepContext::lessthanpoint::operator() (const Point* a, const Point* b) const
+    {
+	if (a->y < b->y) {
+	    return true;
+	} else if (a->y == b->y) {
+	    return (a->x < b->x);
+	}
+	return false;
+    }
 
-void SweepContext::AddHole(const std::vector<Point*>& polyline)
-{
-  InitEdges(polyline);
-  for (auto i : polyline) {
-    points_.push_back(i);
-  }
-}
+    SweepContext::SweepContext()
+    {
+	basin = Basin();
+	edge_event = EdgeEvent();
+    }
 
-void SweepContext::AddPoint(Point* point) {
-  points_.push_back(point);
-}
+    SweepContext::SweepContext(std::vector<Point*> &polyline)
+    {
+	std::vector<Point*> polylineunique;
+
+	basin = Basin();
+	edge_event = EdgeEvent();
+
+	for(unsigned int i = 0; i < polyline.size(); i++) {
+	    Point *p = AddPointCheckForDuplicates(polyline[i]);
+	    polylineunique.push_back(p);
+	}
+	InitEdges(polylineunique);
 
-std::vector<Triangle*> &SweepContext::GetTriangles()
-{
-  return triangles_;
-}
+    }
 
-std::list<Triangle*> &SweepContext::GetMap()
-{
-  return map_;
-}
+    void SweepContext::AddOuterLoop(std::vector<Point*> &polyline)
+    {
+	std::vector<Point*> polylineunique;
+	for(unsigned int i = 0; i < polyline.size(); i++) {
+	    Point *p = AddPointCheckForDuplicates(polyline[i]);
+	    polylineunique.push_back(p);
+	}
+	InitEdges(polylineunique);
 
-void SweepContext::InitTriangulation()
-{
-  double xmax(points_[0]->x), xmin(points_[0]->x);
-  double ymax(points_[0]->y), ymin(points_[0]->y);
-
-  // Calculate bounds.
-  for (auto& point : points_) {
-    Point& p = *point;
-    if (p.x > xmax)
-      xmax = p.x;
-    if (p.x < xmin)
-      xmin = p.x;
-    if (p.y > ymax)
-      ymax = p.y;
-    if (p.y < ymin)
-      ymin = p.y;
-  }
-
-  double dx = kAlpha * (xmax - xmin);
-  double dy = kAlpha * (ymax - ymin);
-  head_ = new Point(xmin - dx, ymin - dy);
-  tail_ = new Point(xmax + dx, ymin - dy);
+    }
 
-  // Sort points along y-axis
-  std::sort(points_.begin(), points_.end(), cmp);
+    void SweepContext::AddHole(std::vector<Point*> &polyline)
+    {
+	std::vector<Point*> polylineunique;
+	for(unsigned int i = 0; i < polyline.size(); i++) {
+	    Point *p = AddPointCheckForDuplicates(polyline[i]);
+	    polylineunique.push_back(p);
+	}
+	InitEdges(polylineunique);
+    }
 
-}
+    void SweepContext::AddPoint(Point* point) {
+	points_.push_back(point);
+    }
 
-void SweepContext::InitEdges(const std::vector<Point*>& polyline)
-{
-  size_t num_points = polyline.size();
-  for (size_t i = 0; i < num_points; i++) {
-    size_t j = i < num_points - 1 ? i + 1 : 0;
-    edge_list.push_back(new Edge(*polyline[i], *polyline[j]));
-  }
-}
+    Point* SweepContext::AddPointCheckForDuplicates(Point* point) {
+	std::pair<std::set<Point*,lessthanpoint>::iterator,bool> result;
 
-Point* SweepContext::GetPoint(size_t index)
-{
-  return points_[index];
-}
+	result = points_set_.insert(point);
+	if (result.second) {
+	    points_.push_back(point);
+	    return point;
+	}
+	Point* found_point = *points_set_.find(point);
+	delete point;
+	return found_point;
+    }
 
-void SweepContext::AddToMap(Triangle* triangle)
-{
-  map_.push_back(triangle);
-}
+    std::vector<Triangle*>& SweepContext::GetTriangles()
+    {
+	return triangles_;
+    }
 
-Node* SweepContext::LocateNode(const Point& point)
-{
-  // TODO implement search tree
-  return front_->LocateNode(point.x);
-}
+    std::list<Triangle*>& SweepContext::GetMap()
+    {
+	return map_;
+    }
 
-void SweepContext::CreateAdvancingFront()
-{
+    void SweepContext::InitTriangulation()
+    {
+	double xmax(points_[0]->x), xmin(points_[0]->x);
+	double ymax(points_[0]->y), ymin(points_[0]->y);
+
+	// Calculate bounds.
+	for (unsigned int i = 0; i < points_.size(); i++) {
+	    Point& p = *points_[i];
+	    if (p.x > xmax)
+		xmax = p.x;
+	    if (p.x < xmin)
+		xmin = p.x;
+	    if (p.y > ymax)
+		ymax = p.y;
+	    if (p.y < ymin)
+		ymin = p.y;
+	}
+
+	double dx = kAlpha * (xmax - xmin);
+	double dy = kAlpha * (ymax - ymin);
+	head_ = new Point(xmax + dx, ymin - dy);
+	tail_ = new Point(xmin - dx, ymin - dy);
 
-  // Initial triangle
-  Triangle* triangle = new Triangle(*points_[0], *head_, *tail_);
+	// Sort points along y-axis
+	std::sort(points_.begin(), points_.end(), cmp);
 
-  map_.push_back(triangle);
+    }
 
-  af_head_ = new Node(*triangle->GetPoint(1), *triangle);
-  af_middle_ = new Node(*triangle->GetPoint(0), *triangle);
-  af_tail_ = new Node(*triangle->GetPoint(2));
-  front_ = new AdvancingFront(*af_head_, *af_tail_);
-
-  // TODO: More intuitive if head is middles next and not previous?
-  //       so swap head and tail
-  af_head_->next = af_middle_;
-  af_middle_->next = af_tail_;
-  af_middle_->prev = af_head_;
-  af_tail_->prev = af_middle_;
-}
+    void SweepContext::InitEdges(std::vector<Point*> &polyline)
+    {
+	size_t num_points = polyline.size();
+	for (size_t i = 0; i < num_points; i++) {
+	    size_t j = i < num_points - 1 ? i + 1 : 0;
+	    if (!(EQ((*polyline[i]).x, (*polyline[j]).x) && EQ((*polyline[i]).y, (*polyline[j]).y)))
+		edge_list.push_back(new Edge(*polyline[i], *polyline[j]));
+	}
+    }
 
-void SweepContext::RemoveNode(Node* node)
-{
-  delete node;
-}
+    Point* SweepContext::GetPoint(size_t index)
+    {
+	return points_[index];
+    }
 
-void SweepContext::MapTriangleToNodes(Triangle& t)
-{
-  for (int i = 0; i < 3; i++) {
-    if (!t.GetNeighbor(i)) {
-      Node* n = front_->LocatePoint(t.PointCW(*t.GetPoint(i)));
-      if (n)
-        n->triangle = &t;
+    std::vector<Point*>& SweepContext::GetPoints()
+    {
+	return points_;
     }
-  }
-}
 
-void SweepContext::RemoveFromMap(Triangle* triangle)
-{
-  map_.remove(triangle);
-}
+    void SweepContext::AddToMap(Triangle* triangle)
+    {
+	map_.push_back(triangle);
+    }
 
-void SweepContext::MeshClean(Triangle& triangle)
-{
-  std::vector<Triangle *> triangles;
-  triangles.push_back(&triangle);
-
-  while(!triangles.empty()){
-	Triangle *t = triangles.back();
-	triangles.pop_back();
-
-    if (t != nullptr && !t->IsInterior()) {
-      t->IsInterior(true);
-      triangles_.push_back(t);
-      for (int i = 0; i < 3; i++) {
-        if (!t->constrained_edge[i])
-          triangles.push_back(t->GetNeighbor(i));
-      }
+    Node& SweepContext::LocateNode(Point& point)
+    {
+	// TODO implement search tree
+	return *front_->LocateNode(point.x);
     }
-  }
-}
 
-SweepContext::~SweepContext()
-{
+    void SweepContext::CreateAdvancingFront(std::vector<Node*> &nodes)
+    {
+
+	// Initial triangle
+	Triangle* triangle = new Triangle(*points_[0], *tail_, *head_);
 
-    // Clean up memory
+	map_.push_back(triangle);
 
-    delete head_;
-    delete tail_;
-    delete front_;
-    delete af_head_;
-    delete af_middle_;
-    delete af_tail_;
+	af_head_ = new Node(*triangle->GetPoint(1), *triangle);
+	af_middle_ = new Node(*triangle->GetPoint(0), *triangle);
+	af_tail_ = new Node(*triangle->GetPoint(2), *triangle);
+	front_ = new AdvancingFront(*af_head_, *af_tail_);
+
+	// TODO: More intuitive if head is middles next and not previous?
+	//       so swap head and tail
+	af_head_->next = af_middle_;
+	af_middle_->next = af_tail_;
+	af_middle_->prev = af_head_;
+	af_tail_->prev = af_middle_;
+    }
+
+    void SweepContext::RemoveNode(Node* node)
+    {
+	delete node;
+    }
 
-    for (auto ptr : map_) {
-      delete ptr;
+    void SweepContext::MapTriangleToNodes(Triangle& t)
+    {
+	for (int i = 0; i < 3; i++) {
+	    if (!t.GetNeighbor(i)) {
+		Node* n = front_->LocatePoint(t.PointCW(*t.GetPoint(i)));
+		if (n)
+		    n->triangle = &t;
+	    }
+	}
     }
 
-    for (auto& i : edge_list) {
-      delete i;
+    void SweepContext::RemoveFromMap(Triangle* triangle)
+    {
+	map_.remove(triangle);
     }
+
+    void SweepContext::MeshClean(Triangle& triangle)
+    {
+	if (&triangle == NULL)
+	    throw std::runtime_error("MeshClean - NULL triangl(?)");
+
+	meshclean_call_cnt++;
+	if (meshclean_call_cnt > 20000)
+	   throw std::runtime_error("SweepContext MeshClean call stack too deep");
+
+	if (!triangle.IsInterior()) {
+	    triangle.IsInterior(true);
+	    triangles_.push_back(&triangle);
+	    for (int i = 0; i < 3; i++) {
+		if (!triangle.constrained_edge[i])
+		    MeshClean(*triangle.GetNeighbor(i));
+	    }
+	}
+
+	meshclean_call_cnt--;
+    }
+
+    SweepContext::~SweepContext()
+    {
+
+	// Clean up memory
+
+	delete head_;
+	delete tail_;
+	delete front_;
+	delete af_head_;
+	delete af_middle_;
+	delete af_tail_;
+
+	typedef std::list<Triangle*> type_list;
+
+	for(type_list::iterator iter = map_.begin(); iter != map_.end(); ++iter) {
+	    Triangle* ptr = *iter;
+	    delete ptr;
+	}
+
+	for(unsigned int i = 0; i < edge_list.size(); i++) {
+	    delete edge_list[i];
+	}
+	points_.clear();
+	points_set_.clear();
+    }
+
 }
 
-} // namespace p2t
+
+// Local Variables:
+// tab-width: 8
+// mode: C++
+// c-basic-offset: 4
+// indent-tabs-mode: t
+// c-file-style: "stroustrup"
+// End:
+// ex: shiftwidth=4 tabstop=8
+
diff -Naur poly2tri.orig/poly2tri/sweep/sweep_context.h POLY2TRI_BLD/poly2tri/sweep/sweep_context.h
--- poly2tri.orig/poly2tri/sweep/sweep_context.h	2023-09-17 14:48:01.014182570 -0400
+++ POLY2TRI_BLD/poly2tri/sweep/sweep_context.h	2023-09-17 14:48:33.345620383 -0400
@@ -29,156 +29,179 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#pragma once
+#ifndef SWEEP_CONTEXT_H
+#define SWEEP_CONTEXT_H
 
 #include <list>
+#include <set>
 #include <vector>
 #include <cstddef>
 
 namespace p2t {
 
-// Inital triangle factor, seed triangle will extend 30% of
-// PointSet width to both left and right.
-const double kAlpha = 0.3;
+    // Inital triangle factor, seed triangle will extend 30% of
+    // PointSet width to both left and right.
+    const double kAlpha = 0.3;
 
-struct Point;
-class Triangle;
-struct Node;
-struct Edge;
-class AdvancingFront;
+    struct Point;
+    class Triangle;
+    struct Node;
+    struct Edge;
+    class AdvancingFront;
 
-class SweepContext {
-public:
+    class SweepContext {
+	public:
 
-/// Constructor
-explicit SweepContext(std::vector<Point*> polyline);
-/// Destructor
-~SweepContext();
+	    /// Constructor
+	    SweepContext();
+	    SweepContext(std::vector<Point*> &polyline);
+	    /// Destructor
+	    ~SweepContext();
 
-void set_head(Point* p1);
+	    void set_head(Point* p1);
 
-Point* head() const;
+	    Point* head();
 
-void set_tail(Point* p1);
+	    void set_tail(Point* p1);
 
-Point* tail() const;
+	    Point* tail();
 
-size_t point_count() const;
+	    size_t point_count();
 
-Node* LocateNode(const Point& point);
+	    Node& LocateNode(Point& point);
 
-void RemoveNode(Node* node);
+	    void RemoveNode(Node* node);
 
-void CreateAdvancingFront();
+	    void CreateAdvancingFront(std::vector<Node*> &nodes);
 
-/// Try to map a node to all sides of this triangle that don't have a neighbor
-void MapTriangleToNodes(Triangle& t);
+	    /// Try to map a node to all sides of this triangle that don't have a neighbor
+	    void MapTriangleToNodes(Triangle& t);
 
-void AddToMap(Triangle* triangle);
+	    void AddToMap(Triangle* triangle);
 
-Point* GetPoint(size_t index);
+	    Point* GetPoint(size_t index);
 
-Point* GetPoints();
+	    std::vector<Point*>& GetPoints();
 
-void RemoveFromMap(Triangle* triangle);
+	    void RemoveFromMap(Triangle* triangle);
 
-void AddHole(const std::vector<Point*>& polyline);
+	    void AddOuterLoop(std::vector<Point*> &polyline);
+	    void AddHole(std::vector<Point*> &polyline);
 
-void AddPoint(Point* point);
+	    void AddPoint(Point* point);
+	    Point* AddPointCheckForDuplicates(Point* point);
 
-AdvancingFront* front() const;
+	    AdvancingFront* front();
 
-void MeshClean(Triangle& triangle);
+	    void MeshClean(Triangle& triangle);
 
-std::vector<Triangle*> &GetTriangles();
-std::list<Triangle*> &GetMap();
+	    std::vector<Triangle*>& GetTriangles();
+	    std::list<Triangle*>& GetMap();
 
-std::vector<Edge*> edge_list;
+	    std::vector<Edge*> edge_list;
 
-struct Basin {
-  Node* left_node;
-  Node* bottom_node;
-  Node* right_node;
-  double width;
-  bool left_highest;
+	    struct Basin {
+		Node* left_node;
+		Node* bottom_node;
+		Node* right_node;
+		double width;
+		bool left_highest;
 
-  Basin()
-  : left_node(nullptr), bottom_node(nullptr), right_node(nullptr), width(0.0), left_highest(false)
-  {
-  }
+		Basin() : left_node(NULL), bottom_node(NULL), right_node(NULL), width(0.0), left_highest(false)
+		{
+		}
 
-  void Clear()
-  {
-    left_node = nullptr;
-    bottom_node = nullptr;
-    right_node = nullptr;
-    width = 0.0;
-    left_highest = false;
-  }
-};
+		void Clear()
+		{
+		    left_node = NULL;
+		    bottom_node = NULL;
+		    right_node = NULL;
+		    width = 0.0;
+		    left_highest = false;
+		}
+	    };
 
-struct EdgeEvent {
-  Edge* constrained_edge;
-  bool right;
+	    struct EdgeEvent {
+		Edge* constrained_edge;
+		bool right;
 
-  EdgeEvent() : constrained_edge(NULL), right(false)
-  {
-  }
-};
+		EdgeEvent() : constrained_edge(NULL), right(false)
+		{
+		}
+	    };
 
-Basin basin;
-EdgeEvent edge_event;
+	    struct lessthanpoint{
+		public:
+		    bool operator() (const Point* a, const Point* b) const;
+	    };
 
-private:
+	    Basin basin;
+	    EdgeEvent edge_event;
 
-friend class Sweep;
+	private:
 
-std::vector<Triangle*> triangles_;
-std::list<Triangle*> map_;
-std::vector<Point*> points_;
+	    friend class Sweep;
 
-// Advancing front
-AdvancingFront* front_;
-// head point used with advancing front
-Point* head_;
-// tail point used with advancing front
-Point* tail_;
+	    std::vector<Triangle*> triangles_;
+	    std::list<Triangle*> map_;
+	    std::vector<Point*> points_;
+	    std::set<Point*,lessthanpoint> points_set_;
 
-Node *af_head_, *af_middle_, *af_tail_;
+	    // Advancing front
+	    AdvancingFront* front_;
+	    // head point used with advancing front
+	    Point* head_;
+	    // tail point used with advancing front
+	    Point* tail_;
 
-void InitTriangulation();
-void InitEdges(const std::vector<Point*>& polyline);
+	    Node *af_head_, *af_middle_, *af_tail_;
 
-};
+	    void InitTriangulation();
+	    void InitEdges(std::vector<Point*> &polyline);
 
-inline AdvancingFront* SweepContext::front() const
-{
-  return front_;
-}
+	    int meshclean_call_cnt = 0;
+    };
 
-inline size_t SweepContext::point_count() const
-{
-  return points_.size();
-}
+    inline AdvancingFront* SweepContext::front()
+    {
+	return front_;
+    }
 
-inline void SweepContext::set_head(Point* p1)
-{
-  head_ = p1;
-}
+    inline size_t SweepContext::point_count()
+    {
+	return points_.size();
+    }
 
-inline Point* SweepContext::head() const
-{
-  return head_;
-}
+    inline void SweepContext::set_head(Point* p1)
+    {
+	head_ = p1;
+    }
 
-inline void SweepContext::set_tail(Point* p1)
-{
-  tail_ = p1;
-}
+    inline Point* SweepContext::head()
+    {
+	return head_;
+    }
 
-inline Point* SweepContext::tail() const
-{
-  return tail_;
-}
+    inline void SweepContext::set_tail(Point* p1)
+    {
+	tail_ = p1;
+    }
+
+    inline Point* SweepContext::tail()
+    {
+	return tail_;
+    }
 
 }
+
+#endif
+
+// Local Variables:
+// tab-width: 8
+// mode: C++
+// c-basic-offset: 4
+// indent-tabs-mode: t
+// c-file-style: "stroustrup"
+// End:
+// ex: shiftwidth=4 tabstop=8
+
diff -Naur poly2tri.orig/poly2tri/sweep/sweep.h POLY2TRI_BLD/poly2tri/sweep/sweep.h
--- poly2tri.orig/poly2tri/sweep/sweep.h	2023-09-17 14:48:01.014182570 -0400
+++ POLY2TRI_BLD/poly2tri/sweep/sweep.h	2023-09-17 14:48:33.345620383 -0400
@@ -33,251 +33,241 @@
  * Zalik, B.(2008)'Sweep-line algorithm for constrained Delaunay triangulation',
  * International Journal of Geographical Information Science
  *
- * "FlipScan" Constrained Edge Algorithm invented by Thomas hln, thahlen@gmail.com
+ * "FlipScan" Constrained Edge Algorithm invented by Thomas ?hl?n, thahlen@gmail.com
  */
 
-#pragma once
+#ifndef SWEEP_H
+#define SWEEP_H
 
+#include <chrono>
 #include <vector>
 
+#define POLY2TRI_MAXTIME 2e4 // Time limit in microseconds
+
 namespace p2t {
 
-class SweepContext;
-struct Node;
-struct Point;
-struct Edge;
-class Triangle;
-
-class Sweep
-{
-public:
-
-  /**
-   * Triangulate
-   *
-   * @param tcx
-   */
-  void Triangulate(SweepContext& tcx);
-
-  /**
-   * Destructor - clean up memory
-   */
-  ~Sweep();
-
-private:
-
-  /**
-   * Start sweeping the Y-sorted point set from bottom to top
-   *
-   * @param tcx
-   */
-  void SweepPoints(SweepContext& tcx);
-
-  /**
-   * Find closes node to the left of the new point and
-   * create a new triangle. If needed new holes and basins
-   * will be filled to.
-   *
-   * @param tcx
-   * @param point
-   * @return
-   */
-  Node& PointEvent(SweepContext& tcx, Point& point);
-
-   /**
-     *
-     *
-     * @param tcx
-     * @param edge
-     * @param node
-     */
-  void EdgeEvent(SweepContext& tcx, Edge* edge, Node* node);
-
-  void EdgeEvent(SweepContext& tcx, Point& ep, Point& eq, Triangle* triangle, Point& point);
-
-  /**
-   * Creates a new front triangle and legalize it
-   *
-   * @param tcx
-   * @param point
-   * @param node
-   * @return
-   */
-  Node& NewFrontTriangle(SweepContext& tcx, Point& point, Node& node);
-
-  /**
-   * Adds a triangle to the advancing front to fill a hole.
-   * @param tcx
-   * @param node - middle node, that is the bottom of the hole
-   */
-  void Fill(SweepContext& tcx, Node& node);
-
-  /**
-   * Returns true if triangle was legalized
-   */
-  bool Legalize(SweepContext& tcx, Triangle& t);
-
-  /**
-   * <b>Requirement</b>:<br>
-   * 1. a,b and c form a triangle.<br>
-   * 2. a and d is know to be on opposite side of bc<br>
-   * <pre>
-   *                a
-   *                +
-   *               / \
-   *              /   \
-   *            b/     \c
-   *            +-------+
-   *           /    d    \
-   *          /           \
-   * </pre>
-   * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by
-   *  a,b and c<br>
-   *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>
-   *  This preknowledge gives us a way to optimize the incircle test
-   * @param a - triangle point, opposite d
-   * @param b - triangle point
-   * @param c - triangle point
-   * @param d - point opposite a
-   * @return true if d is inside circle, false if on circle edge
-   */
-  bool Incircle(const Point& pa, const Point& pb, const Point& pc, const Point& pd) const;
-
-  /**
-   * Rotates a triangle pair one vertex CW
-   *<pre>
-   *       n2                    n2
-   *  P +-----+             P +-----+
-   *    | t  /|               |\  t |
-   *    |   / |               | \   |
-   *  n1|  /  |n3           n1|  \  |n3
-   *    | /   |    after CW   |   \ |
-   *    |/ oT |               | oT \|
-   *    +-----+ oP            +-----+
-   *       n4                    n4
-   * </pre>
-   */
-  void RotateTrianglePair(Triangle& t, Point& p, Triangle& ot, Point& op) const;
-
-  /**
-   * Fills holes in the Advancing Front
-   *
-   *
-   * @param tcx
-   * @param n
-   */
-  void FillAdvancingFront(SweepContext& tcx, Node& n);
-
-  // Decision-making about when to Fill hole.
-  // Contributed by ToolmakerSteve2
-  bool LargeHole_DontFill(const Node* node) const;
-  bool AngleIsNegative(const Point* origin, const Point* pa, const Point* pb) const;
-  bool AngleExceeds90Degrees(const Point* origin, const Point* pa, const Point* pb) const;
-  bool AngleExceedsPlus90DegreesOrIsNegative(const Point* origin, const Point* pa, const Point* pb) const;
-  double Angle(const Point* origin, const Point* pa, const Point* pb) const;
-
-  /**
-   *
-   * @param node - middle node
-   * @return the angle between 3 front nodes
-   */
-  double HoleAngle(const Node& node) const;
-
-  /**
-   * The basin angle is decided against the horizontal line [1,0]
-   */
-  double BasinAngle(const Node& node) const;
-
-  /**
-   * Fills a basin that has formed on the Advancing Front to the right
-   * of given node.<br>
-   * First we decide a left,bottom and right node that forms the
-   * boundaries of the basin. Then we do a reqursive fill.
-   *
-   * @param tcx
-   * @param node - starting node, this or next node will be left node
-   */
-  void FillBasin(SweepContext& tcx, Node& node);
-
-  /**
-   * Recursive algorithm to fill a Basin with triangles
-   *
-   * @param tcx
-   * @param node - bottom_node
-   * @param cnt - counter used to alternate on even and odd numbers
-   */
-  void FillBasinReq(SweepContext& tcx, Node* node);
-
-  bool IsShallow(SweepContext& tcx, Node& node);
-
-  bool IsEdgeSideOfTriangle(Triangle& triangle, Point& ep, Point& eq);
-
-  void FillEdgeEvent(SweepContext& tcx, Edge* edge, Node* node);
-
-  void FillRightAboveEdgeEvent(SweepContext& tcx, Edge* edge, Node* node);
-
-  void FillRightBelowEdgeEvent(SweepContext& tcx, Edge* edge, Node& node);
-
-  void FillRightConcaveEdgeEvent(SweepContext& tcx, Edge* edge, Node& node);
-
-  void FillRightConvexEdgeEvent(SweepContext& tcx, Edge* edge, Node& node);
-
-  void FillLeftAboveEdgeEvent(SweepContext& tcx, Edge* edge, Node* node);
-
-  void FillLeftBelowEdgeEvent(SweepContext& tcx, Edge* edge, Node& node);
-
-  void FillLeftConcaveEdgeEvent(SweepContext& tcx, Edge* edge, Node& node);
-
-  void FillLeftConvexEdgeEvent(SweepContext& tcx, Edge* edge, Node& node);
-
-  void FlipEdgeEvent(SweepContext& tcx, Point& ep, Point& eq, Triangle* t, Point& p);
-
-  /**
-   * After a flip we have two triangles and know that only one will still be
-   * intersecting the edge. So decide which to contiune with and legalize the other
-   *
-   * @param tcx
-   * @param o - should be the result of an orient2d( eq, op, ep )
-   * @param t - triangle 1
-   * @param ot - triangle 2
-   * @param p - a point shared by both triangles
-   * @param op - another point shared by both triangles
-   * @return returns the triangle still intersecting the edge
-   */
-  Triangle& NextFlipTriangle(SweepContext& tcx, int o, Triangle&  t, Triangle& ot, Point& p, Point& op);
-
-   /**
-     * When we need to traverse from one triangle to the next we need
-     * the point in current triangle that is the opposite point to the next
-     * triangle.
-     *
-     * @param ep
-     * @param eq
-     * @param ot
-     * @param op
-     * @return
-     */
-  Point& NextFlipPoint(Point& ep, Point& eq, Triangle& ot, Point& op);
-
-   /**
-     * Scan part of the FlipScan algorithm<br>
-     * When a triangle pair isn't flippable we will scan for the next
-     * point that is inside the flip triangle scan area. When found
-     * we generate a new flipEdgeEvent
-     *
-     * @param tcx
-     * @param ep - last point on the edge we are traversing
-     * @param eq - first point on the edge we are traversing
-     * @param flipTriangle - the current triangle sharing the point eq with edge
-     * @param t
-     * @param p
-     */
-  void FlipScanEdgeEvent(SweepContext& tcx, Point& ep, Point& eq, Triangle& flip_triangle, Triangle& t, Point& p);
+    class SweepContext;
+    struct Node;
+    struct Point;
+    struct Edge;
+    class Triangle;
+
+    class Sweep
+    {
+	public:
+
+	    /**
+	     * Triangulate
+	     */
+	    void Triangulate(SweepContext& tcx, bool finalize = true, int num_points = -1, long maxtime = POLY2TRI_MAXTIME);
+
+	    /**
+	     * Destructor - clean up memory
+	     */
+	    ~Sweep();
+
+	private:
+
+	    /**
+	     * Start sweeping the Y-sorted point set from bottom to top
+	     */
+	    void SweepPoints(SweepContext& tcx, int num_points = -1);
+
+	    /**
+	     * Find closes node to the left of the new point and
+	     * create a new triangle. If needed new holes and basins
+	     * will be filled to.
+	     *
+	     */
+	    Node& PointEvent(SweepContext& tcx, Point& point);
+
+	    void EdgeEvent(SweepContext& tcx, Edge* edge, Node* node);
+
+	    void EdgeEvent(SweepContext& tcx, Point& ep, Point& eq, Triangle* triangle, Point& point);
+
+	    /**
+	     * Creates a new front triangle and legalize it
+	     *
+	     */
+	    Node& NewFrontTriangle(SweepContext& tcx, Point& point, Node& node);
+	    void UpdateNodeAngleCircum(Node& n);
+	    /**
+	     * Adds a triangle to the advancing front to fill a hole.
+	     * @param tcx - sweep context
+	     * @param node - middle node, that is the bottom of the hole
+	     */
+	    void Fill(SweepContext& tcx, Node& node);
+
+	    /**
+	     * Returns true if triangle was legalized
+	     */
+	    bool Legalize(SweepContext& tcx, Triangle& t);
+
+	    /**
+	     * <b>Requirement</b>:<br>
+	     * 1. a,b and c form a triangle.<br>
+	     * 2. a and d is know to be on opposite side of bc<br>
+	     * <pre>
+	     *                a
+	     *                +
+	     *               / \
+	     *              /   \
+	     *            b/     \c
+	     *            +-------+
+	     *           /    d    \
+	     *          /           \
+	     * </pre>
+	     * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by
+	     *  a,b and c<br>
+	     *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>
+	     *  This preknowledge gives us a way to optimize the incircle test
+	     * @param pa - triangle point, opposite d
+	     * @param pb - triangle point
+	     * @param pc - triangle point
+	     * @param pd - point opposite a
+	     * @return true if d is inside circle, false if on circle edge
+	     */
+	    bool Incircle(Point& pa, Point& pb, Point& pc, Point& pd);
+	    bool Circumcircle(const Point& pa, const Point& pb, const Point& pc, Point& center, double& radius);
+
+	    /**
+	     * Rotates a triangle pair one vertex CW
+	     *<pre>
+	     *       n2                    n2
+	     *  P +-----+             P +-----+
+	     *    | t  /|               |\  t |
+	     *    |   / |               | \   |
+	     *  n1|  /  |n3           n1|  \  |n3
+	     *    | /   |    after CW   |   \ |
+	     *    |/ oT |               | oT \|
+	     *    +-----+ oP            +-----+
+	     *       n4                    n4
+	     * </pre>
+	     */
+	    void RotateTrianglePair(Triangle& t, Point& p, Triangle& ot, Point& op);
+
+	    /**
+	     * Fills holes in the Advancing Front
+	     */
+	    void CheckCircleEvent(SweepContext& tcx, double currentheight);
+	    void FillAdvancingFront(SweepContext& tcx, Node& n);
+
+	    // Decision-making about when to Fill hole.
+	    // Contributed by ToolmakerSteve2
+	    bool LargeHole_DontFill(const Node* node) const;
+	    bool AngleIsNegative(const Point* origin, const Point* pa, const Point* pb) const;
+	    bool AngleExceeds90Degrees(const Point* origin, const Point* pa, const Point* pb) const;
+	    bool AngleExceedsPlus90DegreesOrIsNegative(const Point* origin, const Point* pa, const Point* pb) const;
+	    double Angle(const Point& origin, const Point& pa, const Point& pb) const;
+
+	    /**
+	     *
+	     * @param node - middle node
+	     * @return the angle between 3 front nodes
+	     */
+	    double HoleAngle(Node& node);
+
+	    /**
+	     * The basin angle is decided against the horizontal line [1,0]
+	     */
+	    double BasinAngle(Node& node);
+
+	    /**
+	     * Fills a basin that has formed on the Advancing Front to the right
+	     * of given node.<br>
+	     * First we decide a left,bottom and right node that forms the
+	     * boundaries of the basin. Then we do a reqursive fill.
+	     *
+	     * @param node - starting node, this or next node will be left node
+	     */
+	    void FillBasin(SweepContext& tcx, Node& node);
+
+	    /**
+	     * Recursive algorithm to fill a Basin with triangles
+	     *
+	     * @param node - bottom_node
+	     */
+	    void FillBasinReq(SweepContext& tcx, Node* node);
+
+	    bool IsShallow(SweepContext& tcx, Node& node);
+
+	    bool IsEdgeSideOfTriangle(Triangle& triangle, Point& ep, Point& eq);
+
+	    void FillEdgeEvent(SweepContext& tcx, Edge* edge, Node* node);
+
+	    void FillRightAboveEdgeEvent(SweepContext& tcx, Edge* edge, Node* node);
+
+	    void FillRightBelowEdgeEvent(SweepContext& tcx, Edge* edge, Node& node);
+
+	    void FillRightConcaveEdgeEvent(SweepContext& tcx, Edge* edge, Node& node);
+
+	    void FillRightConvexEdgeEvent(SweepContext& tcx, Edge* edge, Node& node);
+
+	    void FillLeftAboveEdgeEvent(SweepContext& tcx, Edge* edge, Node* node);
+
+	    void FillLeftBelowEdgeEvent(SweepContext& tcx, Edge* edge, Node& node);
+
+	    void FillLeftConcaveEdgeEvent(SweepContext& tcx, Edge* edge, Node& node);
+
+	    void FillLeftConvexEdgeEvent(SweepContext& tcx, Edge* edge, Node& node);
+
+	    void FlipEdgeEvent(SweepContext& tcx, Point& ep, Point& eq, Triangle* t, Point& p);
+
+	    /**
+	     * After a flip we have two triangles and know that only one will still be
+	     * intersecting the edge. So decide which to contiune with and legalize the other
+	     *
+	     * @param o - should be the result of an orient2d( eq, op, ep )
+	     * @param t - triangle 1
+	     * @param ot - triangle 2
+	     * @param p - a point shared by both triangles
+	     * @param op - another point shared by both triangles
+	     * @return returns the triangle still intersecting the edge
+	     */
+	    Triangle& NextFlipTriangle(SweepContext& tcx, int o, Triangle&  t, Triangle& ot, Point& p, Point& op);
+
+	    /**
+	     * When we need to traverse from one triangle to the next we need
+	     * the point in current triangle that is the opposite point to the next
+	     * triangle.
+	     */
+	    Point& NextFlipPoint(Point& ep, Point& eq, Triangle& ot, Point& op);
+
+	    /**
+	     * Scan part of the FlipScan algorithm<br>
+	     * When a triangle pair isn't flippable we will scan for the next
+	     * point that is inside the flip triangle scan area. When found
+	     * we generate a new flipEdgeEvent
+	     *
+	     * @param ep - last point on the edge we are traversing
+	     * @param eq - first point on the edge we are traversing
+	     * @param flip_triangle - the current triangle sharing the point eq with edge
+	     */
+	    void FlipScanEdgeEvent(SweepContext& tcx, Point& ep, Point& eq, Triangle& flip_triangle, Triangle& t, Point& p);
+
+	    Triangle* FindInternalTriangle(Triangle* ext_tri);
+
+	    void FinalizationPolygon(SweepContext& tcx);
+
+	    std::vector<Node*> nodes_;
+
+	    int flip_edge_event_cnt = 0;
+
+	    std::chrono::time_point<std::chrono::steady_clock> tri_start_time;
+	    std::chrono::time_point<std::chrono::steady_clock> curr_time;
+	    long timeout;
+    };
 
-  void FinalizationPolygon(SweepContext& tcx);
+}
 
-  std::vector<Node*> nodes_;
+#endif
 
-};
+// Local Variables:
+// tab-width: 8
+// mode: C++
+// c-basic-offset: 4
+// indent-tabs-mode: t
+// c-file-style: "stroustrup"
+// End:
+// ex: shiftwidth=4 tabstop=8
 
-}
diff -Naur poly2tri.orig/README.md POLY2TRI_BLD/README.md
--- poly2tri.orig/README.md	2023-09-17 14:48:01.014182570 -0400
+++ POLY2TRI_BLD/README.md	2023-09-17 14:48:33.345620383 -0400
@@ -1,4 +1,11 @@
-Since there are no Input validation of the data given for triangulation you need
+poly2tri is a C++ library for creating a constrained Delaunay triangulation
+(CDT) of a polygon using a sweep-line algorithm. This specific version of
+poly2tri  is a fork off of the github project git://github.com/jhasse/poly2tri.git
+which in turn is a cleaned up version of the google 'poly2tri' project based
+on the paper "Sweep-line algorithm for constrained Delaunay triangulation" by
+V. Domiter and and B. Zalik.
+
+Since there are no Input validation of the data given for triangulation you need
 to think about this. Poly2Tri does not support repeat points within epsilon.
 
 * If you have a cyclic function that generates random points make sure you don't
@@ -27,44 +34,29 @@
 
 * Standard Template Library (STL)
 
-Unit tests:
-* Boost (filesystem, test framework)
-
 Testbed:
 
+* gcc
 * OpenGL
 * [GLFW](http://glfw.sf.net)
+* Python
 
-Build the library
------------------
+[waf](http://code.google.com/p/waf/) is used to compile the testbed.
+A waf script (86kb) is included in the repositoty.
 
-With the ninja build system installed:
+Building the Testbed
+--------------------
 
+Posix/MSYS environment:
 ```
-mkdir build && cd build
-cmake -GNinja ..
-cmake --build .
+./waf configure
+./waf build
 ```
 
-Build and run with unit tests
-----------------------------
-
-With the ninja build system:
-
+Windows command line:
 ```
-mkdir build && cd build
-cmake -GNinja -DP2T_BUILD_TESTS=ON ..
-cmake --build .
-ctest --output-on-failure
-```
-
-Build with the testbed
------------------
-
-```
-mkdir build && cd build
-cmake -GNinja -DP2T_BUILD_TESTBED=ON ..
-cmake --build .
+python waf configure
+python waf build
 ```
 
 Running the Examples
@@ -72,30 +64,17 @@
 
 Load data points from a file:
 ```
-build/testbed/p2t <filename> <center_x> <center_y> <zoom>
-```
-Load data points from a file and automatically fit the geometry to the window:
+p2t <filename> <center_x> <center_y> <zoom>
 ```
-build/testbed/p2t <filename>
+Random distribution of points inside a consrained box:
 ```
-Random distribution of points inside a constrained box:
-```
-build/testbed/p2t random <num_points> <box_radius> <zoom>
+p2t random <num_points> <box_radius> <zoom>
 ```
 Examples:
 ```
-build/testbed/p2t testbed/data/dude.dat 350 500 3
-
-build/testbed/p2t testbed/data/nazca_monkey.dat
-
-build/testbed/p2t random 10 100 5.0
-build/testbed/p2t random 1000 20000 0.025
-```
-
-References
-==========
+./p2t dude.dat 300 500 2
+./p2t nazca_monkey.dat 0 0 9
 
-- Domiter V. and Zalik B. (2008) Sweepline algorithm for constrained Delaunay triangulation
-- FlipScan by library author Thomas hln
+./p2t random 10 100 5.0
+./p2t random 1000 20000 0.025
 
-![FlipScan](doc/FlipScan.png)
